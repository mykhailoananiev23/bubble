/*!
 *  howler.js v2.1.1
 *  howlerjs.com
 *
 *  (c) 2013-2018, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this on certain browsers/devices.
      var shouldUnlock = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi|Chrome|Safari/i.test(self._navigator && self._navigator.userAgent);
      if (self._audioUnlocked || !self.ctx || !shouldUnlock) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        for (var i=0; i<self.html5PoolSize; i++) {
          var audioNode = new Audio();

          // Mark this Audio object as unlocked to ensure it can get returned
          // to the unlocked pool when released.
          audioNode._unlocked = true;

          // Add the audio node to the pool.
          self._releaseHtml5Audio(audioNode);
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';
        self.ctx.suspend().then(function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        });
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhrWithCredentials = o.xhrWithCredentials || false;

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload) {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended. 
        // If there is, play that sound. If not, continue as usual.  
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      var loop = !!(sound._loop || self._sprite[sprite][2]);
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = loop;
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
              self._loadQueue();
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;

          var listener = function() {
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = parseFloat(from);
      to = parseFloat(to);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Make sure the volume is in the right bounds.
        vol = Math.max(0, vol);
        vol = Math.min(1, vol);

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return self;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            self._emit('seek', id);

            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
          if (!checkIE) {
            sounds[i]._node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
          }

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = 'auto';
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.withCredentials = self._xhrWithCredentials;
      xhr.responseType = 'arraybuffer';
      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : 1, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (typeof define === 'function' && define.amd) {
    define([], function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    });
  }

  // Add support for CommonJS libraries such as browserify.
  if (typeof exports !== 'undefined') {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Define globally in case AMD is not available or unused.
  if (typeof window !== 'undefined') {
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  }
})();

/**
 * Created by Andrewz on 3/29/19.
 */
(function() {
  var blankSound = new Howl({
    src: [""],
    html5: true, // Force to HTML5 so that the audio can stream in (best for large files).
    preload: false
  });
  blankSound.once("unlock", function() {
    HowlerGlobal.unlocked = true;
  });
}());

/**
 * Created by Andrewz on 3/25/19.
 */
// 可以播放1个声音， 或者多个声音，由playlist指定
var TQ = TQ || {};
(function() {
  var MAX_SOUND_LENGTH = 120; // 缺省声音是最大120s
  var STATE = {
    UNLOADED: 1,
    PLAYING: 2,
    PAUSED: 3,
    ENDED: 4
  };

  function HowlerPlayer(url, sprite, spriteMap) {
    var self = this;
    var canPreload = !!HowlerGlobal.unlocked;

    this.state = STATE.UNLOADED;
    this.howlerID = -1;
    this.tryingToPlay = false;
    var config = {
      src: [TQ.RM.toFullPathFs(url)],
      html5: true, // Force to HTML5 so that the audio can stream in (best for large files).
      preload: canPreload,
      onplay: function() {
        self.state = STATE.PLAYING;
        self.tryingToPlay = false;
      },
      onload: function() {
        TQ.Log.info("loaded...");
      },
      onend: function() {
        TQ.Log.info("end...");
        self.state = STATE.ENDED;
      },
      onpause: function() {
        TQ.Log.info("pause...");
        self.state = STATE.PAUSED;
      },
      onstop: function() {
        TQ.Log.info("stop...");
        self.state = STATE.PAUSED;
      },
      onseek: function() {
        TQ.Log.info("seek...");
      }
    };
    if (sprite) {
      config.sprite = sprite;
      if (spriteMap) {
        this.spriteMap = spriteMap;
      }
    }

    this.howl = new Howl(config);
    var sound = self.howl;
    if (!canPreload) {
      sound.once("unlock", function() {
        sound.load();
      });
    }
  }

  HowlerPlayer.prototype = {
    play: function(spriteName) {
      var self = this;
      var sound = self.howl;
      if (self.tryingToPlay) {
        return;
      }

      if (!sound.playing()) { // 同时只有1个实例在播放，不能多个实例{
        if (self.howlerID < 0) {
          if ((sound.state() === "unloaded") && !TQUtility.isBlobUrl(sound._src[0])) {
            sound.once("load", function() {
              self.howlerID = sound.play(spriteName);
            });
            self.tryingToPlay = true;
          } else {
            self.howlerID = sound.play(spriteName); // 首次播放
          }
        } else {
          TQ.AssertExt(sound, "需要先建立audio对象");
          TQDebugger.Panel.logInfo("resume, " + sound._sounds.length);
          // Begin playing the sound.
          var newID = sound.play(spriteName || self.howlerID);
          if (newID !== self.howlerID) {
            if (newID > 0) {
              if (self.howlerID !== newID) {
                console.error("为什么不相等？");
                self.howlerID = newID;
              }
            } else {
              //  虽然曾经存在，但是已经当做垃圾回收了
              self.howlerID = sound.play(spriteName);
            }
          }
        }
      }
    },

    get duration() {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");

      if (!sound) {
        return 0;
      }

      return 1000 * ((sound.state() !== "loaded") ? MAX_SOUND_LENGTH : sound.duration());
    },

    get paused() {
      return (this.state === STATE.PAUSED);
    },

    /**
     * Pause the currently playing track.
     */
    pause: function() {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");

      if (sound) {
        sound.pause();
      }

      TQ.Log.info("pause...");
    },

    stop: function() {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");

      if (sound) {
        sound.stop();
      }

      TQ.Log.info("stopped...");
    },

    resume: function(t, spriteName) {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");
      TQDebugger.Panel.logInfo("resume, " + sound._sounds.length);
      if (sound._sounds.length > 1) {
        // sound.stop();
        // setTimeout(function() {sound.play();}, 100);
      }
      if (sound) {
        if (t > self.duration) {
          self.stop();
        } else {
          if (sound.playing()) {
            // sound.seek(t, self.howlerID);
          } else {
            // sound.once('play', function () {
            //   sound.seek(t, self.howlerID);
            // });
            self.play(spriteName || self.howlerID);
          }
        }
      }
    },

    /**
     * Set the volume and update the volume slider display.
     * @param  {Number} val Volume between 0 and 1.
     */
    volume: function(val) {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");
      sound.volume(val);
      TQ.Log.info("volume " + val);
    },

    seek: function(t) {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");

      // Convert the percent into a seek position.
      if (sound && sound.playing()) {
        sound.seek(t);
      }
    },

    setPosition: function(t) {
      this.seek(t);
    },

    /**
     * The step called within requestAnimationFrame to update the playback position.
     */
    step: function() {
      var self = this;
      var sound = self.howl;
      TQ.AssertExt(sound, "需要先建立audio对象");

      if (sound) {
        var seek = sound.seek() || 0;
      }
      TQ.Log.info(self.formatTime(Math.round(seek)));
    },

    isPlaying: function() {
      return (this.howl.playing());
    },

    hasCompleted: function() {
      return (this.state === STATE.ENDED);
    },
    /**
     * Format the time from seconds to M:SS.
     * @param  {Number} secs Seconds to format.
     * @return {String}      Formatted time.
     */
    formatTime: function(secs) {
      var minutes = Math.floor(secs / 60) || 0;
      var seconds = (secs - minutes * 60) || 0;

      return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
    }
  };

  TQ.HowlerPlayer = HowlerPlayer;
}());

!function(e,n){"function"==typeof define&&(define.amd||define.cmd)?define(function(){return n(e)}):n(e,!0)}(this,function(e,n){function i(n,i,t){e.WeixinJSBridge?WeixinJSBridge.invoke(n,o(i),function(e){c(n,e,t)}):u(n,t)}function t(n,i,t){e.WeixinJSBridge?WeixinJSBridge.on(n,function(e){t&&t.trigger&&t.trigger(e),c(n,e,i)}):t?u(n,t):u(n,i)}function o(e){return e=e||{},e.appId=C.appId,e.verifyAppId=C.appId,e.verifySignType="sha1",e.verifyTimestamp=C.timestamp+"",e.verifyNonceStr=C.nonceStr,e.verifySignature=C.signature,e}function r(e){return{timeStamp:e.timestamp+"",nonceStr:e.nonceStr,package:e.package,paySign:e.paySign,signType:e.signType||"SHA1"}}function a(e){return e.postalCode=e.addressPostalCode,delete e.addressPostalCode,e.provinceName=e.proviceFirstStageName,delete e.proviceFirstStageName,e.cityName=e.addressCitySecondStageName,delete e.addressCitySecondStageName,e.countryName=e.addressCountiesThirdStageName,delete e.addressCountiesThirdStageName,e.detailInfo=e.addressDetailInfo,delete e.addressDetailInfo,e}function c(e,n,i){"openEnterpriseChat"==e&&(n.errCode=n.err_code),delete n.err_code,delete n.err_desc,delete n.err_detail;var t=n.errMsg;t||(t=n.err_msg,delete n.err_msg,t=s(e,t),n.errMsg=t),(i=i||{})._complete&&(i._complete(n),delete i._complete),t=n.errMsg||"",C.debug&&!i.isInnerInvoke&&alert(JSON.stringify(n));var o=t.indexOf(":");switch(t.substring(o+1)){case"ok":i.success&&i.success(n);break;case"cancel":i.cancel&&i.cancel(n);break;default:i.fail&&i.fail(n)}i.complete&&i.complete(n)}function s(e,n){var i=e,t=v[i];t&&(i=t);var o="ok";if(n){var r=n.indexOf(":");"confirm"==(o=n.substring(r+1))&&(o="ok"),"failed"==o&&(o="fail"),-1!=o.indexOf("failed_")&&(o=o.substring(7)),-1!=o.indexOf("fail_")&&(o=o.substring(5)),"access denied"!=(o=(o=o.replace(/_/g," ")).toLowerCase())&&"no permission to execute"!=o||(o="permission denied"),"config"==i&&"function not exist"==o&&(o="ok"),""==o&&(o="fail")}return n=i+":"+o}function d(e){if(e){for(var n=0,i=e.length;n<i;++n){var t=e[n],o=h[t];o&&(e[n]=o)}return e}}function u(e,n){if(!(!C.debug||n&&n.isInnerInvoke)){var i=v[e];i&&(e=i),n&&n._complete&&delete n._complete,console.log('"'+e+'",',n||"")}}function l(e){if(!(k||w||C.debug||x<"6.0.2"||V.systemType<0)){var n=new Image;V.appId=C.appId,V.initTime=A.initEndTime-A.initStartTime,V.preVerifyTime=A.preVerifyEndTime-A.preVerifyStartTime,N.getNetworkType({isInnerInvoke:!0,success:function(e){V.networkType=e.networkType;var i="https://open.weixin.qq.com/sdk/report?v="+V.version+"&o="+V.isPreVerifyOk+"&s="+V.systemType+"&c="+V.clientVersion+"&a="+V.appId+"&n="+V.networkType+"&i="+V.initTime+"&p="+V.preVerifyTime+"&u="+V.url;n.src=i}})}}function p(){return(new Date).getTime()}function f(n){T&&(e.WeixinJSBridge?n():S.addEventListener&&S.addEventListener("WeixinJSBridgeReady",n,!1))}function m(){N.invoke||(N.invoke=function(n,i,t){e.WeixinJSBridge&&WeixinJSBridge.invoke(n,o(i),t)},N.on=function(n,i){e.WeixinJSBridge&&WeixinJSBridge.on(n,i)})}function g(e){if("string"==typeof e&&e.length>0){var n=e.split("?")[0],i=e.split("?")[1];return n+=".html",void 0!==i?n+"?"+i:n}}if(!e.jWeixin){var h={config:"preVerifyJSAPI",onMenuShareTimeline:"menu:share:timeline",onMenuShareAppMessage:"menu:share:appmessage",onMenuShareQQ:"menu:share:qq",onMenuShareWeibo:"menu:share:weiboApp",onMenuShareQZone:"menu:share:QZone",previewImage:"imagePreview",getLocation:"geoLocation",openProductSpecificView:"openProductViewWithPid",addCard:"batchAddCard",openCard:"batchViewCard",chooseWXPay:"getBrandWCPayRequest",openEnterpriseRedPacket:"getRecevieBizHongBaoRequest",startSearchBeacons:"startMonitoringBeacons",stopSearchBeacons:"stopMonitoringBeacons",onSearchBeacons:"onBeaconsInRange",consumeAndShareCard:"consumedShareCard",openAddress:"editAddress"},v=function(){var e={};for(var n in h)e[h[n]]=n;return e}(),S=e.document,I=S.title,y=navigator.userAgent.toLowerCase(),_=navigator.platform.toLowerCase(),k=!(!_.match("mac")&&!_.match("win")),w=-1!=y.indexOf("wxdebugger"),T=-1!=y.indexOf("micromessenger"),M=-1!=y.indexOf("android"),P=-1!=y.indexOf("iphone")||-1!=y.indexOf("ipad"),x=function(){var e=y.match(/micromessenger\/(\d+\.\d+\.\d+)/)||y.match(/micromessenger\/(\d+\.\d+)/);return e?e[1]:""}(),A={initStartTime:p(),initEndTime:0,preVerifyStartTime:0,preVerifyEndTime:0},V={version:1,appId:"",initTime:0,preVerifyTime:0,networkType:"",isPreVerifyOk:1,systemType:P?1:M?2:-1,clientVersion:x,url:encodeURIComponent(location.href)},C={},L={_completes:[]},B={state:0,data:{}};f(function(){A.initEndTime=p()});var O=!1,E=[],N={config:function(e){C=e,u("config",e);var n=!1!==C.check;f(function(){if(n)i(h.config,{verifyJsApiList:d(C.jsApiList)},function(){L._complete=function(e){A.preVerifyEndTime=p(),B.state=1,B.data=e},L.success=function(e){V.isPreVerifyOk=0},L.fail=function(e){L._fail?L._fail(e):B.state=-1};var e=L._completes;return e.push(function(){l()}),L.complete=function(n){for(var i=0,t=e.length;i<t;++i)e[i]();L._completes=[]},L}()),A.preVerifyStartTime=p();else{B.state=1;for(var e=L._completes,t=0,o=e.length;t<o;++t)e[t]();L._completes=[]}}),m()},ready:function(e){0!=B.state?e():(L._completes.push(e),!T&&C.debug&&e())},error:function(e){x<"6.0.2"||(-1==B.state?e(B.data):L._fail=e)},checkJsApi:function(e){var n=function(e){var n=e.checkResult;for(var i in n){var t=v[i];t&&(n[t]=n[i],delete n[i])}return e};i("checkJsApi",{jsApiList:d(e.jsApiList)},(e._complete=function(e){if(M){var i=e.checkResult;i&&(e.checkResult=JSON.parse(i))}e=n(e)},e))},onMenuShareTimeline:function(e){t(h.onMenuShareTimeline,{complete:function(){i("shareTimeline",{title:e.title||I,desc:e.title||I,img_url:e.imgUrl||"",link:e.link||location.href,type:e.type||"link",data_url:e.dataUrl||""},e)}},e)},onMenuShareAppMessage:function(e){t(h.onMenuShareAppMessage,{complete:function(n){"favorite"===n.scene?i("sendAppMessage",{title:e.title||I,desc:e.desc||"",link:e.link||location.href,img_url:e.imgUrl||"",type:e.type||"link",data_url:e.dataUrl||""}):i("sendAppMessage",{title:e.title||I,desc:e.desc||"",link:e.link||location.href,img_url:e.imgUrl||"",type:e.type||"link",data_url:e.dataUrl||""},e)}},e)},onMenuShareQQ:function(e){t(h.onMenuShareQQ,{complete:function(){i("shareQQ",{title:e.title||I,desc:e.desc||"",img_url:e.imgUrl||"",link:e.link||location.href},e)}},e)},onMenuShareWeibo:function(e){t(h.onMenuShareWeibo,{complete:function(){i("shareWeiboApp",{title:e.title||I,desc:e.desc||"",img_url:e.imgUrl||"",link:e.link||location.href},e)}},e)},onMenuShareQZone:function(e){t(h.onMenuShareQZone,{complete:function(){i("shareQZone",{title:e.title||I,desc:e.desc||"",img_url:e.imgUrl||"",link:e.link||location.href},e)}},e)},updateTimelineShareData:function(e){i("updateTimelineShareData",{title:e.title,link:e.link,imgUrl:e.imgUrl},e)},updateAppMessageShareData:function(e){i("updateAppMessageShareData",{title:e.title,desc:e.desc,link:e.link,imgUrl:e.imgUrl},e)},startRecord:function(e){i("startRecord",{},e)},stopRecord:function(e){i("stopRecord",{},e)},onVoiceRecordEnd:function(e){t("onVoiceRecordEnd",e)},playVoice:function(e){i("playVoice",{localId:e.localId},e)},pauseVoice:function(e){i("pauseVoice",{localId:e.localId},e)},stopVoice:function(e){i("stopVoice",{localId:e.localId},e)},onVoicePlayEnd:function(e){t("onVoicePlayEnd",e)},uploadVoice:function(e){i("uploadVoice",{localId:e.localId,isShowProgressTips:0==e.isShowProgressTips?0:1},e)},downloadVoice:function(e){i("downloadVoice",{serverId:e.serverId,isShowProgressTips:0==e.isShowProgressTips?0:1},e)},translateVoice:function(e){i("translateVoice",{localId:e.localId,isShowProgressTips:0==e.isShowProgressTips?0:1},e)},chooseImage:function(e){i("chooseImage",{scene:"1|2",count:e.count||9,sizeType:e.sizeType||["original","compressed"],sourceType:e.sourceType||["album","camera"]},(e._complete=function(e){if(M){var n=e.localIds;try{n&&(e.localIds=JSON.parse(n))}catch(e){}}},e))},getLocation:function(e){},previewImage:function(e){i(h.previewImage,{current:e.current,urls:e.urls},e)},uploadImage:function(e){i("uploadImage",{localId:e.localId,isShowProgressTips:0==e.isShowProgressTips?0:1},e)},downloadImage:function(e){i("downloadImage",{serverId:e.serverId,isShowProgressTips:0==e.isShowProgressTips?0:1},e)},getLocalImgData:function(e){!1===O?(O=!0,i("getLocalImgData",{localId:e.localId},(e._complete=function(e){if(O=!1,E.length>0){var n=E.shift();wx.getLocalImgData(n)}},e))):E.push(e)},getNetworkType:function(e){var n=function(e){var n=e.errMsg;e.errMsg="getNetworkType:ok";var i=e.subtype;if(delete e.subtype,i)e.networkType=i;else{var t=n.indexOf(":"),o=n.substring(t+1);switch(o){case"wifi":case"edge":case"wwan":e.networkType=o;break;default:e.errMsg="getNetworkType:fail"}}return e};i("getNetworkType",{},(e._complete=function(e){e=n(e)},e))},openLocation:function(e){i("openLocation",{latitude:e.latitude,longitude:e.longitude,name:e.name||"",address:e.address||"",scale:e.scale||28,infoUrl:e.infoUrl||""},e)},getLocation:function(e){e=e||{},i(h.getLocation,{type:e.type||"wgs84"},(e._complete=function(e){delete e.type},e))},hideOptionMenu:function(e){i("hideOptionMenu",{},e)},showOptionMenu:function(e){i("showOptionMenu",{},e)},closeWindow:function(e){i("closeWindow",{},e=e||{})},hideMenuItems:function(e){i("hideMenuItems",{menuList:e.menuList},e)},showMenuItems:function(e){i("showMenuItems",{menuList:e.menuList},e)},hideAllNonBaseMenuItem:function(e){i("hideAllNonBaseMenuItem",{},e)},showAllNonBaseMenuItem:function(e){i("showAllNonBaseMenuItem",{},e)},scanQRCode:function(e){i("scanQRCode",{needResult:(e=e||{}).needResult||0,scanType:e.scanType||["qrCode","barCode"]},(e._complete=function(e){if(P){var n=e.resultStr;if(n){var i=JSON.parse(n);e.resultStr=i&&i.scan_code&&i.scan_code.scan_result}}},e))},openAddress:function(e){i(h.openAddress,{},(e._complete=function(e){e=a(e)},e))},openProductSpecificView:function(e){i(h.openProductSpecificView,{pid:e.productId,view_type:e.viewType||0,ext_info:e.extInfo},e)},addCard:function(e){for(var n=e.cardList,t=[],o=0,r=n.length;o<r;++o){var a=n[o],c={card_id:a.cardId,card_ext:a.cardExt};t.push(c)}i(h.addCard,{card_list:t},(e._complete=function(e){var n=e.card_list;if(n){for(var i=0,t=(n=JSON.parse(n)).length;i<t;++i){var o=n[i];o.cardId=o.card_id,o.cardExt=o.card_ext,o.isSuccess=!!o.is_succ,delete o.card_id,delete o.card_ext,delete o.is_succ}e.cardList=n,delete e.card_list}},e))},chooseCard:function(e){i("chooseCard",{app_id:C.appId,location_id:e.shopId||"",sign_type:e.signType||"SHA1",card_id:e.cardId||"",card_type:e.cardType||"",card_sign:e.cardSign,time_stamp:e.timestamp+"",nonce_str:e.nonceStr},(e._complete=function(e){e.cardList=e.choose_card_info,delete e.choose_card_info},e))},openCard:function(e){for(var n=e.cardList,t=[],o=0,r=n.length;o<r;++o){var a=n[o],c={card_id:a.cardId,code:a.code};t.push(c)}i(h.openCard,{card_list:t},e)},consumeAndShareCard:function(e){i(h.consumeAndShareCard,{consumedCardId:e.cardId,consumedCode:e.code},e)},chooseWXPay:function(e){i(h.chooseWXPay,r(e),e)},openEnterpriseRedPacket:function(e){i(h.openEnterpriseRedPacket,r(e),e)},startSearchBeacons:function(e){i(h.startSearchBeacons,{ticket:e.ticket},e)},stopSearchBeacons:function(e){i(h.stopSearchBeacons,{},e)},onSearchBeacons:function(e){t(h.onSearchBeacons,e)},openEnterpriseChat:function(e){i("openEnterpriseChat",{useridlist:e.userIds,chatname:e.groupName},e)},launchMiniProgram:function(e){i("launchMiniProgram",{targetAppId:e.targetAppId,path:g(e.path),envVersion:e.envVersion},e)},miniProgram:{navigateBack:function(e){e=e||{},f(function(){i("invokeMiniProgramAPI",{name:"navigateBack",arg:{delta:e.delta||1}},e)})},navigateTo:function(e){f(function(){i("invokeMiniProgramAPI",{name:"navigateTo",arg:{url:e.url}},e)})},redirectTo:function(e){f(function(){i("invokeMiniProgramAPI",{name:"redirectTo",arg:{url:e.url}},e)})},switchTab:function(e){f(function(){i("invokeMiniProgramAPI",{name:"switchTab",arg:{url:e.url}},e)})},reLaunch:function(e){f(function(){i("invokeMiniProgramAPI",{name:"reLaunch",arg:{url:e.url}},e)})},postMessage:function(e){f(function(){i("invokeMiniProgramAPI",{name:"postMessage",arg:e.data||{}},e)})},getEnv:function(n){f(function(){n({miniprogram:"miniprogram"===e.__wxjs_environment})})}}},b=1,R={};return S.addEventListener("error",function(e){if(!M){var n=e.target,i=n.tagName,t=n.src;if(("IMG"==i||"VIDEO"==i||"AUDIO"==i||"SOURCE"==i)&&-1!=t.indexOf("wxlocalresource://")){e.preventDefault(),e.stopPropagation();var o=n["wx-id"];if(o||(o=b++,n["wx-id"]=o),R[o])return;R[o]=!0,wx.ready(function(){wx.getLocalImgData({localId:t,success:function(e){n.src=e.localData}})})}}},!0),S.addEventListener("load",function(e){if(!M){var n=e.target,i=n.tagName;n.src;if("IMG"==i||"VIDEO"==i||"AUDIO"==i||"SOURCE"==i){var t=n["wx-id"];t&&(R[t]=!1)}}},!0),n&&(e.wx=e.jWeixin=N),N}});
/* global define, URL, webkitURL, FileReader */

;(function ($) {
  'use strict'

  // Loads an image for a given File object.
  // Invokes the callback with an img or optional canvas
  // element (if supported by the browser) as parameter:
  function loadImage (file, callback, options) {
    var img = document.createElement('img')
    var url
    img.onerror = function (event) {
      return loadImage.onerror(img, event, file, callback, options)
    }
    img.onload = function (event) {
      return loadImage.onload(img, event, file, callback, options)
    }
    if (typeof file === 'string') {
      loadImage.fetchBlob(file, function (blob) {
        if (blob) {
          file = blob
          url = loadImage.createObjectURL(file)
        } else {
          url = file
          if (options && options.crossOrigin) {
            img.crossOrigin = options.crossOrigin
          }
        }
        img.src = url
      }, options)
      return img
    } else if (loadImage.isInstanceOf('Blob', file) ||
        // Files are also Blob instances, but some browsers
        // (Firefox 3.6) support the File API but not Blobs:
        loadImage.isInstanceOf('File', file)) {
      url = img._objectURL = loadImage.createObjectURL(file)
      if (url) {
        img.src = url
        return img
      }
      return loadImage.readFile(file, function (e) {
        var target = e.target
        if (target && target.result) {
          img.src = target.result
        } else if (callback) {
          callback(e)
        }
      })
    }
  }
  // The check for URL.revokeObjectURL fixes an issue with Opera 12,
  // which provides URL.createObjectURL but doesn't properly implement it:
  var urlAPI = ($.createObjectURL && $) ||
                ($.URL && URL.revokeObjectURL && URL) ||
                ($.webkitURL && webkitURL)

  function revokeHelper (img, options) {
    if (img._objectURL && !(options && options.noRevoke)) {
      loadImage.revokeObjectURL(img._objectURL)
      delete img._objectURL
    }
  }

  // If the callback given to this function returns a blob, it is used as image
  // source instead of the original url and overrides the file argument used in
  // the onload and onerror event callbacks:
  loadImage.fetchBlob = function (url, callback, options) {
    callback()
  }

  loadImage.isInstanceOf = function (type, obj) {
    // Cross-frame instanceof check
    return Object.prototype.toString.call(obj) === '[object ' + type + ']'
  }

  loadImage.transform = function (img, options, callback, file, data) {
    callback(img, data)
  }

  loadImage.onerror = function (img, event, file, callback, options) {
    revokeHelper(img, options)
    if (callback) {
      callback.call(img, event)
    }
  }

  loadImage.onload = function (img, event, file, callback, options) {
    revokeHelper(img, options)
    if (callback) {
      loadImage.transform(img, options, callback, file, {})
    }
  }

  loadImage.createObjectURL = function (file) {
    return urlAPI ? urlAPI.createObjectURL(file) : false
  }

  loadImage.revokeObjectURL = function (url) {
    return urlAPI ? urlAPI.revokeObjectURL(url) : false
  }

  // Loads a given File object via FileReader interface,
  // invokes the callback with the event object (load or error).
  // The result can be read via event.target.result:
  loadImage.readFile = function (file, callback, method) {
    if ($.FileReader) {
      var fileReader = new FileReader()
      fileReader.onload = fileReader.onerror = callback
      method = method || 'readAsDataURL'
      if (fileReader[method]) {
        fileReader[method](file)
        return fileReader
      }
    }
    return false
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return loadImage
    })
  } else if (typeof module === 'object' && module.exports) {
    module.exports = loadImage
  } else {
    $.loadImage = loadImage
  }
}(typeof window !== 'undefined' && window || this))

;
(function (factory) {
    'use strict'
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['./load-image'], factory)
    } else if (typeof module === 'object' && module.exports) {
        factory(require('./load-image'))
    } else {
        // Browser globals:
        factory(window.loadImage)
    }
}(function (loadImage) {
    'use strict'

    var originalTransform = loadImage.transform

    loadImage.transform = function (img, options, callback, file, data) {
        originalTransform.call(
            loadImage,
            loadImage.scale(img, options, data),
            options,
            callback,
            file,
            data
        )
    }

    // Transform image coordinates, allows to override e.g.
    // the canvas orientation based on the orientation option,
    // gets canvas, options passed as arguments:
    loadImage.transformCoordinates = function () {
        return
    }

    // Returns transformed options, allows to override e.g.
    // maxWidth, maxHeight and crop options based on the aspectRatio.
    // gets img, options passed as arguments:
    loadImage.getTransformedOptions = function (img, options) {
        var aspectRatio = options.aspectRatio
        var newOptions
        var i
        var width
        var height
        if (!aspectRatio) {
            return options
        }
        newOptions = {}
        for (i in options) {
            if (options.hasOwnProperty(i)) {
                newOptions[i] = options[i]
            }
        }
        newOptions.crop = true
        width = img.naturalWidth || img.width
        height = img.naturalHeight || img.height
        if (width / height > aspectRatio) {
            newOptions.maxWidth = height * aspectRatio
            newOptions.maxHeight = height
        } else {
            newOptions.maxWidth = width
            newOptions.maxHeight = width / aspectRatio
        }
        return newOptions
    }

    // Canvas render method, allows to implement a different rendering algorithm:
    loadImage.renderImageToCanvas = function (canvas,
                                              img,
                                              sourceX,
                                              sourceY,
                                              sourceWidth,
                                              sourceHeight,
                                              destX,
                                              destY,
                                              destWidth,
                                              destHeight) {
        canvas.getContext('2d').drawImage(
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            destX,
            destY,
            destWidth,
            destHeight
        )
        return canvas
    }

    // Determines if the target image should be a canvas element:
    loadImage.hasCanvasOption = function (options) {
        return options.canvas || options.crop || !!options.aspectRatio
    }

    // Scales and/or crops the given image (img or canvas HTML element)
    // using the given options.
    // Returns a canvas object if the browser supports canvas
    // and the hasCanvasOption method returns true or a canvas
    // object is passed as image, else the scaled image:
    loadImage.scale = function (img, options, data) {
        options = options || {}
        var canvas = document.createElement('canvas')
        var useCanvas = img.getContext ||
            (loadImage.hasCanvasOption(options) && canvas.getContext)
        var width = img.naturalWidth || img.width
        var height = img.naturalHeight || img.height
        var destWidth = width
        var destHeight = height
        var maxWidth
        var maxHeight
        var minWidth
        var minHeight
        var sourceWidth
        var sourceHeight
        var sourceX
        var sourceY
        var pixelRatio
        var downsamplingRatio
        var tmp

        function scaleUp() {
            var scale = Math.max(
                (minWidth || destWidth) / destWidth,
                (minHeight || destHeight) / destHeight
            )
            if (scale > 1) {
                destWidth *= scale
                destHeight *= scale
            }
        }

        function scaleDown() {
            var scale = Math.min(
                (maxWidth || destWidth) / destWidth,
                (maxHeight || destHeight) / destHeight
            )
            if (scale < 1) {
                destWidth *= scale
                destHeight *= scale
            }
        }

        if (useCanvas) {
            options = loadImage.getTransformedOptions(img, options, data)
            sourceX = options.left || 0
            sourceY = options.top || 0
            if (options.sourceWidth) {
                sourceWidth = options.sourceWidth
                if (options.right !== undefined && options.left === undefined) {
                    sourceX = width - sourceWidth - options.right
                }
            } else {
                sourceWidth = width - sourceX - (options.right || 0)
            }
            if (options.sourceHeight) {
                sourceHeight = options.sourceHeight
                if (options.bottom !== undefined && options.top === undefined) {
                    sourceY = height - sourceHeight - options.bottom
                }
            } else {
                sourceHeight = height - sourceY - (options.bottom || 0)
            }
            destWidth = sourceWidth
            destHeight = sourceHeight
        }
        maxWidth = options.maxWidth
        maxHeight = options.maxHeight
        minWidth = options.minWidth
        minHeight = options.minHeight
        if (useCanvas && maxWidth && maxHeight && options.crop) {
            destWidth = maxWidth
            destHeight = maxHeight
            tmp = sourceWidth / sourceHeight - maxWidth / maxHeight
            if (tmp < 0) {
                sourceHeight = maxHeight * sourceWidth / maxWidth
                if (options.top === undefined && options.bottom === undefined) {
                    sourceY = (height - sourceHeight) / 2
                }
            } else if (tmp > 0) {
                sourceWidth = maxWidth * sourceHeight / maxHeight
                if (options.left === undefined && options.right === undefined) {
                    sourceX = (width - sourceWidth) / 2
                }
            }
        } else {
            if (options.contain || options.cover) {
                minWidth = maxWidth = maxWidth || minWidth
                minHeight = maxHeight = maxHeight || minHeight
            }
            if (options.cover) {
                scaleDown()
                scaleUp()
            } else {
                scaleUp()
                scaleDown()
            }
        }
        if (useCanvas) {
            pixelRatio = options.pixelRatio
            if (pixelRatio > 1) {
                canvas.style.width = destWidth + 'px'
                canvas.style.height = destHeight + 'px'
                destWidth *= pixelRatio
                destHeight *= pixelRatio
                canvas.getContext('2d').scale(pixelRatio, pixelRatio)
            }
            downsamplingRatio = options.downsamplingRatio
            if (downsamplingRatio > 0 && downsamplingRatio < 1 &&
                destWidth < sourceWidth && destHeight < sourceHeight) {
                while (sourceWidth * downsamplingRatio > destWidth) {
                    canvas.width = sourceWidth * downsamplingRatio
                    canvas.height = sourceHeight * downsamplingRatio
                    loadImage.renderImageToCanvas(
                        canvas,
                        img,
                        sourceX,
                        sourceY,
                        sourceWidth,
                        sourceHeight,
                        0,
                        0,
                        canvas.width,
                        canvas.height
                    )
                    sourceX = 0
                    sourceY = 0
                    sourceWidth = canvas.width
                    sourceHeight = canvas.height
                    img = document.createElement('canvas')
                    img.width = sourceWidth
                    img.height = sourceHeight
                    loadImage.renderImageToCanvas(
                        img,
                        canvas,
                        0,
                        0,
                        sourceWidth,
                        sourceHeight,
                        0,
                        0,
                        sourceWidth,
                        sourceHeight
                    )
                }
            }
            canvas.width = destWidth
            canvas.height = destHeight
            loadImage.transformCoordinates(
                canvas,
                options
            )
            return loadImage.renderImageToCanvas(
                canvas,
                img,
                sourceX,
                sourceY,
                sourceWidth,
                sourceHeight,
                0,
                0,
                destWidth,
                destHeight
            )
        }
        img.width = destWidth
        img.height = destHeight
        return img
    }
}))

;
(function (factory) {
    'use strict'
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['./load-image'], factory)
    } else if (typeof module === 'object' && module.exports) {
        factory(require('./load-image'))
    } else {
        // Browser globals:
        factory(window.loadImage)
    }
}(function (loadImage) {
    'use strict'

    var hasblobSlice = typeof Blob !== 'undefined' && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice)

    loadImage.blobSlice = hasblobSlice && function () {
            var slice = this.slice || this.webkitSlice || this.mozSlice
            return slice.apply(this, arguments)
        }

    loadImage.metaDataParsers = {
        jpeg: {
            0xffe1: [] // APP1 marker
        }
    }

    // Parses image meta data and calls the callback with an object argument
    // with the following properties:
    // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)
    // The options arguments accepts an object and supports the following properties:
    // * maxMetaDataSize: Defines the maximum number of bytes to parse.
    // * disableImageHead: Disables creating the imageHead property.
    loadImage.parseMetaData = function (file, callback, options, data) {
        options = options || {}
        data = data || {}
        var that = this
        // 256 KiB should contain all EXIF/ICC/IPTC segments:
        var maxMetaDataSize = options.maxMetaDataSize || 262144
        var noMetaData = !(typeof DataView !== 'undefined' && file && file.size >= 12 &&
        file.type === 'image/jpeg' && loadImage.blobSlice)
        if (noMetaData || !loadImage.readFile(
                loadImage.blobSlice.call(file, 0, maxMetaDataSize),
                function (e) {
                    if (e.target.error) {
                        // FileReader error
                        console.log(e.target.error)
                        callback(data)
                        return
                    }
                    // Note on endianness:
                    // Since the marker and length bytes in JPEG files are always
                    // stored in big endian order, we can leave the endian parameter
                    // of the DataView methods undefined, defaulting to big endian.
                    var buffer = e.target.result
                    var dataView = new DataView(buffer)
                    var offset = 2
                    var maxOffset = dataView.byteLength - 4
                    var headLength = offset
                    var markerBytes
                    var markerLength
                    var parsers
                    var i
                    // Check for the JPEG marker (0xffd8):
                    if (dataView.getUint16(0) === 0xffd8) {
                        while (offset < maxOffset) {
                            markerBytes = dataView.getUint16(offset)
                            // Search for APPn (0xffeN) and COM (0xfffe) markers,
                            // which contain application-specific meta-data like
                            // Exif, ICC and IPTC data and text comments:
                            if ((markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||
                                markerBytes === 0xfffe) {
                                // The marker bytes (2) are always followed by
                                // the length bytes (2), indicating the length of the
                                // marker segment, which includes the length bytes,
                                // but not the marker bytes, so we add 2:
                                markerLength = dataView.getUint16(offset + 2) + 2
                                if (offset + markerLength > dataView.byteLength) {
                                    console.log('Invalid meta data: Invalid segment size.')
                                    break
                                }
                                parsers = loadImage.metaDataParsers.jpeg[markerBytes]
                                if (parsers) {
                                    for (i = 0; i < parsers.length; i += 1) {
                                        parsers[i].call(
                                            that,
                                            dataView,
                                            offset,
                                            markerLength,
                                            data,
                                            options
                                        )
                                    }
                                }
                                offset += markerLength
                                headLength = offset
                            } else {
                                // Not an APPn or COM marker, probably safe to
                                // assume that this is the end of the meta data
                                break
                            }
                        }
                        // Meta length must be longer than JPEG marker (2)
                        // plus APPn marker (2), followed by length bytes (2):
                        if (!options.disableImageHead && headLength > 6) {
                            if (buffer.slice) {
                                data.imageHead = buffer.slice(0, headLength)
                            } else {
                                // Workaround for IE10, which does not yet
                                // support ArrayBuffer.slice:
                                data.imageHead = new Uint8Array(buffer)
                                    .subarray(0, headLength)
                            }
                        }
                    } else {
                        console.log('Invalid JPEG file: Missing JPEG marker.')
                    }
                    callback(data)
                },
                'readAsArrayBuffer'
            )) {
            callback(data)
        }
    }

    // Determines if meta data should be loaded automatically:
    loadImage.hasMetaOption = function (options) {
        return options && options.meta
    }

    var originalTransform = loadImage.transform
    loadImage.transform = function (img, options, callback, file, data) {
        if (loadImage.hasMetaOption(options)) {
            loadImage.parseMetaData(file, function (data) {
                originalTransform.call(loadImage, img, options, callback, file, data)
            }, options, data)
        } else {
            originalTransform.apply(loadImage, arguments)
        }
    }
}))


;
(function (factory) {
    'use strict'
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['./load-image', './load-image-meta'], factory)
    } else if (typeof module === 'object' && module.exports) {
        factory(require('./load-image'), require('./load-image-meta'))
    } else {
        // Browser globals:
        factory(window.loadImage)
    }
}(function (loadImage) {
    'use strict'

    if (typeof fetch !== 'undefined' && typeof Request !== 'undefined') {
        loadImage.fetchBlob = function (url, callback, options) {
            if (loadImage.hasMetaOption(options)) {
                return fetch(new Request(url, options)).then(function (response) {
                    return response.blob()
                }).then(callback).catch(function (err) {
                    console.log(err)
                    callback()
                })
            } else {
                callback()
            }
        }
    }
}))

;
(function (factory) {
    'use strict'
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['./load-image', './load-image-meta'], factory)
    } else if (typeof module === 'object' && module.exports) {
        factory(require('./load-image'), require('./load-image-meta'))
    } else {
        // Browser globals:
        factory(window.loadImage)
    }
}(function (loadImage) {
    'use strict'

    loadImage.ExifMap = function () {
        return this
    }

    loadImage.ExifMap.prototype.map = {
        'Orientation': 0x0112
    }

    loadImage.ExifMap.prototype.get = function (id) {
        return this[id] || this[this.map[id]]
    }

    loadImage.getExifThumbnail = function (dataView, offset, length) {
        var hexData,
            i,
            b
        if (!length || offset + length > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid thumbnail data.')
            return
        }
        hexData = []
        for (i = 0; i < length; i += 1) {
            b = dataView.getUint8(offset + i)
            hexData.push((b < 16 ? '0' : '') + b.toString(16))
        }
        return 'data:image/jpeg,%' + hexData.join('%')
    }

    loadImage.exifTagTypes = {
        // byte, 8-bit unsigned int:
        1: {
            getValue: function (dataView, dataOffset) {
                return dataView.getUint8(dataOffset)
            },
            size: 1
        },
        // ascii, 8-bit byte:
        2: {
            getValue: function (dataView, dataOffset) {
                return String.fromCharCode(dataView.getUint8(dataOffset))
            },
            size: 1,
            ascii: true
        },
        // short, 16 bit int:
        3: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getUint16(dataOffset, littleEndian)
            },
            size: 2
        },
        // long, 32 bit int:
        4: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getUint32(dataOffset, littleEndian)
            },
            size: 4
        },
        // rational = two long values, first is numerator, second is denominator:
        5: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getUint32(dataOffset, littleEndian) /
                    dataView.getUint32(dataOffset + 4, littleEndian)
            },
            size: 8
        },
        // slong, 32 bit signed int:
        9: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getInt32(dataOffset, littleEndian)
            },
            size: 4
        },
        // srational, two slongs, first is numerator, second is denominator:
        10: {
            getValue: function (dataView, dataOffset, littleEndian) {
                return dataView.getInt32(dataOffset, littleEndian) /
                    dataView.getInt32(dataOffset + 4, littleEndian)
            },
            size: 8
        }
    }
    // undefined, 8-bit byte, value depending on field:
    loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1]

    loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {
        var tagType = loadImage.exifTagTypes[type]
        var tagSize
        var dataOffset
        var values
        var i
        var str
        var c
        if (!tagType) {
            console.log('Invalid Exif data: Invalid tag type.')
            return
        }
        tagSize = tagType.size * length
        // Determine if the value is contained in the dataOffset bytes,
        // or if the value at the dataOffset is a pointer to the actual data:
        dataOffset = tagSize > 4
            ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)
            : (offset + 8)
        if (dataOffset + tagSize > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid data offset.')
            return
        }
        if (length === 1) {
            return tagType.getValue(dataView, dataOffset, littleEndian)
        }
        values = []
        for (i = 0; i < length; i += 1) {
            values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian)
        }
        if (tagType.ascii) {
            str = ''
            // Concatenate the chars:
            for (i = 0; i < values.length; i += 1) {
                c = values[i]
                // Ignore the terminating NULL byte(s):
                if (c === '\u0000') {
                    break
                }
                str += c
            }
            return str
        }
        return values
    }

    loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {
        var tag = dataView.getUint16(offset, littleEndian)
        data.exif[tag] = loadImage.getExifValue(
            dataView,
            tiffOffset,
            offset,
            dataView.getUint16(offset + 2, littleEndian), // tag type
            dataView.getUint32(offset + 4, littleEndian), // tag length
            littleEndian
        )
    }

    loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {
        var tagsNumber,
            dirEndOffset,
            i
        if (dirOffset + 6 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid directory offset.')
            return
        }
        tagsNumber = dataView.getUint16(dirOffset, littleEndian)
        dirEndOffset = dirOffset + 2 + 12 * tagsNumber
        if (dirEndOffset + 4 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid directory size.')
            return
        }
        for (i = 0; i < tagsNumber; i += 1) {
            this.parseExifTag(
                dataView,
                tiffOffset,
                dirOffset + 2 + 12 * i, // tag offset
                littleEndian,
                data
            )
        }
        // Return the offset to the next directory:
        return dataView.getUint32(dirEndOffset, littleEndian)
    }

    loadImage.parseExifData = function (dataView, offset, length, data, options) {
        if (options.disableExif) {
            return
        }
        var tiffOffset = offset + 10
        var littleEndian
        var dirOffset
        var thumbnailData
        // Check for the ASCII code for "Exif" (0x45786966):
        if (dataView.getUint32(offset + 4) !== 0x45786966) {
            // No Exif data, might be XMP data instead
            return
        }
        if (tiffOffset + 8 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid segment size.')
            return
        }
        // Check for the two null bytes:
        if (dataView.getUint16(offset + 8) !== 0x0000) {
            console.log('Invalid Exif data: Missing byte alignment offset.')
            return
        }
        // Check the byte alignment:
        switch (dataView.getUint16(tiffOffset)) {
            case 0x4949:
                littleEndian = true
                break
            case 0x4D4D:
                littleEndian = false
                break
            default:
                console.log('Invalid Exif data: Invalid byte alignment marker.')
                return
        }
        // Check for the TIFF tag marker (0x002A):
        if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {
            console.log('Invalid Exif data: Missing TIFF marker.')
            return
        }
        // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
        dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)
        // Create the exif object to store the tags:
        data.exif = new loadImage.ExifMap()
        // Parse the tags of the main image directory and retrieve the
        // offset to the next directory, usually the thumbnail directory:
        dirOffset = loadImage.parseExifTags(
            dataView,
            tiffOffset,
            tiffOffset + dirOffset,
            littleEndian,
            data
        )
        if (dirOffset && !options.disableExifThumbnail) {
            thumbnailData = {exif: {}}
            dirOffset = loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + dirOffset,
                littleEndian,
                thumbnailData
            )
            // Check for JPEG Thumbnail offset:
            if (thumbnailData.exif[0x0201]) {
                data.exif.Thumbnail = loadImage.getExifThumbnail(
                    dataView,
                    tiffOffset + thumbnailData.exif[0x0201],
                    thumbnailData.exif[0x0202] // Thumbnail data length
                )
            }
        }
        // Check for Exif Sub IFD Pointer:
        if (data.exif[0x8769] && !options.disableExifSub) {
            loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + data.exif[0x8769], // directory offset
                littleEndian,
                data
            )
        }
        // Check for GPS Info IFD Pointer:
        if (data.exif[0x8825] && !options.disableExifGps) {
            loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + data.exif[0x8825], // directory offset
                littleEndian,
                data
            )
        }
    }

    // Registers the Exif parser for the APP1 JPEG meta data segment:
    loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)

    // Adds the following properties to the parseMetaData callback data:
    // * exif: The exif tags, parsed by the parseExifData method

    // Adds the following options to the parseMetaData method:
    // * disableExif: Disables Exif parsing.
    // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.
    // * disableExifSub: Disables parsing of the Exif Sub IFD.
    // * disableExifGps: Disables parsing of the Exif GPS Info IFD.
}))
;
(function (factory) {
    'use strict'
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['./load-image', './load-image-exif'], factory)
    } else if (typeof module === 'object' && module.exports) {
        factory(require('./load-image'), require('./load-image-exif'))
    } else {
        // Browser globals:
        factory(window.loadImage)
    }
}(function (loadImage) {
    'use strict'

    loadImage.ExifMap.prototype.tags = {
        // =================
        // TIFF tags (IFD0):
        // =================
        0x0100: 'ImageWidth',
        0x0101: 'ImageHeight',
        0x8769: 'ExifIFDPointer',
        0x8825: 'GPSInfoIFDPointer',
        0xA005: 'InteroperabilityIFDPointer',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x0112: 'Orientation',
        0x0115: 'SamplesPerPixel',
        0x011C: 'PlanarConfiguration',
        0x0212: 'YCbCrSubSampling',
        0x0213: 'YCbCrPositioning',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x0128: 'ResolutionUnit',
        0x0111: 'StripOffsets',
        0x0116: 'RowsPerStrip',
        0x0117: 'StripByteCounts',
        0x0201: 'JPEGInterchangeFormat',
        0x0202: 'JPEGInterchangeFormatLength',
        0x012D: 'TransferFunction',
        0x013E: 'WhitePoint',
        0x013F: 'PrimaryChromaticities',
        0x0211: 'YCbCrCoefficients',
        0x0214: 'ReferenceBlackWhite',
        0x0132: 'DateTime',
        0x010E: 'ImageDescription',
        0x010F: 'Make',
        0x0110: 'Model',
        0x0131: 'Software',
        0x013B: 'Artist',
        0x8298: 'Copyright',
        // ==================
        // Exif Sub IFD tags:
        // ==================
        0x9000: 'ExifVersion', // EXIF version
        0xA000: 'FlashpixVersion', // Flashpix format version
        0xA001: 'ColorSpace', // Color space information tag
        0xA002: 'PixelXDimension', // Valid width of meaningful image
        0xA003: 'PixelYDimension', // Valid height of meaningful image
        0xA500: 'Gamma',
        0x9101: 'ComponentsConfiguration', // Information about channels
        0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel
        0x927C: 'MakerNote', // Any desired information written by the manufacturer
        0x9286: 'UserComment', // Comments by user
        0xA004: 'RelatedSoundFile', // Name of related sound file
        0x9003: 'DateTimeOriginal', // Date and time when the original image was generated
        0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally
        0x9290: 'SubSecTime', // Fractions of seconds for DateTime
        0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal
        0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized
        0x829A: 'ExposureTime', // Exposure time (in seconds)
        0x829D: 'FNumber',
        0x8822: 'ExposureProgram', // Exposure program
        0x8824: 'SpectralSensitivity', // Spectral sensitivity
        0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2
        0x8828: 'OECF', // Optoelectric conversion factor
        0x8830: 'SensitivityType',
        0x8831: 'StandardOutputSensitivity',
        0x8832: 'RecommendedExposureIndex',
        0x8833: 'ISOSpeed',
        0x8834: 'ISOSpeedLatitudeyyy',
        0x8835: 'ISOSpeedLatitudezzz',
        0x9201: 'ShutterSpeedValue', // Shutter speed
        0x9202: 'ApertureValue', // Lens aperture
        0x9203: 'BrightnessValue', // Value of brightness
        0x9204: 'ExposureBias', // Exposure bias
        0x9205: 'MaxApertureValue', // Smallest F number of lens
        0x9206: 'SubjectDistance', // Distance to subject in meters
        0x9207: 'MeteringMode', // Metering mode
        0x9208: 'LightSource', // Kind of light source
        0x9209: 'Flash', // Flash status
        0x9214: 'SubjectArea', // Location and area of main subject
        0x920A: 'FocalLength', // Focal length of the lens in mm
        0xA20B: 'FlashEnergy', // Strobe energy in BCPS
        0xA20C: 'SpatialFrequencyResponse',
        0xA20E: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit
        0xA20F: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit
        0xA210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution
        0xA214: 'SubjectLocation', // Location of subject in image
        0xA215: 'ExposureIndex', // Exposure index selected on camera
        0xA217: 'SensingMethod', // Image sensor type
        0xA300: 'FileSource', // Image source (3 == DSC)
        0xA301: 'SceneType', // Scene type (1 == directly photographed)
        0xA302: 'CFAPattern', // Color filter array geometric pattern
        0xA401: 'CustomRendered', // Special processing
        0xA402: 'ExposureMode', // Exposure mode
        0xA403: 'WhiteBalance', // 1 = auto white balance, 2 = manual
        0xA404: 'DigitalZoomRatio', // Digital zoom ratio
        0xA405: 'FocalLengthIn35mmFilm',
        0xA406: 'SceneCaptureType', // Type of scene
        0xA407: 'GainControl', // Degree of overall image gain adjustment
        0xA408: 'Contrast', // Direction of contrast processing applied by camera
        0xA409: 'Saturation', // Direction of saturation processing applied by camera
        0xA40A: 'Sharpness', // Direction of sharpness processing applied by camera
        0xA40B: 'DeviceSettingDescription',
        0xA40C: 'SubjectDistanceRange', // Distance to subject
        0xA420: 'ImageUniqueID', // Identifier assigned uniquely to each image
        0xA430: 'CameraOwnerName',
        0xA431: 'BodySerialNumber',
        0xA432: 'LensSpecification',
        0xA433: 'LensMake',
        0xA434: 'LensModel',
        0xA435: 'LensSerialNumber',
        // ==============
        // GPS Info tags:
        // ==============
        0x0000: 'GPSVersionID',
        0x0001: 'GPSLatitudeRef',
        0x0002: 'GPSLatitude',
        0x0003: 'GPSLongitudeRef',
        0x0004: 'GPSLongitude',
        0x0005: 'GPSAltitudeRef',
        0x0006: 'GPSAltitude',
        0x0007: 'GPSTimeStamp',
        0x0008: 'GPSSatellites',
        0x0009: 'GPSStatus',
        0x000A: 'GPSMeasureMode',
        0x000B: 'GPSDOP',
        0x000C: 'GPSSpeedRef',
        0x000D: 'GPSSpeed',
        0x000E: 'GPSTrackRef',
        0x000F: 'GPSTrack',
        0x0010: 'GPSImgDirectionRef',
        0x0011: 'GPSImgDirection',
        0x0012: 'GPSMapDatum',
        0x0013: 'GPSDestLatitudeRef',
        0x0014: 'GPSDestLatitude',
        0x0015: 'GPSDestLongitudeRef',
        0x0016: 'GPSDestLongitude',
        0x0017: 'GPSDestBearingRef',
        0x0018: 'GPSDestBearing',
        0x0019: 'GPSDestDistanceRef',
        0x001A: 'GPSDestDistance',
        0x001B: 'GPSProcessingMethod',
        0x001C: 'GPSAreaInformation',
        0x001D: 'GPSDateStamp',
        0x001E: 'GPSDifferential',
        0x001F: 'GPSHPositioningError'
    }

    loadImage.ExifMap.prototype.stringValues = {
        ExposureProgram: {
            0: 'Undefined',
            1: 'Manual',
            2: 'Normal program',
            3: 'Aperture priority',
            4: 'Shutter priority',
            5: 'Creative program',
            6: 'Action program',
            7: 'Portrait mode',
            8: 'Landscape mode'
        },
        MeteringMode: {
            0: 'Unknown',
            1: 'Average',
            2: 'CenterWeightedAverage',
            3: 'Spot',
            4: 'MultiSpot',
            5: 'Pattern',
            6: 'Partial',
            255: 'Other'
        },
        LightSource: {
            0: 'Unknown',
            1: 'Daylight',
            2: 'Fluorescent',
            3: 'Tungsten (incandescent light)',
            4: 'Flash',
            9: 'Fine weather',
            10: 'Cloudy weather',
            11: 'Shade',
            12: 'Daylight fluorescent (D 5700 - 7100K)',
            13: 'Day white fluorescent (N 4600 - 5400K)',
            14: 'Cool white fluorescent (W 3900 - 4500K)',
            15: 'White fluorescent (WW 3200 - 3700K)',
            17: 'Standard light A',
            18: 'Standard light B',
            19: 'Standard light C',
            20: 'D55',
            21: 'D65',
            22: 'D75',
            23: 'D50',
            24: 'ISO studio tungsten',
            255: 'Other'
        },
        Flash: {
            0x0000: 'Flash did not fire',
            0x0001: 'Flash fired',
            0x0005: 'Strobe return light not detected',
            0x0007: 'Strobe return light detected',
            0x0009: 'Flash fired, compulsory flash mode',
            0x000D: 'Flash fired, compulsory flash mode, return light not detected',
            0x000F: 'Flash fired, compulsory flash mode, return light detected',
            0x0010: 'Flash did not fire, compulsory flash mode',
            0x0018: 'Flash did not fire, auto mode',
            0x0019: 'Flash fired, auto mode',
            0x001D: 'Flash fired, auto mode, return light not detected',
            0x001F: 'Flash fired, auto mode, return light detected',
            0x0020: 'No flash function',
            0x0041: 'Flash fired, red-eye reduction mode',
            0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
            0x0047: 'Flash fired, red-eye reduction mode, return light detected',
            0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
            0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
            0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
            0x0059: 'Flash fired, auto mode, red-eye reduction mode',
            0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
            0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
        },
        SensingMethod: {
            1: 'Undefined',
            2: 'One-chip color area sensor',
            3: 'Two-chip color area sensor',
            4: 'Three-chip color area sensor',
            5: 'Color sequential area sensor',
            7: 'Trilinear sensor',
            8: 'Color sequential linear sensor'
        },
        SceneCaptureType: {
            0: 'Standard',
            1: 'Landscape',
            2: 'Portrait',
            3: 'Night scene'
        },
        SceneType: {
            1: 'Directly photographed'
        },
        CustomRendered: {
            0: 'Normal process',
            1: 'Custom process'
        },
        WhiteBalance: {
            0: 'Auto white balance',
            1: 'Manual white balance'
        },
        GainControl: {
            0: 'None',
            1: 'Low gain up',
            2: 'High gain up',
            3: 'Low gain down',
            4: 'High gain down'
        },
        Contrast: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        Saturation: {
            0: 'Normal',
            1: 'Low saturation',
            2: 'High saturation'
        },
        Sharpness: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        SubjectDistanceRange: {
            0: 'Unknown',
            1: 'Macro',
            2: 'Close view',
            3: 'Distant view'
        },
        FileSource: {
            3: 'DSC'
        },
        ComponentsConfiguration: {
            0: '',
            1: 'Y',
            2: 'Cb',
            3: 'Cr',
            4: 'R',
            5: 'G',
            6: 'B'
        },
        Orientation: {
            1: 'top-left',
            2: 'top-right',
            3: 'bottom-right',
            4: 'bottom-left',
            5: 'left-top',
            6: 'right-top',
            7: 'right-bottom',
            8: 'left-bottom'
        }
    }

    loadImage.ExifMap.prototype.getText = function (id) {
        var value = this.get(id)
        switch (id) {
            case 'LightSource':
            case 'Flash':
            case 'MeteringMode':
            case 'ExposureProgram':
            case 'SensingMethod':
            case 'SceneCaptureType':
            case 'SceneType':
            case 'CustomRendered':
            case 'WhiteBalance':
            case 'GainControl':
            case 'Contrast':
            case 'Saturation':
            case 'Sharpness':
            case 'SubjectDistanceRange':
            case 'FileSource':
            case 'Orientation':
                return this.stringValues[id][value]
            case 'ExifVersion':
            case 'FlashpixVersion':
                if (!value) return
                return String.fromCharCode(value[0], value[1], value[2], value[3])
            case 'ComponentsConfiguration':
                if (!value) return
                return this.stringValues[id][value[0]] +
                    this.stringValues[id][value[1]] +
                    this.stringValues[id][value[2]] +
                    this.stringValues[id][value[3]]
            case 'GPSVersionID':
                if (!value) return
                return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]
        }
        return String(value)
    }

    ;
    (function (exifMapPrototype) {
        var tags = exifMapPrototype.tags
        var map = exifMapPrototype.map
        var prop
        // Map the tag names to tags:
        for (prop in tags) {
            if (tags.hasOwnProperty(prop)) {
                map[tags[prop]] = prop
            }
        }
    }(loadImage.ExifMap.prototype))

    loadImage.ExifMap.prototype.getAll = function () {
        var map = {}
        var prop
        var id
        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                id = this.tags[prop]
                if (id) {
                    map[id] = this.getText(id)
                }
            }
        }
        return map
    }
}))

;
(function (factory) {
    'use strict'
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define(['./load-image', './load-image-scale', './load-image-meta'], factory)
    } else if (typeof module === 'object' && module.exports) {
        factory(
            require('./load-image'),
            require('./load-image-scale'),
            require('./load-image-meta')
        )
    } else {
        // Browser globals:
        factory(window.loadImage)
    }
}(function (loadImage) {
    'use strict'

    var originalHasCanvasOption = loadImage.hasCanvasOption
    var originalHasMetaOption = loadImage.hasMetaOption
    var originalTransformCoordinates = loadImage.transformCoordinates
    var originalGetTransformedOptions = loadImage.getTransformedOptions

    // Determines if the target image should be a canvas element:
    loadImage.hasCanvasOption = function (options) {
        return !!options.orientation ||
            originalHasCanvasOption.call(loadImage, options)
    }

    // Determines if meta data should be loaded automatically:
    loadImage.hasMetaOption = function (options) {
        return options && options.orientation === true ||
            originalHasMetaOption.call(loadImage, options)
    }

    // Transform image orientation based on
    // the given EXIF orientation option:
    loadImage.transformCoordinates = function (canvas, options) {
        originalTransformCoordinates.call(loadImage, canvas, options)
        var ctx = canvas.getContext('2d')
        var width = canvas.width
        var height = canvas.height
        var styleWidth = canvas.style.width
        var styleHeight = canvas.style.height
        var orientation = options.orientation
        if (!orientation || orientation > 8) {
            return
        }
        if (orientation > 4) {
            canvas.width = height
            canvas.height = width
            canvas.style.width = styleHeight
            canvas.style.height = styleWidth
        }
        switch (orientation) {
            case 2:
                // horizontal flip
                ctx.translate(width, 0)
                ctx.scale(-1, 1)
                break
            case 3:
                // 180° rotate left
                ctx.translate(width, height)
                ctx.rotate(Math.PI)
                break
            case 4:
                // vertical flip
                ctx.translate(0, height)
                ctx.scale(1, -1)
                break
            case 5:
                // vertical flip + 90 rotate right
                ctx.rotate(0.5 * Math.PI)
                ctx.scale(1, -1)
                break
            case 6:
                // 90° rotate right
                ctx.rotate(0.5 * Math.PI)
                ctx.translate(0, -height)
                break
            case 7:
                // horizontal flip + 90 rotate right
                ctx.rotate(0.5 * Math.PI)
                ctx.translate(width, -height)
                ctx.scale(-1, 1)
                break
            case 8:
                // 90° rotate left
                ctx.rotate(-0.5 * Math.PI)
                ctx.translate(-width, 0)
                break
        }
    }

    // Transforms coordinate and dimension options
    // based on the given orientation option:
    loadImage.getTransformedOptions = function (img, opts, data) {
        var options = originalGetTransformedOptions.call(loadImage, img, opts)
        var orientation = options.orientation
        var newOptions
        var i
        if (orientation === true && data && data.exif) {
            orientation = data.exif.get('Orientation')
        }
        if (!orientation || orientation > 8 || orientation === 1) {
            return options
        }
        newOptions = {}
        for (i in options) {
            if (options.hasOwnProperty(i)) {
                newOptions[i] = options[i]
            }
        }
        newOptions.orientation = orientation
        switch (orientation) {
            case 2:
                // horizontal flip
                newOptions.left = options.right
                newOptions.right = options.left
                break
            case 3:
                // 180° rotate left
                newOptions.left = options.right
                newOptions.top = options.bottom
                newOptions.right = options.left
                newOptions.bottom = options.top
                break
            case 4:
                // vertical flip
                newOptions.top = options.bottom
                newOptions.bottom = options.top
                break
            case 5:
                // vertical flip + 90 rotate right
                newOptions.left = options.top
                newOptions.top = options.left
                newOptions.right = options.bottom
                newOptions.bottom = options.right
                break
            case 6:
                // 90° rotate right
                newOptions.left = options.top
                newOptions.top = options.right
                newOptions.right = options.bottom
                newOptions.bottom = options.left
                break
            case 7:
                // horizontal flip + 90 rotate right
                newOptions.left = options.bottom
                newOptions.top = options.right
                newOptions.right = options.top
                newOptions.bottom = options.left
                break
            case 8:
                // 90° rotate left
                newOptions.left = options.bottom
                newOptions.top = options.left
                newOptions.right = options.top
                newOptions.bottom = options.right
                break
        }
        if (newOptions.orientation > 4) {
            newOptions.maxWidth = options.maxHeight
            newOptions.maxHeight = options.maxWidth
            newOptions.minWidth = options.minHeight
            newOptions.minHeight = options.minWidth
            newOptions.sourceWidth = options.sourceHeight
            newOptions.sourceHeight = options.sourceWidth
        }
        return newOptions
    }
}))

/**
 * Created by Andrewz on 2/15/18.
 */
var TQ = TQ || {};
TQ.MultiHostQue = (function(){
    var maxConnectionPerHost = 6,
        maxConnections = 20,
        hosts = [],
        urls = [];

    return {
        addUrl: addUrl,
        close: close,
        isHostFull: isHostFull,
        removeUrl: removeUrl
    };

    function addUrl(url) {
        var host = TQ.Base.Utility.urlParser(url).host;
        if (hosts.indexOf(host) < 0) {
            urls[host] = [];
            hosts.push(host);
        }
        urls[host].push(url);
    }

    function removeUrl(url) {
        var host = TQ.Base.Utility.urlParser(url).host;
        if (hosts.indexOf(host) < 0) {
            return;
        }
        var id = urls[host].indexOf(url);
        if (id >= 0) {
            urls[host].splice(id, 1);
        }
    }

    function close() {
        hosts.forEach(function(host) {
            urls[host].splice(0);
        })
    }
    function isHostFull(url) {
        var host = TQ.Base.Utility.urlParser(url).host;
        return ((hosts.indexOf(host) > 0) && (urls[host].length > maxConnectionPerHost));
    }
}());

/*!
* PreloadJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of the library.
	 * @class PreloadJS
	 **/
	var s = createjs.PreloadJS = createjs.PreloadJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type {String}
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type {String}
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * <h4>Example</h4>
 *
 *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
	"use strict";

	/**
	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
	 * method gets called in the correct scope.
	 *
	 * Additional arguments can be passed that will be applied to the function when it is called.
	 *
	 * <h4>Example</h4>
	 *
	 *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));
	 *
	 *      function myHandler(arg1, arg2) {
	 *           // This gets called when myObject.myCallback is executed.
	 *      }
	 *
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
	 * @public
	 * @static
	 */
	createjs.proxy = function (method, scope) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		return function () {
			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
		};
	}

}());

//##############################################################################
// BrowserDetect.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */
(function() {
	"use strict";

	/**
	 * An object that determines the current browser, version, operating system, and other environment
	 * variables via user agent string.
	 *
	 * Used for audio because feature detection is unable to detect the many limitations of mobile devices.
	 *
	 * <h4>Example</h4>
	 *
	 *      if (createjs.BrowserDetect.isIOS) { // do stuff }
	 *
	 * @property BrowserDetect
	 * @type {Object}
	 * @param {Boolean} isFirefox True if our browser is Firefox.
	 * @param {Boolean} isOpera True if our browser is opera.
	 * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a
	 * completely different browser with different abilities.
	 * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).
	 * @param {Boolean} isAndroid True if our browser is Android.
	 * @param {Boolean} isBlackberry True if our browser is Blackberry.
	 * @constructor
	 * @static
	 */
	function BrowserDetect() {
		throw "BrowserDetect cannot be instantiated";
	}

	var agent = BrowserDetect.agent = window.navigator.userAgent;
	BrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);
	BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
	BrowserDetect.isOpera = (window.opera != null);
	BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities
	BrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);

	createjs.BrowserDetect = BrowserDetect;

}());

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 *
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {


	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;

		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;

		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;

		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;

		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;

		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;

		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();

		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;

		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;

		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;

		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};

	/**
	 * Causes the active listener to be removed via removeEventListener();
	 *
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 *
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};

	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	function ErrorEvent(title, message, data) {
		this.Event_constructor("error");

		/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
		this.title = title;

		/**
		 * The verbose error message, containing details about the error.
		 * @property message
		 * @type String
		 */
		this.message = message;

		/**
		 * Additional data attached to an error.
		 * @property data
		 * @type {Object}
		 */
		this.data = data;
	}

	var p = createjs.extend(ErrorEvent, createjs.Event);

	p.clone = function() {
		return new createjs.ErrorEvent(this.title, this.message, this.data);
	};

	createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 *
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 *
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 *
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 *
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {


	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;

		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 *
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 *
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};


// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};

	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 *
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 *
	 * <h4>Example</h4>
	 *
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 *
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};

	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 *
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;

			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
	"use strict";

	// constructor
	/**
	 * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.
	 * @class ProgressEvent
	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
	 * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is
	 * a percentage (between 0 and 1), it can be omitted.
	 * @todo Consider having this event be a "fileprogress" event as well
	 * @constructor
	 */
	function ProgressEvent(loaded, total) {
		this.Event_constructor("progress");

		/**
		 * The amount that has been loaded (out of a total amount)
		 * @property loaded
		 * @type {Number}
		 */
		this.loaded = loaded;

		/**
		 * The total "size" of the load.
		 * @property total
		 * @type {Number}
		 * @default 1
		 */
		this.total = (total == null) ? 1 : total;

		/**
		 * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = (total == 0) ? 0 : this.loaded / this.total;
	};

	var p = createjs.extend(ProgressEvent, createjs.Event);

	/**
	 * Returns a clone of the ProgressEvent instance.
	 * @method clone
	 * @return {ProgressEvent} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new createjs.ProgressEvent(this.loaded, this.total);
	};

	createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");

}(window));

//##############################################################################
// json3.js
//##############################################################################

/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

//##############################################################################
// DomUtils.js
//##############################################################################

(function () {

	/**
	 * A few utilities for interacting with the dom.
	 * @class DomUtils
	 */
	var s = {};

	s.appendToHead = function (el) {
		s.getHead().appendChild(el)
	}

	s.getHead = function () {
		return document.head || document.getElementsByTagName("head")[0];
	}

	s.getBody = function () {
		return document.body || document.getElementsByTagName("body")[0];
	}

	createjs.DomUtils = s;

}());

//##############################################################################
// DataUtils.js
//##############################################################################

(function () {

	/**
	 * A few data utilities for formatting different data types.
	 * @class DataUtils
	 */
	var s = {};

	// static methods
	/**
	 * Parse XML using the DOM. This is required when preloading XML or SVG.
	 * @method parseXML
	 * @param {String} text The raw text or XML that is loaded by XHR.
	 * @param {String} type The mime type of the XML. Use "text/xml" for XML, and  "image/svg+xml" for SVG parsing.
	 * @return {XML} An XML document
	 * @static
	 */
	s.parseXML = function (text, type) {
		var xml = null;
		// CocoonJS does not support XML parsing with either method.

		// Most browsers will use DOMParser
		// IE fails on certain SVG files, so we have a fallback below.
		try {
			if (window.DOMParser) {
				var parser = new DOMParser();
				xml = parser.parseFromString(text, type);
			}
		} catch (e) {
		}

		// Fallback for IE support.
		if (!xml) {
			try {
				xml = new ActiveXObject("Microsoft.XMLDOM");
				xml.async = false;
				xml.loadXML(text);
			} catch (e) {
				xml = null;
			}
		}

		return xml;
	};

	/**
	 * Parse a string into an Object.
	 * @method parseJSON
	 * @param {String} value The loaded JSON string
	 * @returns {Object} A JavaScript object.
	 */
	s.parseJSON = function (value) {
		if (value == null) {
			return null;
		}

		try {
			return JSON.parse(value);
		} catch (e) {
			// TODO; Handle this with a custom error?
			throw e;
		}
	};

	createjs.DataUtils = s;

}());

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
	 * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A
	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
	 * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}
	 * @class LoadItem
	 * @constructor
	 * @since 0.6.0
	 */
	function LoadItem() {
		/**
		 * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
		 * string (recommended), or an HTML tag.
		 * This can also be an object, but in that case it has to include a type and be handled by a plugin.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = null;

		/**
		 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
		 * be set manually. This is helpful in cases where a file does not have an extension.
		 * @property type
		 * @type {String}
		 * @default null
		 */
		this.type = null;

		/**
		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
		 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
		 * @property id
		 * @type {String}
		 * @default null
		 */
		this.id = null;

		/**
		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
		 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
		 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
		 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
		 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
		 * @property maintainOrder
		 * @type {Boolean}
		 * @default false
		 */
		this.maintainOrder = false;

		/**
		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
		 * @property callback
		 * @type {String}
		 * @default null
		 */
		this.callback = null;

		/**
		 * An arbitrary data object, which is included with the loaded object.
		 * @property data
		 * @type {Object}
		 * @default null
		 */
		this.data = null;

		/**
		 * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or
		 * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as
		 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
		 * @property method
		 * @type {String}
		 * @default get
		 */
		this.method = createjs.LoadItem.GET;

		/**
		 * An object hash of name/value pairs to send to the server.
		 * @property values
		 * @type {Object}
		 * @default null
		 */
		this.values = null;

		/**
		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
		 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
		 * default headers by including them in your headers object.
		 * @property headers
		 * @type {Object}
		 * @default null
		 */
		this.headers = null;

		/**
		 * Enable credentials for XHR requests.
		 * @property withCredentials
		 * @type {Boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
		 * based files (json, xml, text, css, js).
		 * @property mimeType
		 * @type {String}
		 * @default null
		 */
		this.mimeType = null;

		/**
		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
		 * @property crossOrigin
		 * @type {boolean}
		 * @default Anonymous
		 */
		this.crossOrigin = null;

		/**
		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
		 * (level one) loading, as XHR (level 2) provides its own timeout event.
		 * @property loadTimeout
		 * @type {Number}
		 * @default 8000 (8 seconds)
		 */
		this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
	};

	var p = LoadItem.prototype = {};
	var s = LoadItem;

	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 * @property LOAD_TIMEOUT_DEFAULT
	 * @type {number}
	 * @static
	 */
	s.LOAD_TIMEOUT_DEFAULT = 8000;

	/**
	 * Create a LoadItem.
	 * <ul>
	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
	 *     <li>LoadItem instances are returned as-is</li>
	 *     <li>Objects are returned with any needed properties added</li>
	 * </ul>
	 * @method create
	 * @param {LoadItem|String|Object} value The load item value
	 * @returns {LoadItem|Object}
	 * @static
	 */
	s.create = function (value) {
		if (typeof value == "string") {
			var item = new LoadItem();
			item.src = value;
			return item;
		} else if (value instanceof s) {
			return value;
		} else if (value instanceof Object && value.src) {
			if (value.loadTimeout == null) {
				value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
			}
			return value;
		} else {
			throw new Error("Type not recognized.");
		}
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

	/**
	 * Utilities that assist with parsing load items, and determining file types, etc.
	 * @class RequestUtils
	 */
	var s = {};

	/**
	 * The Regular Expression used to test file URLS for an absolute path.
	 * @property ABSOLUTE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

	/**
	 * The Regular Expression used to test file URLS for a relative path.
	 * @property RELATIVE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.RELATIVE_PATT = (/^[./]*?\//i);

	/**
	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
	 * removed.
	 * @property EXTENSION_PATT
	 * @type {RegExp}
	 * @static
	 */
	s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

	/**
	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
	 * <ul>
	 *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or
	 *     `//networkPath`)</li>
	 *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>
	 *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and
	 *     the file path is expected to follow the format `name.ext`.</li>
	 * </ul>
	 * @method parseURI
	 * @param {String} path
	 * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`
	 * property, which is the lowercase extension.
	 * @static
	 */
	s.parseURI = function (path) {
		var info = {absolute: false, relative: false};
		if (path == null) { return info; }

		// Drop the query string
		var queryIndex = path.indexOf("?");
		if (queryIndex > -1) {
			path = path.substr(0, queryIndex);
		}

		// Absolute
		var match;
		if (s.ABSOLUTE_PATT.test(path)) {
			info.absolute = true;

			// Relative
		} else if (s.RELATIVE_PATT.test(path)) {
			info.relative = true;
		}

		// Extension
		if (match = path.match(s.EXTENSION_PATT)) {
			info.extension = match[1].toLowerCase();
		}
		return info;
	};

	/**
	 * Formats an object into a query string for either a POST or GET request.
	 * @method formatQueryString
	 * @param {Object} data The data to convert to a query string.
	 * @param {Array} [query] Existing name/value pairs to append on to this query.
	 * @static
	 */
	s.formatQueryString = function (data, query) {
		if (data == null) {
			throw new Error('You must specify data.');
		}
		var params = [];
		for (var n in data) {
			params.push(n + '=' + escape(data[n]));
		}
		if (query) {
			params = params.concat(query);
		}
		return params.join('&');
	};

	/**
	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.
	 * @method buildPath
	 * @param {String} src The source path to add values to.
	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
	 * path will be preserved.
	 * @returns {string} A formatted string that contains the path and the supplied parameters.
	 * @static
	 */
	s.buildPath = function (src, data) {
		if (data == null) {
			return src;
		}

		var query = [];
		var idx = src.indexOf('?');

		if (idx != -1) {
			var q = src.slice(idx + 1);
			query = query.concat(q.split('&'));
		}

		if (idx != -1) {
			return src.slice(0, idx) + '?' + this._formatQueryString(data, query);
		} else {
			return src + '?' + this._formatQueryString(data, query);
		}
	};

	/**
	 * @method isCrossDomain
	 * @param {LoadItem|Object} item A load item with a `src` property.
	 * @return {Boolean} If the load item is loading from a different domain than the current location.
	 * @static
	 */
	s.isCrossDomain = function (item) {
		var target = document.createElement("a");
		target.href = item.src;

		var host = document.createElement("a");
		host.href = location.href;

		var crossdomain = (target.hostname != "") &&
						  (target.port != host.port ||
						   target.protocol != host.protocol ||
						   target.hostname != host.hostname);
		return crossdomain;
	};

	/**
	 * @method isLocal
	 * @param {LoadItem|Object} item A load item with a `src` property
	 * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as
	 * well.
	 * @static
	 */
	s.isLocal = function (item) {
		var target = document.createElement("a");
		target.href = item.src;
		return target.hostname == "" && target.protocol == "file:";
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
	 * {{#crossLink "AbstractLoader"}}{{/crossLink}}.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @static
	 */
	s.isBinary = function (type) {
		switch (type) {
			case createjs.AbstractLoader.IMAGE:
			case createjs.AbstractLoader.BINARY:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Check if item is a valid HTMLImageElement
	 * @method isImageTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isImageTag = function(item) {
		return item instanceof HTMLImageElement;
	};

	/**
	 * Check if item is a valid HTMLAudioElement
	 * @method isAudioTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isAudioTag = function(item) {
		if (window.HTMLAudioElement) {
			return item instanceof HTMLAudioElement;
		} else {
			return false;
		}
	};

	/**
	 * Check if item is a valid HTMLVideoElement
	 * @method isVideoTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isVideoTag = function(item) {
		if (window.HTMLVideoElement) {
			return item instanceof HTMLVideoElement;
		} else {
			return false;
		}
	};

	/**
	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @static
	 */
	s.isText = function (type) {
		switch (type) {
			case createjs.AbstractLoader.TEXT:
			case createjs.AbstractLoader.JSON:
			case createjs.AbstractLoader.MANIFEST:
			case createjs.AbstractLoader.XML:
			case createjs.AbstractLoader.CSS:
			case createjs.AbstractLoader.SVG:
			case createjs.AbstractLoader.JAVASCRIPT:
			case createjs.AbstractLoader.SPRITESHEET:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @method getTypeByExtension
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if
	 * the type can not be determined by the extension.
	 * @static
	 */
	s.getTypeByExtension = function (extension) {
		if (extension == null) {
			return createjs.AbstractLoader.TEXT;
		}

		switch (extension.toLowerCase()) {
			case "jpeg":
			case "jpg":
			case "gif":
			case "png":
			case "webp":
			case "bmp":
				return createjs.AbstractLoader.IMAGE;
			case "ogg":
			case "mp3":
			case "webm":
				return createjs.AbstractLoader.SOUND;
			case "mp4":
			case "webm":
			case "ts":
				return createjs.AbstractLoader.VIDEO;
			case "json":
				return createjs.AbstractLoader.JSON;
			case "xml":
				return createjs.AbstractLoader.XML;
			case "css":
				return createjs.AbstractLoader.CSS;
			case "js":
				return createjs.AbstractLoader.JAVASCRIPT;
			case 'svg':
				return createjs.AbstractLoader.SVG;
			default:
				return createjs.AbstractLoader.TEXT;
		}
	};

	createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	 * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
	 * @class AbstractLoader
	 * @param {LoadItem|object|string} loadItem The item to be loaded.
	 * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	 * other, so this is a suggested directive.
	 * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	 * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
	 * @extends EventDispatcher
	 */
	function AbstractLoader(loadItem, preferXHR, type) {
		this.EventDispatcher_constructor();

		// public properties
		/**
		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
		 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
		 * @property loaded
		 * @type {Boolean}
		 * @default false
		 */
		this.loaded = false;

		/**
		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
		 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
		 * instead.
		 * @property canceled
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 */
		this.canceled = false;

		/**
		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
		 *
		 * <h4>Example</h4>
		 *
		 *     var queue = new createjs.LoadQueue();
		 *     queue.loadFile("largeImage.png");
		 *     queue.on("progress", function() {
		 *         console.log("Progress:", queue.progress, event.progress);
		 *     });
		 *
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = 0;

		/**
		 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
		 * supported types.
		 * @property type
		 * @type {String}
		 */
		this.type = type;

		/**
		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
		 * can be overridden to provide custom formatting.
		 *
		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
		 * asynchronous, such as creating a new image.
		 * @property resultFormatter
		 * @type {Function}
		 * @default null
		 */
		this.resultFormatter = null;

		// protected properties
		/**
		 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
		 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
		 * @property _item
		 * @type {LoadItem|Object}
		 * @private
		 */
		if (loadItem) {
			this._item = createjs.LoadItem.create(loadItem);
		} else {
			this._item = null;
		}

		/**
		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).
		 * @property _preferXHR
		 * @type {Boolean}
		 * @private
		 */
		this._preferXHR = preferXHR;

		/**
		 * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
		 * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
		 * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
		 * @property _result
		 * @type {Object|String}
		 * @private
		 */
		this._result = null;

		/**
		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
		 * method, and passing `true`.
		 * @property _rawResult
		 * @type {Object|String}
		 * @private
		 */
		this._rawResult = null;

		/**
		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _loadItems
		 * @type {null}
		 * @protected
		 */
		this._loadedItems = null;

		/**
		 * The attribute the items loaded using tags use for the source.
		 * @type {string}
		 * @default null
		 * @private
		 */
		this._tagSrcAttribute = null;

		/**
		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
		 * @property _tag
		 * @type {Object}
		 * @private
		 */
		this._tag = null;
	};

	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
	var s = AbstractLoader;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Defines a POST request, use for a method value when loading data.
	 * @property POST
	 * @type {string}
	 * @default post
	 * @static
	 */
	s.POST = "POST";

	/**
	 * Defines a GET request, use for a method value when loading data.
	 * @property GET
	 * @type {string}
	 * @default get
	 * @static
	 */
	s.GET = "GET";

	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @since 0.6.0
	 */
	s.BINARY = "binary";

	/**
	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
	 * &lt;style&gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @since 0.6.0
	 */
	s.CSS = "css";

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @since 0.6.0
	 */
	s.IMAGE = "image";

	/**
	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
	 * &lt;script&gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @since 0.6.0
	 */
	s.JAVASCRIPT = "javascript";

	/**
	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @since 0.6.0
	 */
	s.JSON = "json";

	/**
	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @since 0.6.0
	 */
	s.JSONP = "jsonp";

	/**
	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.6.0
	 */
	s.MANIFEST = "manifest";

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &lt;audio&gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @since 0.6.0
	 */
	s.SOUND = "sound";

	/**
	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
	 * &lt;video&gt; tag.
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @since 0.6.0
	 */
	s.VIDEO = "video";

	/**
	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
	 * @property SPRITESHEET
	 * @type {String}
	 * @default spritesheet
	 * @static
	 * @since 0.6.0
	 */
	s.SPRITESHEET = "spritesheet";

	/**
	 * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @since 0.6.0
	 */
	s.SVG = "svg";

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @since 0.6.0
	 */
	s.TEXT = "text";

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @since 0.6.0
	 */
	s.XML = "xml";

// Events
	/**
	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The even type ("fileerror")
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileload")
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("initialize")
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */


	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
	 * @method getItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	p.getItem = function () {
		return this._item;
	};

	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	p.getResult = function (raw) {
		return raw ? this._rawResult : this._result;
	};

	/**
	 * Return the `tag` this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	p.getTag = function () {
		return this._tag;
	};

	/**
	 * Set the `tag` this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	p.setTag = function(tag) {
	  this._tag = tag;
	};

	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.on("complete", handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	p.load = function () {
		this._createRequest();

		this._request.on("complete", this, this);
		this._request.on("progress", this, this);
		this._request.on("loadStart", this, this);
		this._request.on("abort", this, this);
		this._request.on("timeout", this, this);
		this._request.on("error", this, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._request;
		this.dispatchEvent(evt);

		this._request.load();
	};

	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	p.cancel = function () {
		this.canceled = true;
		this.destroy();
	};

	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	p.destroy = function() {
		if (this._request) {
			this._request.removeAllEventListeners();
			this._request.destroy();
		}

		this._request = null;

		this._item = null;
		this._rawResult = null;
		this._result = null;

		this._loadItems = null;

		this.removeAllEventListeners();
	};

	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	p.getLoadedItems = function () {
		return this._loadedItems;
	};


	// Private methods
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	p._createTag = function(src) { return null; };

	/**
	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	p._sendLoadStart = function () {
		if (this._isCanceled()) { return; }
		this.dispatchEvent("loadstart");
	};

	/**
	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
	 * and <code>total</code> properties.
	 * @protected
	 */
	p._sendProgress = function (value) {
		if (this._isCanceled()) { return; }
		var event = null;
		if (typeof(value) == "number") {
			this.progress = value;
			event = new createjs.ProgressEvent(this.progress);
		} else {
			event = value;
			this.progress = value.loaded / value.total;
			event.progress = this.progress;
			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
		}
		this.hasEventListener("progress") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	p._sendComplete = function () {
		if (this._isCanceled()) { return; }

		this.loaded = true;

		var event = new createjs.Event("complete");
		event.rawResult = this._rawResult;

		if (this._result != null) {
			event.result = this._result;
		}

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	p._sendError = function (event) {
		if (this._isCanceled() || !this.hasEventListener("error")) { return; }
		if (event == null) {
			event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error
		}
		this.dispatchEvent(event);
	};

	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	p._isCanceled = function () {
		if (window.createjs == null || this.canceled) {
			return true;
		}
		return false;
	};

	/**
	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most
	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
	 * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.
	 * @property resultFormatter
	 * @type Function
	 * @return {Object} The formatted result
	 * @since 0.6.0
	 */
	p.resultFormatter = null;

	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target._response;
				var result = this.resultFormatter && this.resultFormatter(this);
				var _this = this;
				if (result instanceof Function) {
					result(function(result) {
						_this._result = result;
						_this._sendComplete();
					});
				} else {
					this._result =  result || this._rawResult;
					this._sendComplete();
				}
				break;
			case "progress":
				this._sendProgress(event);
				break;
			case "error":
				this._sendError(event);
				break;
			case "loadstart":
				this._sendLoadStart();
				break;
			case "abort":
			case "timeout":
				if (!this._isCanceled()) {
					this.dispatchEvent(event.type);
				}
				break;
		}
	};

	/**
	 * @method buildPath
	 * @protected
	 * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}
	 * instead.
	 */
	p.buildPath = function (src, data) {
		return createjs.RequestUtils.buildPath(src, data);
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function () {
		return "[PreloadJS AbstractLoader]";
	};

	createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
	 * handle HTML media elements, such as Video and Audio.
	 * @class AbstractMediaLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @param {String} type The type of media to load. Usually "video" or "audio".
	 * @extends AbstractLoader
	 * @constructor
	 */
	function AbstractMediaLoader(loadItem, preferXHR, type) {
		this.AbstractLoader_constructor(loadItem, preferXHR, type);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
	};

	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

	// static properties
	// public methods
	p.load = function () {
		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
		if (!this._tag) {
			this._tag = this._createTag(this._item.src);
		}

		this._tag.preload = "auto";
		this._tag.load();

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Creates a new tag for loading if it doesn't exist yet.
	 * @method _createTag
	 * @private
	 */
	p._createTag = function () {};


	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * The result formatter for media files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLVideoElement|HTMLAudioElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.onstalled = null;
		if (this._preferXHR) {
			loader.getTag().src = loader.getResult(true);
		}
		return loader.getTag();
	};

	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
	 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
	 * hood to get data.
	 * @class AbstractRequest
	 * @param {LoadItem} item
	 * @constructor
	 */
	var AbstractRequest = function (item) {
		this._item = item;
	};

	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

	// public methods
	/**
	 * Begin a load.
	 * @method load
	 */
	p.load =  function() {};

	/**
	 * Clean up a request.
	 * @method destroy
	 */
	p.destroy = function() {};

	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	p.cancel = function() {};

	createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 */
	function TagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		/**
		 * The HTML tag instance that is used to load.
		 * @property _tag
		 * @type {HTMLElement}
		 * @protected
		 */
		this._tag = tag;

		/**
		 * The tag attribute that specifies the source, such as "src", "href", etc.
		 * @property _tagSrcAttribute
		 * @type {String}
		 * @protected
		 */
		this._tagSrcAttribute = srcAttribute;

		/**
		 * A method closure used for handling the tag load event.
		 * @property _loadedHandler
		 * @type {Function}
		 * @private
		 */
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

		/**
		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
		 * @property _addedToDOM
		 * @type {Boolean}
		 * @private
		 */
		this._addedToDOM = false;

		/**
		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.
		 *
		 * @type {null}
		 * @private
		 */
		this._startTagVisibility = null;
	};

	var p = createjs.extend(TagRequest, createjs.AbstractRequest);

	// public methods
	p.load = function () {
		this._tag.onload = createjs.proxy(this._handleTagComplete, this);
		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
		this._tag.onerror = createjs.proxy(this._handleError, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._tag;

		this.dispatchEvent(evt);

		this._hideTag();

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		this._tag[this._tagSrcAttribute] = this._item.src;

		// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
		if (this._tag.parentNode == null) {
			window.document.body.appendChild(this._tag);
			this._addedToDOM = true;
		}
	};

	p.destroy = function() {
		this._clean();
		this._tag = null;

		this.AbstractRequest_destroy();
	};

	// private methods
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	p._handleError = function() {
		this._clean();
		this.dispatchEvent("error");
	};

	/**
	 * Handle the tag's onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	p._handleTagComplete = function () {
		this._rawResult = this._tag;
		this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;

		this._clean();
		this._showTag();

		this.dispatchEvent("complete");
	};

	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._clean();
		this.dispatchEvent(new createjs.Event("timeout"));
	};

	/**
	 * Remove event listeners, but don't destroy the request object
	 * @method _clean
	 * @private
	 */
	p._clean = function() {
		this._tag.onload = null;
		this._tag.onreadystatechange = null;
		this._tag.onerror = null;
		if (this._addedToDOM && this._tag.parentNode != null) {
			this._tag.parentNode.removeChild(this._tag);
		}
		clearTimeout(this._loadTimeout);
	};

	p._hideTag = function() {
		this._startTagVisibility = this._tag.style.visibility;
		this._tag.style.visibility = "hidden";
	};

	p._showTag = function() {
		this._tag.style.visibility = this._startTagVisibility;
	};

	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.
	 * @class MediaTagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLAudioElement|HTMLVideoElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 * @constructor
	 */
	function MediaTagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		this._tag = tag;
		this._tagSrcAttribute = srcAttribute;
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
	};

	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
	var s = MediaTagRequest;

	// public methods
	p.load = function () {
		var sc = createjs.proxy(this._handleStalled, this);
		this._stalledCallback = sc;

		var pc = createjs.proxy(this._handleProgress, this);
		this._handleProgress = pc;

		this._tag.addEventListener("stalled", sc);
		this._tag.addEventListener("progress", pc);

		// This will tell us when audio is buffered enough to play through, but not when its loaded.
		// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
		this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.

		this.TagRequest_load();
	};

	// private methods
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	/**
	 * An XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	// protected methods
	p._clean = function () {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.removeEventListener("stalled", this._stalledCallback);
		this._tag.removeEventListener("progress", this._progressCallback);

		this.TagRequest__clean();
	};

	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	function XHRRequest (item) {
		this.AbstractRequest_constructor(item);

		// protected properties
		/**
		 * A reference to the XHR request used to load the content.
		 * @property _request
		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
		 * @private
		 */
		this._request = null;

		/**
		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
		 * typically IE9).
		 * @property _loadTimeout
		 * @type {Number}
		 * @private
		 */
		this._loadTimeout = null;

		/**
		 * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
		 * the version, so we use capabilities to make a best guess.
		 * @property _xhrLevel
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._xhrLevel = 1;

		/**
		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		 * null until the file is loaded.
		 * @property _response
		 * @type {mixed}
		 * @private
		 */
		this._response = null;

		/**
		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
		 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
		 * want to access the raw content as it was loaded.
		 * @property _rawResponse
		 * @type {String|Object}
		 * @private
		 */
		this._rawResponse = null;

		this._canceled = false;

		// Setup our event handlers now.
		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
		this._handleErrorProxy = createjs.proxy(this._handleError, this);
		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

		if (!this._createXHR(item)) {
			//TODO: Throw error?
		}
	};

	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	XHRRequest.ACTIVEX_VERSIONS = [
		"Msxml2.XMLHTTP.6.0",
		"Msxml2.XMLHTTP.5.0",
		"Msxml2.XMLHTTP.4.0",
		"MSXML2.XMLHTTP.3.0",
		"MSXML2.XMLHTTP",
		"Microsoft.XMLHTTP"
	];

// Public methods
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>An binary arraybuffer loaded by XHR</li>
	 * </ul>
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (raw) {
		if (raw && this._rawResponse) {
			return this._rawResponse;
		}
		return this._response;
	};

	// Overrides abstract method in AbstractRequest
	p.cancel = function () {
		this.canceled = true;
		this._clean();
		this._request.abort();
	};

	// Overrides abstract method in AbstractLoader
	p.load = function () {
		if (this._request == null) {
			this._handleError();
			return;
		}

		//Events
		if (this._request.addEventListener != null) {
			this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
			this._request.addEventListener("progress", this._handleProgressProxy, false);
			this._request.addEventListener("abort", this._handleAbortProxy, false);
			this._request.addEventListener("error", this._handleErrorProxy, false);
			this._request.addEventListener("timeout", this._handleTimeoutProxy, false);

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.addEventListener("load", this._handleLoadProxy, false);
			this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
		} else {
			// IE9 support
			this._request.onloadstart = this._handleLoadStartProxy;
			this._request.onprogress = this._handleProgressProxy;
			this._request.onabort = this._handleAbortProxy;
			this._request.onerror = this._handleErrorProxy;
			this._request.ontimeout = this._handleTimeoutProxy;

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.onload = this._handleLoadProxy;
			this._request.onreadystatechange = this._handleReadyStateChangeProxy;
		}

		// Set up a timeout if we don't have XHR2
		if (this._xhrLevel == 1) {
			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
		}

		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
		try {
			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
				this._request.send();
			} else if (this._item.method == createjs.AbstractLoader.POST) {
				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
			}
		} catch (error) {
			this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
		}
	};

	p.setResponseType = function (type) {
		// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded
		if (type === 'blob') {
			type = window.URL ? 'blob' : 'arraybuffer';
			this._responseType = type;
		}
		this._request.responseType = type;
	};

	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getAllResponseHeaders = function () {
		if (this._request.getAllResponseHeaders instanceof Function) {
			return this._request.getAllResponseHeaders();
		} else {
			return null;
		}
	};

	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getResponseHeader = function (header) {
		if (this._request.getResponseHeader instanceof Function) {
			return this._request.getResponseHeader(header);
		} else {
			return null;
		}
	};

// protected methods
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	p._handleLoadStart = function (event) {
		clearTimeout(this._loadTimeout);
		this.dispatchEvent("loadstart");
	};

	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	p._handleAbort = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
	};

	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleError = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(event.message));
	};

	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	p._handleReadyStateChange = function (event) {
		if (this._request.readyState == 4) {
			this._handleLoad();
		}
	};

	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	p._handleLoad = function (event) {
		if (this.loaded) {
			return;
		}
		this.loaded = true;

		var error = this._checkError();
		if (error) {
			this._handleError(error);
			return;
		}

		this._response = this._getResponse();
		// Convert arraybuffer back to blob
		if (this._responseType === 'arraybuffer') {
			try {
				this._response = new Blob([this._response]);
			} catch (e) {
				// Fallback to use BlobBuilder if Blob constructor is not supported
				// Tested on Android 2.3 ~ 4.2 and iOS5 safari
				window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				if (e.name === 'TypeError' && window.BlobBuilder) {
					var builder = new BlobBuilder();
					builder.append(this._response);
					this._response = builder.getBlob();
				}
			}
		}
		this._clean();

		this.dispatchEvent(new createjs.Event("complete"));
	};

	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	p._handleTimeout = function (event) {
		this._clean();

		this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
	};

// Protected
	/**
	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note
	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.
	 * @method _checkError
	 * @return {int} If the request status returns an error code.
	 * @private
	 */
	p._checkError = function () {
		//LM: Probably need additional handlers here, maybe 501
		var status = parseInt(this._request.status);

		switch (status) {
			case 404:   // Not Found
			case 0:     // Not Loaded
				return new Error(status);
		}
		return null;
	};

	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.
	 * @method _getResponse
	 * @private
	 */
	p._getResponse = function () {
		if (this._response != null) {
			return this._response;
		}

		if (this._request.response != null) {
			return this._request.response;
		}

		// Android 2.2 uses .responseText
		try {
			if (this._request.responseText != null) {
				return this._request.responseText;
			}
		} catch (e) {
		}

		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml
		try {
			if (this._request.responseXML != null) {
				return this._request.responseXML;
			}
		} catch (e) {
		}

		return null;
	};

	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
	 *      <li>XMLHttpRequest are created when available.</li>
	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
	 *      <li>Text requests override the mime type if possible</li>
	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	p._createXHR = function (item) {
		// Check for cross-domain loads. We can't fully support them, but we can try.
		var crossdomain = createjs.RequestUtils.isCrossDomain(item);
		var headers = {};

		// Create the request. Fallback to whatever support we have.
		var req = null;
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			// This is 8 or 9, so use XDomainRequest instead.
			if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
				req = new XDomainRequest();
			}
		} else { // Old IE versions use a different approach
			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
				var axVersion = s.ACTIVEX_VERSIONS[i];
				try {
					req = new ActiveXObject(axVersion);
					break;
				} catch (e) {
				}
			}
			if (req == null) {
				return false;
			}
		}

		// Default to utf-8 for Text requests.
		if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
			item.mimeType = "text/plain; charset=utf-8";
		}

		// IE9 doesn't support overrideMimeType(), so we need to check for it.
		if (item.mimeType && req.overrideMimeType) {
			req.overrideMimeType(item.mimeType);
		}

		// Determine the XHR level
		this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;

		var src = null;
		if (item.method == createjs.AbstractLoader.GET) {
			src = createjs.RequestUtils.buildPath(item.src, item.values);
		} else {
			src = item.src;
		}

		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
		req.open(item.method || createjs.AbstractLoader.GET, src, true);

		if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
			headers["Origin"] = location.origin;
		}

		// To send data we need to set the Content-type header)
		if (item.values && item.method == createjs.AbstractLoader.POST) {
			headers["Content-Type"] = "application/x-www-form-urlencoded";
		}

		if (!crossdomain && !headers["X-Requested-With"]) {
			headers["X-Requested-With"] = "XMLHttpRequest";
		}

		if (item.headers) {
			for (var n in item.headers) {
				headers[n] = item.headers[n];
			}
		}

		for (n in headers) {
			req.setRequestHeader(n, headers[n])
		}

		if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
			req.withCredentials = item.withCredentials;
		}

		this._request = req;

		return true;
	};

	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	p._clean = function () {
		clearTimeout(this._loadTimeout);

		if (this._request.removeEventListener != null) {
			this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
			this._request.removeEventListener("progress", this._handleProgressProxy);
			this._request.removeEventListener("abort", this._handleAbortProxy);
			this._request.removeEventListener("error", this._handleErrorProxy);
			this._request.removeEventListener("timeout", this._handleTimeoutProxy);
			this._request.removeEventListener("load", this._handleLoadProxy);
			this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
		} else {
			this._request.onloadstart = null;
			this._request.onprogress = null;
			this._request.onabort = null;
			this._request.onerror = null;
			this._request.ontimeout = null;
			this._request.onload = null;
			this._request.onreadystatechange = null;
		}
	};

	p.toString = function () {
		return "[PreloadJS XHRRequest]";
	};

	createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");

}());

//##############################################################################
// LoadQueue.js
//##############################################################################

this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
	"use strict";

// constructor
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * <b>Creating a Queue</b><br />
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * <b>Listening for Events</b><br />
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
	 *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
	 *     files</li>
	 *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.</li>
	 *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.</li>
	 *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
	 *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
	 * </ul>
	 *
	 *      queue.on("fileload", handleFileLoad, this);
	 *      queue.on("complete", handleComplete, this);
	 *
	 * <b>Adding files and manifests</b><br />
	 * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile("filePath/file.jpg");
	 *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
	 *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest("path/to/manifest.json");
	 *      queue.loadManifest({src:"manifest.json", type:"manifest"});
	 *
	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * `loadNow` argument of `true`.
	 *
	 *      queue.load();
	 *
	 * <b>File Types</b><br />
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * <code>type</code> property with any manifest item.
	 *
	 *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.AbstractLoader.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:createjs.AbstractLoader.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:
	 * <ul>
	 *     <li>{{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
	 *     <li>{{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}: CSS files</li>
	 *     <li>{{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
	 *     <li>{{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
	 *     <li>{{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}: JSON data</li>
	 *     <li>{{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
	 *     <li>{{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>
	 *     <li>{{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
	 *     <li>{{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definiteions. This
	 *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>
	 *     <li>{{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}: SVG files</li>
	 *     <li>{{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
	 *     <li>{{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}: XML data</li>
	 * </ul>
	 *
	 * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better
	 * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but
	 * are deprecated.</em>
	 *
	 * <b>Handling Results</b><br />
	 * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * <ul>
	 *     <li>Binary: The binary loaded result</li>
	 *     <li>CSS: A &lt;link /&gt; tag</li>
	 *     <li>Image: An &lt;img /&gt; tag</li>
	 *     <li>JavaScript: A &lt;script /&gt; tag</li>
	 *     <li>JSON/JSONP: A formatted JavaScript Object</li>
	 *     <li>Manifest: A JavaScript object.
	 *     <li>Sound: An &lt;audio /&gt; tag</a>
	 *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.
	 *     <li>SVG: An &lt;object /&gt; tag</li>
	 *     <li>Text: Raw text</li>
	 *     <li>XML: An XML DOM node</li>
	 * </ul>
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.LoadQueue.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the
	 * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult("image");
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
	 *
	 * <b>Plugins</b><br />
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * <h4>Known Browser Issues</h4>
	 * <ul>
	 *     <li>Browsers without audio support can not load audio files.</li>
	 *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
	 *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
	 *     than Chrome will continue to download in the background.</li>
	 *     <li>When loading scripts using tags, they are automatically added to the document.</li>
	 *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
	 *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.</li>
	 *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.</li>
	 * </ul>
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
	 * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	function LoadQueue (preferXHR, basePath, crossOrigin) {
		this.AbstractLoader_constructor();

		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this._plugins = [];

		/**
		 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _typeCallbacks
		 * @type {Object}
		 * @private
		 */
		this._typeCallbacks = {};

		/**
		 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _extensionCallbacks
		 * @type {null}
		 * @private
		 */
		this._extensionCallbacks = {};

		/**
		 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
		 * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.
		 * @property next
		 * @type {LoadQueue}
		 * @default null
		 */
		this.next = null;

		/**
		 * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head
		 * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas
		 * scripts loaded using XHR can load in any order, but will "finish" and be added to the document in the order
		 * specified.
		 *
		 * Any items can be set to load in order by setting the {{#crossLink "maintainOrder:property"}}{{/crossLink}}
		 * property on the load item, or by ensuring that only one connection can be open at a time using
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property
		 * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the
		 * `maintainScriptOrder` to `false` during a load will not change items already in a queue.
		 *
		 * <h4>Example</h4>
		 *
		 *      var queue = new createjs.LoadQueue();
		 *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
		 *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
		 *      queue.loadManifest([
		 *          "script1.js",
		 *          "script2.js",
		 *          "image.png", // Load any time
		 *          {src: "image2.png", maintainOrder: true} // Will wait for script2.js
		 *          "image3.png",
		 *          "script3.js" // Will wait for image2.png before loading (or completing when loading with XHR)
		 *      ]);
		 *
		 * @property maintainScriptOrder
		 * @type {Boolean}
		 * @default true
		 */
		this.maintainScriptOrder = true;

		/**
		 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
		 * @property stopOnError
		 * @type {Boolean}
		 * @default false
		 */
		this.stopOnError = false;

		/**
		 * The number of maximum open connections that a loadQueue tries to maintain. Please see
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.
		 * @property _maxConnections
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._maxConnections = 1;

		/**
		 * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
		 * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
		 * handle the content, it will be selected. The default loader, ({{#crossLink "TextLoader"}}{{/crossLink}} is
		 * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
		 * {{#crossLink "LoadItem/type"}}{{/crossLink}}, which is automatically determined using the file extension of
		 * the {{#crossLink "LoadItem/src:property"}}{{/crossLink}}.
		 *
		 * Loaders can be removed from PreloadJS by simply not including them.
		 *
		 * Custom loaders installed using {{#crossLink "registerLoader"}}{{/crossLink}} will be prepended to this list
		 * so that they are checked first.
		 * @property _availableLoaders
		 * @type {Array}
		 * @private
		 * @since 0.6.0
		 */
		this._availableLoaders = [
			createjs.ImageLoader,
			createjs.JavaScriptLoader,
			createjs.CSSLoader,
			createjs.JSONLoader,
			createjs.JSONPLoader,
			createjs.SoundLoader,
			createjs.ManifestLoader,
			createjs.SpriteSheetLoader,
			createjs.XMLLoader,
			createjs.SVGLoader,
			createjs.BinaryLoader,
			createjs.VideoLoader,
			createjs.TextLoader,
		];

		/**
		 * The number of built in loaders, so they can't be removed by {{#crossLink "unregisterLoader"}}{{/crossLink}.
				 * @property _defaultLoaderLength
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._defaultLoaderLength = this._availableLoaders.length;

		this.init(preferXHR, basePath, crossOrigin);
	}

	var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
	var s = LoadQueue;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	p.init = function (preferXHR, basePath, crossOrigin) {

		// public properties
		/**
		 * @property useXHR
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 * @deprecated Use preferXHR instead.
		 */
		this.useXHR = true;

		/**
		 * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
		 * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
		 * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
		 * user-defined type.
		 * @type {Boolean}
		 * @default true
		 * @since 0.6.0
		 */
		this.preferXHR = true; //TODO: Get/Set
		this._preferXHR = true;
		this.setPreferXHR(preferXHR);

		// protected properties
		/**
		 * Whether the queue is currently paused or not.
		 * @property _paused
		 * @type {boolean}
		 * @private
		 */
		this._paused = false;

		/**
		 * A path that will be prepended on to the item's {{#crossLink "LoadItem/src:property"}}{{/crossLink}}. The
		 * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such
		 * as `http://`, or a relative path such as `../`.
		 * @property _basePath
		 * @type {String}
		 * @private
		 * @since 0.3.1
		 */
		this._basePath = basePath;

		/**
		 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
		 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
		 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
		 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""
		 * and "Anonymous".
		 * @property _crossOrigin
		 * @type {String}
		 * @default ""
		 * @private
		 * @since 0.4.1
		 */
		this._crossOrigin = crossOrigin;

		/**
		 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
		 * file is requested.
		 * @property _loadStartWasDispatched
		 * @type {Boolean}
		 * @default false
		 * @private
		 */
		this._loadStartWasDispatched = false;

		/**
		 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
		 * using a script tag to do preloading.
		 * @property _currentlyLoadingScript
		 * @type {Boolean}
		 * @private
		 */
		this._currentlyLoadingScript = null;

		/**
		 * An array containing the currently downloading files.
		 * @property _currentLoads
		 * @type {Array}
		 * @private
		 */
		this._currentLoads = [];

		/**
		 * An array containing the queued items that have not yet started downloading.
		 * @property _loadQueue
		 * @type {Array}
		 * @private
		 */
		this._loadQueue = [];

		/**
		 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
		 * @property _loadQueueBackup
		 * @type {Array}
		 * @private
		 */
		this._loadQueueBackup = [];

		/**
		 * An object hash of items that have finished downloading, indexed by the {{#crossLink "LoadItem"}}{{/crossLink}}
		 * id.
		 * @property _loadItemsById
		 * @type {Object}
		 * @private
		 */
		this._loadItemsById = {};

		/**
		 * An object hash of items that have finished downloading, indexed by {{#crossLink "LoadItem"}}{{/crossLink}}
		 * source.
		 * @property _loadItemsBySrc
		 * @type {Object}
		 * @private
		 */
		this._loadItemsBySrc = {};

		/**
		 * An object hash of loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedResults
		 * @type {Object}
		 * @private
		 */
		this._loadedResults = {};

		/**
		 * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedRawResults
		 * @type {Object}
		 * @private
		 */
		this._loadedRawResults = {};

		/**
		 * The number of items that have been requested. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded. This does not include items inside of loaders such as the
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _numItems
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItems = 0;

		/**
		 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded.
		 * @property _numItemsLoaded
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItemsLoaded = 0;

		/**
		 * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right
		 * order.
		 * @property _scriptOrder
		 * @type {Array}
		 * @private
		 */
		this._scriptOrder = [];

		/**
		 * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are
		 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>
		 * once they are complete and have been dispatched.
		 * @property _loadedScripts
		 * @type {Array}
		 * @private
		 */
		this._loadedScripts = [];

		/**
		 * The last progress amount. This is used to suppress duplicate progress events.
		 * @property _lastProgress
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._lastProgress = NaN;

	};

// static properties
	/**
	 * The time in milliseconds to assume a load has failed. An {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event is dispatched if the timeout is reached before any data is received.
	 * @property loadTimeout
	 * @type {Number}
	 * @default 8000
	 * @static
	 * @since 0.4.1
	 * @deprecated In favour of {{#crossLink "LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.
	 */
	s.loadTimeout = 8000;

	/**
	 * The time in milliseconds to assume a load has failed.
	 * @property LOAD_TIMEOUT
	 * @type {Number}
	 * @default 0
	 * @deprecated in favor of the {{#crossLink "LoadQueue/loadTimeout:property"}}{{/crossLink}} property.
	 */
	s.LOAD_TIMEOUT = 0;

// Preload Types
	/**
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}} instead.
	 */
	s.BINARY = createjs.AbstractLoader.BINARY;

	/**
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.CSS = createjs.AbstractLoader.CSS;

	/**
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.IMAGE = createjs.AbstractLoader.IMAGE;

	/**
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;

	/**
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}} instead.
	 */
	s.JSON = createjs.AbstractLoader.JSON;

	/**
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}} instead.
	 */
	s.JSONP = createjs.AbstractLoader.JSONP;

	/**
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.4.1
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}} instead.
	 */
	s.MANIFEST = createjs.AbstractLoader.MANIFEST;

	/**
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.SOUND = createjs.AbstractLoader.SOUND;

	/**
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.VIDEO = createjs.AbstractLoader.VIDEO;

	/**
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}} instead.
	 */
	s.SVG = createjs.AbstractLoader.SVG;

	/**
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}} instead.
	 */
	s.TEXT = createjs.AbstractLoader.TEXT;

	/**
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}} instead.
	 */
	s.XML = createjs.AbstractLoader.XML;

	/**
	 * @property POST
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} instead.
	 */
	s.POST = createjs.AbstractLoader.POST;

	/**
	 * @property GET
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} instead.
	 */
	s.GET = createjs.AbstractLoader.GET;

// events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file's progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

// public methods
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	p.registerLoader = function (loader) {
		if (!loader || !loader.canLoadItem) {
			throw new Error("loader is of an incorrect type.");
		} else if (this._availableLoaders.indexOf(loader) != -1) {
			throw new Error("loader already exists."); //LM: Maybe just silently fail here
		}

		this._availableLoaders.unshift(loader);
	};

	/**
	 * Remove a custom loader added usig {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	p.unregisterLoader = function (loader) {
		var idx = this._availableLoaders.indexOf(loader);
		if (idx != -1 && idx < this._defaultLoaderLength - 1) {
			this._availableLoaders.splice(idx, 1);
		}
	};

	/**
	 * @method setUseXHR
	 * @param {Boolean} value The new useXHR value to set.
	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
	 * the provided value argument was true.
	 * @since 0.3.0
	 * @deprecated use the {{#crossLink "preferXHR:property"}}{{/crossLink}} property, or the {{#crossLink "setUseXHR"}}{{/crossLink}}
	 * method instead.
	 */
	p.setUseXHR = function (value) {
		return this.setPreferXHR(value);
	};

	/**
	 * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may
	 * fail, or be ignored depending on the browser's capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	p.setPreferXHR = function (value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.preferXHR = (value != false && window.XMLHttpRequest != null);
		return this.preferXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function () {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * <h4>Example</h4>
	 *
	 *      queue.loadManifest([
	 *          {src:"test.png", id:"png"},
	 *          {src:"test.jpg", id:"jpg"},
	 *          {src:"test.mp3", id:"mp3"}
	 *      ]);
	 *      queue.remove("png"); // Single item by ID
	 *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
	 *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function (idsOrUrls) {
		var args = null;

		if (idsOrUrls && !(idsOrUrls instanceof Array)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length > 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.preferXHR, this._basePath);

			// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length - 1; i >= 0; i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i, 1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length - 1; i >= 0; i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i, 1)[0].cancel();
						break;
					}
				}

				if (r) {
					this._disposeItem(this.getItem(item));
				} else {
					for (var i = this._currentLoads.length - 1; i >= 0; i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i, 1)[0].cancel();
                            TQ.MultiHostQue.removeUrl(loadItem.src);
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function () {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
	 * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
	 * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
	 * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
	 * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function (plugin) {
		if (plugin == null) {
			return;
		}

		if (plugin.getPreloadHandlers != null) {
			this._plugins.push(plugin);
			var map = plugin.getPreloadHandlers();
			map.scope = plugin;

			if (map.types != null) {
				for (var i = 0, l = map.types.length; i < l; i++) {
					this._typeCallbacks[map.types[i]] = map;
				}
			}

			if (map.extensions != null) {
				for (i = 0, l = map.extensions.length; i < l; i++) {
					this._extensionCallbacks[map.extensions[i]] = map;
				}
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
	 * is `true`, only one script is loaded at a time due to browser limitations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused && this._loadQueue.length > 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadFile = function (file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.ErrorEvent("PRELOAD_NO_FILE");
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * <ol>
	 *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
	 *     which defines the list of files to load, and can optionally contain a "path" property, which will be
	 *     prepended to each file in the list.</li>
	 *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
	 *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
	 *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An Array of files to load.</li>
	 * </ol>
	 *
	 * Each "file" in a manifest can be either:
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadManifest = function (manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (manifest instanceof Array) {
			if (manifest.length == 0) {
				var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
				this._sendError(event);
				return;
			}
			fileList = manifest;

			// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === "string") {
			fileList = [
				{
					src: manifest,
					type: s.MANIFEST
				}
			];

		} else if (typeof(manifest) == "object") {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
					this._sendError(event);
				}
				fileList = [manifest];

				// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

			// Unsupported. This will throw an error.
		} else {
			var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
			this._sendError(event);
			return;
		}

		for (var i = 0, l = fileList.length; i < l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	p.load = function () {
		this.setPaused(false);
	};

	/**
	 * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was
	 * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getItem
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event as the `item` parameter.
	 */
	p.getItem = function (value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
	 * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getResult
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
	 *      DOM.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>A binary arraybuffer loaded by XHR</li>
	 *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.</li>
	 * </ul>
	 * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the 'item`
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) {
			return null;
		}
		var id = item.id;
		if (rawResult && this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	p.getItems = function (loaded) {
		var arr = [];
		for (var n in this._loadItemsById) {
			var item = this._loadItemsById[n];
			var result = this.getResult(n);
			if (loaded === true && result == null) {
				continue;
			}
			arr.push({
				item: item,
				result: result,
				rawResult: this.getResult(n, true)
			});
		}
		return arr;
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
	 * argument is `false`.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function (value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.
	 * @method close
	 */
	p.close = function () {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
        TQ.MultiHostQue.close();
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
		this._itemCount = 0;
		this._lastProgress = NaN;
	};

// protected methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
	 * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function (value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) {
			return;
		} // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			if ("plugins" in loader) {
				loader.plugins = this._plugins;
			}
			item._loader = loader;
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if ((this.maintainScriptOrder
					&& item.type == createjs.LoadQueue.JAVASCRIPT
						//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
					)
					|| item.maintainOrder === true) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function (value, path, basePath) {
		var item = createjs.LoadItem.create(value);
		if (item == null) {
			return null;
		}

		var bp = ""; // Store the generated basePath
		var useBasePath = basePath || this._basePath;

		if (item.src instanceof Object) {
			if (!item.type) {
				return null;
			} // the the src is an object, type is required to pass off to plugin
			if (path) {
				bp = path;
				var pathMatch = createjs.RequestUtils.parseURI(path);
				// Also append basePath
				if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		} else {
			// Determine Extension, etc.
			var match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension) {
				item.ext = match.extension;
			}
			if (item.type == null) {
				item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
			}

			// Inject path & basePath
			var autoId = item.src;
			if (!match.absolute && !match.relative) {
				if (path) {
					bp = path;
					var pathMatch = createjs.RequestUtils.parseURI(path);
					autoId = path + autoId;
					// Also append basePath
					if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
						bp = useBasePath + bp;
					}
				} else if (useBasePath != null) {
					bp = useBasePath;
				}
			}
			item.src = bp + item.src;
		}
		item.path = bp;

		// If there's no id, set one now.
		if (item.id === undefined || item.id === null || item.id === "") {
			item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item, this);

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

				// Load as normal:
			} else if (result === true) {
				// Do Nothing

				// Result is a loader class:
			} else if (result != null) {
				item._loader = result;
			}

			// Update the extension in case the type changed:
			match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension != null) {
				item.ext = match.extension;
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		if (item.crossOrigin == null) {
			item.crossOrigin = this._crossOrigin;
		}

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function (item) {
		if (item._loader != null) { // A plugin already specified a loader
			return item._loader;
		}

		// Initially, try and use the provided/supported XHR mode:
		var preferXHR = this.preferXHR;

		for (var i = 0; i < this._availableLoaders.length; i++) {
			var loader = this._availableLoaders[i];
			if (loader && loader.canLoadItem(item)) {
				return new loader(item, preferXHR);
			}
		}

		// TODO: Log error (requires createjs.log)
		return null;
	};

	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
	 * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function () {
		if (this._paused) {
			return;
		}

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next && this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i = 0; i < this._loadQueue.length; i++) {
			if (this._currentLoads.length >= this._maxConnections) {
				break;
			}
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one tag-script at a time:
			// Note: maintainOrder items don't do anything here because we can hold onto their loaded value
			if (!this._canStartLoad(loader)) {
				continue;
			}
			this._loadQueue.splice(i, 1);
			i--;
			this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function (loader) {
		loader.on("fileload", this._handleFileLoad, this);
		loader.on("progress", this._handleProgress, this);
		loader.on("complete", this._handleFileComplete, this);
		loader.on("error", this._handleError, this);
		loader.on("fileerror", this._handleFileError, this);
		this._currentLoads.push(loader);
        TQ.MultiHostQue.addUrl(loader.getItem().src);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	p._handleFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	p._handleFileError = function (event) {
		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);
		this._sendError(newEvent);
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
	 * is set to `true`.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleError = function (event) {
		var loader = event.target;
		this._numItemsLoaded++;

		this._finishOrderedItem(loader, true);
		this._updateProgress();

		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._cleanLoadItem(loader);
			this._loadNext();
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function (event) {
		var loader = event.target;
		var item = loader.getItem();

		var result = loader.getResult();
		this._loadedResults[item.id] = result;
		var rawResult = loader.getResult(true);
		if (rawResult != null && rawResult !== result) {
			this._loadedRawResults[item.id] = rawResult;
		}

		this._saveLoadedItems(loader);

		// Remove the load item
		this._removeLoadItem(loader);

		if (!this._finishOrderedItem(loader)) {
			// The item was NOT managed, so process it now
			this._processFinishedLoad(item, loader);
		}

		// Clean up the load item
		this._cleanLoadItem(loader);
	};

	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the
	 * LoadQueue's look-ups, including {{#crossLink "getItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	p._saveLoadedItems = function (loader) {
		// TODO: Not sure how to handle this. Would be nice to expose the items.
		// Loaders may load sub-items. This adds them to this queue
		var list = loader.getLoadedItems();
		if (list === null) {
			return;
		}

		for (var i = 0; i < list.length; i++) {
			var item = list[i].item;

			// Store item lookups
			this._loadItemsBySrc[item.src] = item;
			this._loadItemsById[item.id] = item;

			// Store loaded content
			this._loadedResults[item.id] = list[i].result;
			this._loadedRawResults[item.id] = list[i].rawResult;
		}
	};

	/**
	 * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	p._finishOrderedItem = function (loader, loadFailed) {
		var item = loader.getItem();

		if ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)
				|| item.maintainOrder) {

			//TODO: Evaluate removal of the _currentlyLoadingScript
			if (loader instanceof createjs.JavaScriptLoader) {
				this._currentlyLoadingScript = false;
			}

			var index = createjs.indexOf(this._scriptOrder, item);
			if (index == -1) {
				return false;
			} // This loader no longer exists
			this._loadedScripts[index] = (loadFailed === true) ? true : item;

			this._checkScriptLoadOrder();
			return true;
		}

		return false;
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to `true`. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i = 0; i < l; i++) {
			var item = this._loadedScripts[i];
			if (item === null) {
				break;
			} // This is still loading. Do not process further.
			if (item === true) {
				continue;
			} // This has completed, and been processed. Move on.

			var loadItem = this._loadedResults[item.id];
			if (item.type == createjs.LoadQueue.JAVASCRIPT) {
				// Append script tags to the head automatically.
				createjs.DomUtils.appendToHead(loadItem);
			}

			var loader = item._loader;
			this._processFinishedLoad(item, loader);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function (item, loader) {
		this._numItemsLoaded++;

		// Since LoadQueue needs maintain order, we can't append scripts in the loader.
		// So we do it here instead. Or in _checkScriptLoadOrder();
		if (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {
			createjs.DomUtils.appendToHead(item.result);
		}

		this._updateProgress();
		this._sendFileComplete(item, loader);
		this._loadNext();
	};

	/**
	 * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	p._canStartLoad = function (loader) {
		if (!this.maintainScriptOrder || loader.preferXHR) {
			return true;
		}
		var item = loader.getItem();
		if (item.type != createjs.LoadQueue.JAVASCRIPT) {
			return true;
		}
		if (this._currentlyLoadingScript) {
			return false;
		}

		var index = this._scriptOrder.indexOf(item);
		var i = 0;
		while (i < index) {
			var checkItem = this._loadedScripts[i];
			if (checkItem == null) {
				return false;
			}
			i++;
		}
		this._currentlyLoadingScript = true;
		return true;
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function (loader) {
		var l = this._currentLoads.length;
		for (var i = 0; i < l; i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i, 1);
                TQ.MultiHostQue.removeUrl(loader.getItem().src);
				break;
			}
		}
	};

	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	p._cleanLoadItem = function(loader) {
		var item = loader.getItem();
		if (item) {
			delete item._loader;
		}
	}

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function (event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before
	 * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * <ul>
	 *      <li>5/10 of the items in the queue (50%)</li>
	 *      <li>plus 20% of item 6's slot (2%)</li>
	 *      <li>equals 52%</li>
	 * </ul>
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems - this._numItemsLoaded;
		if (remaining > 0) {
			var chunk = 0;
			for (var i = 0, l = this._currentLoads.length; i < l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining / this._numItems);
		}

		if (this._lastProgress != loaded) {
			this._sendProgress(loaded);
			this._lastProgress = loaded;
		}
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function (item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};

	/**
	 * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function (item, progress) {
		if (this._isCanceled() || this._paused) {
			return;
		}
		if (!this.hasEventListener("fileprogress")) {
			return;
		}

		//LM: Rework ProgressEvent to support this?
		var event = new createjs.Event("fileprogress");
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function (item, loader) {
		if (this._isCanceled() || this._paused) {
			return;
		}

		var event = new createjs.Event("fileload");
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

		// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
		if (item.completeHandler) {
			item.completeHandler(event);
		}

		this.hasEventListener("fileload") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function (item) {
		var event = new createjs.Event("filestart");
		event.item = item;
		this.hasEventListener("filestart") && this.dispatchEvent(event);
	};

	p.toString = function () {
		return "[PreloadJS LoadQueue]";
	};

	createjs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");
}());

//##############################################################################
// TextLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for Text files.
	 * @class TextLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function TextLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);
	};

	var p = createjs.extend(TextLoader, createjs.AbstractLoader);
	var s = TextLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}},
	 * but is also the default loader if a file type can not be determined.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.TEXT;
	};

	createjs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");

}());

//##############################################################################
// BinaryLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.
	 * @class BinaryLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function BinaryLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);
		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
	var s = BinaryLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.BINARY;
	};

	// private methods
	/**
	 * Before the item loads, set the response type to "arraybuffer"
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.setResponseType("arraybuffer");
	};

	createjs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");

}());

//##############################################################################
// CSSLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class CSSLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function CSSLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "href";

		if (preferXHR) {
			this._tag = document.createElement("style");
		} else {
			this._tag = document.createElement("link");
		}

		this._tag.rel = "stylesheet";
		this._tag.type = "text/css";
	};

	var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
	var s = CSSLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.CSS;
	};

	// protected methods
	/**
	 * The result formatter for CSS files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		if (this._preferXHR) {
			var tag = loader.getTag();

			if (tag.styleSheet) { // IE
				tag.styleSheet.cssText = loader.getResult(true);
			} else {
				var textNode = document.createTextNode(loader.getResult(true));
				tag.appendChild(textNode);
			}
		} else {
			tag = this._tag;
		}

		createjs.DomUtils.appendToHead(tag);

		return tag;
	};

	createjs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");

}());

//##############################################################################
// ImageLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for image files.
	 * @class ImageLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ImageLoader (loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";

		// Check if the preload item is already a tag.
		if (createjs.RequestUtils.isImageTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {
			this._tag = loadItem.src;
		} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {
			this._tag = loadItem.tag;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		} else {
			this._tag = document.createElement("img");
		}

		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
	var s = ImageLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.IMAGE;
	};

	// public methods
	p.load = function () {
		if (this._tag.src != "" && this._tag.complete) {
			this._sendComplete();
			return;
		}

		var crossOrigin = this._item.crossOrigin;
		if (crossOrigin == true) { crossOrigin = "Anonymous"; }
		if (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {
			this._tag.crossOrigin = crossOrigin;
		}

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Before the item loads, set its mimeType and responseType.
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.mimeType = 'text/plain; charset=x-user-defined-binary';

		// Only exists for XHR
		if (event.loader.setResponseType) {
			event.loader.setResponseType("blob");
		}
	};

	/**
	 * The result formatter for Image files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLImageElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var _this = this;
		return function (done) {
			var tag = _this._tag;
			var URL = window.URL || window.webkitURL;

			if (!_this._preferXHR) {
				//document.body.removeChild(tag);
			} else if (URL) {
				var objURL = URL.createObjectURL(loader.getResult(true));
				tag.src = objURL;
				tag.onload = function () {
					URL.revokeObjectURL(_this.src);
				}
			} else {
				tag.src = loader.getItem().src;
			}

			if (tag.complete) {
				done(tag);
			} else {
				tag.onload = function () {
					done(this);
				}
			}
		};
	};

	createjs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");

}());

//##############################################################################
// JavaScriptLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JavaScript files.
	 * @class JavaScriptLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JavaScriptLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
		this.setTag(document.createElement("script"));
	};

	var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
	var s = JavaScriptLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JAVASCRIPT;
	};

	// protected methods
	/**
	 * The result formatter for JavaScript files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var tag = loader.getTag();
		if (this._preferXHR) {
			tag.text = loader.getResult(true);
		}
		return tag;
	};

	createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");

}());

//##############################################################################
// JSONLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink "JSONPLoader"}}{{/crossLink}}
	 * instead. To load JSON-formatted manifests, use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to
	 * load EaselJS SpriteSheets, use {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 * @class JSONLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
	var s = JSONLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSON && !item._loadAsJSONP;
	};

	// protected methods
	/**
	 * The result formatter for JSON files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var json = null;
		try {
			json = createjs.DataUtils.parseJSON(loader.getResult(true));
		} catch (e) {
			var event = new createjs.ErrorEvent("JSON_FORMAT", null, e);
			this._sendError(event);
			return e;
		}

		return json;
	};

	createjs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");

}());

//##############################################################################
// JSONPLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON
	 * without a callback use the {{#crossLink "JSONLoader"}}{{/crossLink}} instead. To load JSON-formatted manifests,
	 * use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use
	 * {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 *
	 * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded
	 * in order, either use the {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} method (set to 1),
	 * or set {{#crossLink "LoadItem/maintainOrder:property"}}{{/crossLink}} on items with the same callback.
	 * @class JSONPLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONPLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);
		this.setTag(document.createElement("script"));
		this.getTag().type = "text/javascript";
	};

	var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
	var s = JSONPLoader;


	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSONP || item._loadAsJSONP;
	};

	// public methods
	p.cancel = function () {
		this.AbstractLoader_cancel();
		this._dispose();
	};

	/**
	 * Loads the JSONp file.  Because of the unique loading needs of jsonP
	 * we don't use the AbstractLoader.load() method.
	 *
	 * @method load
	 *
	 */
	p.load = function () {
		if (this._item.callback == null) {
			throw new Error('callback is required for loading JSONP requests.');
		}

		// TODO: Look into creating our own iFrame to handle the load
		// In the first attempt, FF did not get the result
		//   result instanceof Object did not work either
		//   so we would need to clone the result.
		if (window[this._item.callback] != null) {
			throw new Error(
				"JSONP callback '" +
				this._item.callback +
				"' already exists on window. You need to specify a different callback or re-name the current one.");
		}

		window[this._item.callback] = createjs.proxy(this._handleLoad, this);
		window.document.body.appendChild(this._tag);

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		// Load the tag
		this._tag.src = this._item.src;
	};

	// private methods
	/**
	 * Handle the JSONP callback, which is a public method defined on `window`.
	 * @method _handleLoad
	 * @param {Object} data The formatted JSON data.
	 * @private
	 */
	p._handleLoad = function (data) {
		this._result = this._rawResult = data;
		this._sendComplete();

		this._dispose();
	};

	/**
	 * The tag request has not loaded within the time specfied in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._dispose();
		this.dispatchEvent(new createjs.ErrorEvent("timeout"));
	};

	/**
	 * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.
	 * @method _dispose
	 * @private
	 */
	p._dispose = function () {
		window.document.body.removeChild(this._tag);
		delete window[this._item.callback];

		clearTimeout(this._loadTimeout);
	};

	createjs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");

}());

//##############################################################################
// ManifestLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests
	 * using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}} as part of the
	 * {{#crossLink "LoadItem"}}{{/crossLink}}.
	 *
	 * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This
	 * example shows a sample manifest definition, as well as how to to include a sub-manifest.
	 *
	 * 		{
	 * 			"path": "assets/",
	 *	 	    "manifest": [
	 *				"image.png",
	 *				{"src": "image2.png", "id":"image2"},
	 *				{"src": "sub-manifest.json", "type":"manifest", "callback":"jsonCallback"}
	 *	 	    ]
	 *	 	}
	 *
	 * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink "LoadQueue"}}{{/crossLink}},
	 * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.
	 *
	 * Note that the {{#crossLink "JSONLoader"}}{{/crossLink}} and {{#crossLink "JSONPLoader"}}{{/crossLink}} are
	 * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink "LoadItem"}}{{/crossLink}}
	 * {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property to {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}.
	 * @class ManifestLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ManifestLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);

	// Public Properties
		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}},
		 * used to pass plugins to new LoadQueues that may be created.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this.plugins = null;


	// Protected Properties
		/**
		 * An internal {{#crossLink "LoadQueue"}}{{/crossLink}} that loads the contents of the manifest.
		 * @property _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	};

	var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
	var s = ManifestLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property MANIFEST_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.MANIFEST_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.MANIFEST;
	};

	// public methods
	p.load = function () {
		this.AbstractLoader_load();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.MANIFEST_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.MANIFEST_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	p.destroy = function() {
		this.AbstractLoader_destroy();
		this._manifestQueue.close();
	};

	/**
	 * Create and load the manifest items once the actual manifest has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.manifest) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("error", this._handleManifestError, this, true);
			for(var i = 0, l = this.plugins.length; i < l; i++) {	// conserve order of plugins
				queue.installPlugin(this.plugins[i]);
			}
			queue.loadManifest(json);
		} else {
			this._sendComplete();
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The manifest has completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the ManifestLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The manifest has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * The manifest has reported an error with one of the files.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
	 * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an
	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the
	 * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.
	 * @class SoundLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function SoundLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);

		// protected properties
		if (createjs.RequestUtils.isAudioTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		}
	};

	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
	var s = SoundLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SOUND;
	};

	// protected methods
	p._createTag = function (src) {
		var tag = document.createElement("audio");
		tag.autoplay = false;
		tag.preload = "none";

		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
		tag.src = src;
		return tag;
	};

	createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");

}());

//##############################################################################
// VideoLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for video files.
	 * @class VideoLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function VideoLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);

		if (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {
			this.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);

			// We can't use XHR for a tag that's passed in.
			this._preferXHR = false;
		} else {
			this.setTag(this._createTag());
		}
	};

	var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
	var s = VideoLoader;

	/**
	 * Create a new video tag
	 *
	 * @returns {HTMLElement}
	 * @private
	 */
	p._createTag = function () {
		return document.createElement("video");
	};

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/VIDEO:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.VIDEO;
	};

	createjs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");

}());

//##############################################################################
// SpriteSheetLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader
	 * completes. To load SpriteSheets using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}
	 * as part of the {{#crossLink "LoadItem"}}{{/crossLink}}. Note that the {{#crossLink "JSONLoader"}}{{/crossLink}}
	 * and {{#crossLink "JSONPLoader"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>
	 * set the {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property
	 * to {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}.
	 * @class SpriteSheetLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SpriteSheetLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.SPRITESHEET);

		// protected properties
		/**
		 * An internal queue which loads the SpriteSheet's images.
		 * @method _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	}

	var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
	var s = SpriteSheetLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property SPRITESHEET_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.SPRITESHEET_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SPRITESHEET;
	};

	// public methods
	p.destroy = function() {
		this.AbstractLoader_destroy;
		this._manifestQueue.close();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null && callback instanceof Function) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.SPRITESHEET_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.SPRITESHEET_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	/**
	 * Create and load the images once the SpriteSheet JSON has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.images) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("error", this._handleManifestError, this, true);
			queue.loadManifest(json.images);
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		var image = event.result;
		if (image != null) {
			var images = this.getResult().images;
			var pos = images.indexOf(event.item.src);
			images[pos] = image;
		}
	};

	/**
	 * The images have completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the SpriteSheetLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._result = new createjs.SpriteSheet(this._result);
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The images {{#crossLink "LoadQueue"}}{{/crossLink}} has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * An image has reported an error.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");

}());

//##############################################################################
// SVGLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for SVG files.
	 * @class SVGLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SVGLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "data";

		if (preferXHR) {
			this.setTag(document.createElement("svg"));
		} else {
			this.setTag(document.createElement("object"));
			this.getTag().type = "image/svg+xml";
		}
	};

	var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
	var s = SVGLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SVG;
	};

	// protected methods
	/**
	 * The result formatter for SVG files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {Object}
	 * @private
	 */
	p._formatResult = function (loader) {
		// mime should be image/svg+xml, but Opera requires text/xml
		var xml = createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
		var tag = loader.getTag();

		if (!this._preferXHR && document.body.contains(tag)) {
			document.body.removeChild(tag);
		}

		if (xml.documentElement != null) {
			tag.appendChild(xml.documentElement);
			tag.style.visibility = "visible";
			return tag;
		} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)
			return xml;
		}
	};

	createjs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");

}());

//##############################################################################
// XMLLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class XMLLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function XMLLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
	var s = XMLLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.XML;
	};

	// protected methods
	/**
	 * The result formatter for XML files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {XMLDocument}
	 * @private
	 */
	p._formatResult = function (loader) {
		return createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
	};

	createjs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");

}());

/*!
* @license EaselJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2011-2015 gskinner.com, inc.
*
* Distributed under the terms of the MIT license.
* http://www.opensource.org/licenses/mit-license.html
*
* This notice shall be included in all copies or substantial portions of the Software.
*/
this.createjs=this.createjs||{},createjs.extend=function(a,b){"use strict";function c(){this.constructor=a}return c.prototype=b.prototype,a.prototype=new c},this.createjs=this.createjs||{},createjs.promote=function(a,b){"use strict";var c=a.prototype,d=Object.getPrototypeOf&&Object.getPrototypeOf(c)||c.__proto__;if(d){c[(b+="_")+"constructor"]=d.constructor;for(var e in d)c.hasOwnProperty(e)&&"function"==typeof d[e]&&(c[b+e]=d[e])}return a},this.createjs=this.createjs||{},createjs.indexOf=function(a,b){"use strict";for(var c=0,d=a.length;d>c;c++)if(b===a[c])return c;return-1},this.createjs=this.createjs||{},function(){"use strict";function a(){throw"UID cannot be instantiated"}a._nextID=0,a.get=function(){return a._nextID++},createjs.UID=a}(),this.createjs=this.createjs||{},createjs.deprecate=function(a,b){"use strict";return function(){var c="Deprecated property or method '"+b+"'. See docs for info.";return console&&(console.warn?console.warn(c):console.log(c)),a&&a.apply(this,arguments)}},this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){this.type=a,this.target=null,this.currentTarget=null,this.eventPhase=0,this.bubbles=!!b,this.cancelable=!!c,this.timeStamp=(new Date).getTime(),this.defaultPrevented=!1,this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.removed=!1}var b=a.prototype;b.preventDefault=function(){this.defaultPrevented=this.cancelable&&!0},b.stopPropagation=function(){this.propagationStopped=!0},b.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},b.remove=function(){this.removed=!0},b.clone=function(){return new a(this.type,this.bubbles,this.cancelable)},b.set=function(a){for(var b in a)this[b]=a[b];return this},b.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this._listeners=null,this._captureListeners=null}var b=a.prototype;a.initialize=function(a){a.addEventListener=b.addEventListener,a.on=b.on,a.removeEventListener=a.off=b.removeEventListener,a.removeAllEventListeners=b.removeAllEventListeners,a.hasEventListener=b.hasEventListener,a.dispatchEvent=b.dispatchEvent,a._dispatchEvent=b._dispatchEvent,a.willTrigger=b.willTrigger},b.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},b.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},b.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},b.off=b.removeEventListener,b.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},b.dispatchEvent=function(a,b,c){if("string"==typeof a){var d=this._listeners;if(!(b||d&&d[a]))return!0;a=new createjs.Event(a,b,c)}else a.target&&a.clone&&(a=a.clone());try{a.target=this}catch(e){}if(a.bubbles&&this.parent){for(var f=this,g=[f];f.parent;)g.push(f=f.parent);var h,i=g.length;for(h=i-1;h>=0&&!a.propagationStopped;h--)g[h]._dispatchEvent(a,1+(0==h));for(h=1;i>h&&!a.propagationStopped;h++)g[h]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return!a.defaultPrevented},b.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},b.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},b.toString=function(){return"[EventDispatcher]"},b._dispatchEvent=function(a,b){var c,d,e=2>=b?this._captureListeners:this._listeners;if(a&&e&&(d=e[a.type])&&(c=d.length)){try{a.currentTarget=this}catch(f){}try{a.eventPhase=0|b}catch(f){}a.removed=!1,d=d.slice();for(var g=0;c>g&&!a.immediatePropagationStopped;g++){var h=d[g];h.handleEvent?h.handleEvent(a):h(a),a.removed&&(this.off(a.type,h,1==b),a.removed=!1)}}2===b&&this._dispatchEvent(a,2.1)},createjs.EventDispatcher=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"Ticker cannot be instantiated."}a.RAF_SYNCHED="synched",a.RAF="raf",a.TIMEOUT="timeout",a.timingMode=null,a.maxDelta=0,a.paused=!1,a.removeEventListener=null,a.removeAllEventListeners=null,a.dispatchEvent=null,a.hasEventListener=null,a._listeners=null,createjs.EventDispatcher.initialize(a),a._addEventListener=a.addEventListener,a.addEventListener=function(){return!a._inited&&a.init(),a._addEventListener.apply(a,arguments)},a._inited=!1,a._startTime=0,a._pausedTime=0,a._ticks=0,a._pausedTicks=0,a._interval=50,a._lastTime=0,a._times=null,a._tickTimes=null,a._timerId=null,a._raf=!0,a._setInterval=function(b){a._interval=b,a._inited&&a._setupTick()},a.setInterval=createjs.deprecate(a._setInterval,"Ticker.setInterval"),a._getInterval=function(){return a._interval},a.getInterval=createjs.deprecate(a._getInterval,"Ticker.getInterval"),a._setFPS=function(b){a._setInterval(1e3/b)},a.setFPS=createjs.deprecate(a._setFPS,"Ticker.setFPS"),a._getFPS=function(){return 1e3/a._interval},a.getFPS=createjs.deprecate(a._getFPS,"Ticker.getFPS");try{Object.defineProperties(a,{interval:{get:a._getInterval,set:a._setInterval},framerate:{get:a._getFPS,set:a._setFPS}})}catch(b){console.log(b)}a.init=function(){a._inited||(a._inited=!0,a._times=[],a._tickTimes=[],a._startTime=a._getTime(),a._times.push(a._lastTime=0),a.interval=a._interval)},a.reset=function(){if(a._raf){var b=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame;b&&b(a._timerId)}else clearTimeout(a._timerId);a.removeAllEventListeners("tick"),a._timerId=a._times=a._tickTimes=null,a._startTime=a._lastTime=a._ticks=a._pausedTime=0,a._inited=!1},a.getMeasuredTickTime=function(b){var c=0,d=a._tickTimes;if(!d||d.length<1)return-1;b=Math.min(d.length,b||0|a._getFPS());for(var e=0;b>e;e++)c+=d[e];return c/b},a.getMeasuredFPS=function(b){var c=a._times;return!c||c.length<2?-1:(b=Math.min(c.length-1,b||0|a._getFPS()),1e3/((c[0]-c[b])/b))},a.getTime=function(b){return a._startTime?a._getTime()-(b?a._pausedTime:0):-1},a.getEventTime=function(b){return a._startTime?(a._lastTime||a._startTime)-(b?a._pausedTime:0):-1},a.getTicks=function(b){return a._ticks-(b?a._pausedTicks:0)},a._handleSynch=function(){a._timerId=null,a._setupTick(),a._getTime()-a._lastTime>=.97*(a._interval-1)&&a._tick()},a._handleRAF=function(){a._timerId=null,a._setupTick(),a._tick()},a._handleTimeout=function(){a._timerId=null,a._setupTick(),a._tick()},a._setupTick=function(){if(null==a._timerId){var b=a.timingMode;if(b==a.RAF_SYNCHED||b==a.RAF){var c=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;if(c)return a._timerId=c(b==a.RAF?a._handleRAF:a._handleSynch),void(a._raf=!0)}a._raf=!1,a._timerId=setTimeout(a._handleTimeout,a._interval)}},a._tick=function(){var b=a.paused,c=a._getTime(),d=c-a._lastTime;if(a._lastTime=c,a._ticks++,b&&(a._pausedTicks++,a._pausedTime+=d),a.hasEventListener("tick")){var e=new createjs.Event("tick"),f=a.maxDelta;e.delta=f&&d>f?f:d,e.paused=b,e.time=c,e.runTime=c-a._pausedTime,a.dispatchEvent(e)}for(a._tickTimes.unshift(a._getTime()-c);a._tickTimes.length>100;)a._tickTimes.pop();for(a._times.unshift(c);a._times.length>100;)a._times.pop()};var c=window,d=c.performance.now||c.performance.mozNow||c.performance.msNow||c.performance.oNow||c.performance.webkitNow;a._getTime=function(){return(d&&d.call(c.performance)||(new Date).getTime())-a._startTime},createjs.Ticker=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.readyState=a.readyState,this._video=a,this._canvas=null,this._lastTime=-1,this.readyState<2&&a.addEventListener("canplaythrough",this._videoReady.bind(this))}var b=a.prototype;b.getImage=function(){if(!(this.readyState<2)){var a=this._canvas,b=this._video;if(a||(a=this._canvas=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"),a.width=b.videoWidth,a.height=b.videoHeight),b.readyState>=2&&b.currentTime!==this._lastTime){var c=a.getContext("2d");c.clearRect(0,0,a.width,a.height),c.drawImage(b,0,0,a.width,a.height),this._lastTime=b.currentTime}return a}},b._videoReady=function(){this.readyState=2},createjs.VideoBuffer=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f,g,h,i,j,k){this.Event_constructor(a,b,c),this.stageX=d,this.stageY=e,this.rawX=null==i?d:i,this.rawY=null==j?e:j,this.nativeEvent=f,this.pointerID=g,this.primary=!!h,this.relatedTarget=k}var b=createjs.extend(a,createjs.Event);b._get_localX=function(){return this.currentTarget.globalToLocal(this.rawX,this.rawY).x},b._get_localY=function(){return this.currentTarget.globalToLocal(this.rawX,this.rawY).y},b._get_isTouch=function(){return-1!==this.pointerID};try{Object.defineProperties(b,{localX:{get:b._get_localX},localY:{get:b._get_localY},isTouch:{get:b._get_isTouch}})}catch(c){}b.clone=function(){return new a(this.type,this.bubbles,this.cancelable,this.stageX,this.stageY,this.nativeEvent,this.pointerID,this.primary,this.rawX,this.rawY)},b.toString=function(){return"[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]"},createjs.MouseEvent=createjs.promote(a,"Event")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f){this.setValues(a,b,c,d,e,f)}var b=a.prototype;a.DEG_TO_RAD=Math.PI/180,a.identity=null,b.setValues=function(a,b,c,d,e,f){return this.a=null==a?1:a,this.b=b||0,this.c=c||0,this.d=null==d?1:d,this.tx=e||0,this.ty=f||0,this},b.append=function(a,b,c,d,e,f){var g=this.a,h=this.b,i=this.c,j=this.d;return(1!=a||0!=b||0!=c||1!=d)&&(this.a=g*a+i*b,this.b=h*a+j*b,this.c=g*c+i*d,this.d=h*c+j*d),this.tx=g*e+i*f+this.tx,this.ty=h*e+j*f+this.ty,this},b.prepend=function(a,b,c,d,e,f){var g=this.a,h=this.c,i=this.tx;return this.a=a*g+c*this.b,this.b=b*g+d*this.b,this.c=a*h+c*this.d,this.d=b*h+d*this.d,this.tx=a*i+c*this.ty+e,this.ty=b*i+d*this.ty+f,this},b.appendMatrix=function(a){return this.append(a.a,a.b,a.c,a.d,a.tx,a.ty)},b.prependMatrix=function(a){return this.prepend(a.a,a.b,a.c,a.d,a.tx,a.ty)},b.appendTransform=function(b,c,d,e,f,g,h,i,j){if(f%360)var k=f*a.DEG_TO_RAD,l=Math.cos(k),m=Math.sin(k);else l=1,m=0;return g||h?(g*=a.DEG_TO_RAD,h*=a.DEG_TO_RAD,this.append(Math.cos(h),Math.sin(h),-Math.sin(g),Math.cos(g),b,c),this.append(l*d,m*d,-m*e,l*e,0,0)):this.append(l*d,m*d,-m*e,l*e,b,c),(i||j)&&(this.tx-=i*this.a+j*this.c,this.ty-=i*this.b+j*this.d),this},b.prependTransform=function(b,c,d,e,f,g,h,i,j){if(f%360)var k=f*a.DEG_TO_RAD,l=Math.cos(k),m=Math.sin(k);else l=1,m=0;return(i||j)&&(this.tx-=i,this.ty-=j),g||h?(g*=a.DEG_TO_RAD,h*=a.DEG_TO_RAD,this.prepend(l*d,m*d,-m*e,l*e,0,0),this.prepend(Math.cos(h),Math.sin(h),-Math.sin(g),Math.cos(g),b,c)):this.prepend(l*d,m*d,-m*e,l*e,b,c),this},b.rotate=function(b){b*=a.DEG_TO_RAD;var c=Math.cos(b),d=Math.sin(b),e=this.a,f=this.b;return this.a=e*c+this.c*d,this.b=f*c+this.d*d,this.c=-e*d+this.c*c,this.d=-f*d+this.d*c,this},b.skew=function(b,c){return b*=a.DEG_TO_RAD,c*=a.DEG_TO_RAD,this.append(Math.cos(c),Math.sin(c),-Math.sin(b),Math.cos(b),0,0),this},b.scale=function(a,b){return this.a*=a,this.b*=a,this.c*=b,this.d*=b,this},b.translate=function(a,b){return this.tx+=this.a*a+this.c*b,this.ty+=this.b*a+this.d*b,this},b.identity=function(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this},b.invert=function(){var a=this.a,b=this.b,c=this.c,d=this.d,e=this.tx,f=a*d-b*c;return this.a=d/f,this.b=-b/f,this.c=-c/f,this.d=a/f,this.tx=(c*this.ty-d*e)/f,this.ty=-(a*this.ty-b*e)/f,this},b.isIdentity=function(){return 0===this.tx&&0===this.ty&&1===this.a&&0===this.b&&0===this.c&&1===this.d},b.equals=function(a){return this.tx===a.tx&&this.ty===a.ty&&this.a===a.a&&this.b===a.b&&this.c===a.c&&this.d===a.d},b.transformPoint=function(a,b,c){return c=c||{},c.x=a*this.a+b*this.c+this.tx,c.y=a*this.b+b*this.d+this.ty,c},b.decompose=function(b){null==b&&(b={}),b.x=this.tx,b.y=this.ty,b.scaleX=Math.sqrt(this.a*this.a+this.b*this.b),b.scaleY=Math.sqrt(this.c*this.c+this.d*this.d);var c=Math.atan2(-this.c,this.d),d=Math.atan2(this.b,this.a),e=Math.abs(1-c/d);return 1e-5>e?(b.rotation=d/a.DEG_TO_RAD,this.a<0&&this.d>=0&&(b.rotation+=b.rotation<=0?180:-180),b.skewX=b.skewY=0):(b.skewX=c/a.DEG_TO_RAD,b.skewY=d/a.DEG_TO_RAD),b},b.copy=function(a){return this.setValues(a.a,a.b,a.c,a.d,a.tx,a.ty)},b.clone=function(){return new a(this.a,this.b,this.c,this.d,this.tx,this.ty)},b.toString=function(){return"[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]"},a.identity=new a,createjs.Matrix2D=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e){this.setValues(a,b,c,d,e)}var b=a.prototype;b.setValues=function(a,b,c,d,e){return this.visible=null==a?!0:!!a,this.alpha=null==b?1:b,this.shadow=c,this.compositeOperation=d,this.matrix=e||this.matrix&&this.matrix.identity()||new createjs.Matrix2D,this},b.append=function(a,b,c,d,e){return this.alpha*=b,this.shadow=c||this.shadow,this.compositeOperation=d||this.compositeOperation,this.visible=this.visible&&a,e&&this.matrix.appendMatrix(e),this},b.prepend=function(a,b,c,d,e){return this.alpha*=b,this.shadow=this.shadow||c,this.compositeOperation=this.compositeOperation||d,this.visible=this.visible&&a,e&&this.matrix.prependMatrix(e),this},b.identity=function(){return this.visible=!0,this.alpha=1,this.shadow=this.compositeOperation=null,this.matrix.identity(),this},b.clone=function(){return new a(this.alpha,this.shadow,this.compositeOperation,this.visible,this.matrix.clone())},createjs.DisplayProps=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.setValues(a,b)}var b=a.prototype;b.setValues=function(a,b){return this.x=a||0,this.y=b||0,this},b.copy=function(a){return this.x=a.x,this.y=a.y,this},b.clone=function(){return new a(this.x,this.y)},b.toString=function(){return"[Point (x="+this.x+" y="+this.y+")]"},createjs.Point=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d){this.setValues(a,b,c,d)}var b=a.prototype;b.setValues=function(a,b,c,d){return this.x=a||0,this.y=b||0,this.width=c||0,this.height=d||0,this},b.extend=function(a,b,c,d){return c=c||0,d=d||0,a+c>this.x+this.width&&(this.width=a+c-this.x),b+d>this.y+this.height&&(this.height=b+d-this.y),a<this.x&&(this.width+=this.x-a,this.x=a),b<this.y&&(this.height+=this.y-b,this.y=b),this},b.pad=function(a,b,c,d){return this.x-=b,this.y-=a,this.width+=b+d,this.height+=a+c,this},b.copy=function(a){return this.setValues(a.x,a.y,a.width,a.height)},b.contains=function(a,b,c,d){return c=c||0,d=d||0,a>=this.x&&a+c<=this.x+this.width&&b>=this.y&&b+d<=this.y+this.height},b.union=function(a){return this.clone().extend(a.x,a.y,a.width,a.height)},b.intersection=function(b){var c=b.x,d=b.y,e=c+b.width,f=d+b.height;return this.x>c&&(c=this.x),this.y>d&&(d=this.y),this.x+this.width<e&&(e=this.x+this.width),this.y+this.height<f&&(f=this.y+this.height),c>=e||d>=f?null:new a(c,d,e-c,f-d)},b.intersects=function(a){return a.x<=this.x+this.width&&this.x<=a.x+a.width&&a.y<=this.y+this.height&&this.y<=a.y+a.height},b.isEmpty=function(){return this.width<=0||this.height<=0},b.clone=function(){return new a(this.x,this.y,this.width,this.height)},b.toString=function(){return"[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]"},createjs.Rectangle=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f,g){a.addEventListener&&(this.target=a,this.overLabel=null==c?"over":c,this.outLabel=null==b?"out":b,this.downLabel=null==d?"down":d,this.play=e,this._isPressed=!1,this._isOver=!1,this._enabled=!1,a.mouseChildren=!1,this.enabled=!0,this.handleEvent({}),f&&(g&&(f.actionsEnabled=!1,f.gotoAndStop&&f.gotoAndStop(g)),a.hitArea=f))}var b=a.prototype;b._setEnabled=function(a){if(a!=this._enabled){var b=this.target;this._enabled=a,a?(b.cursor="pointer",b.addEventListener("rollover",this),b.addEventListener("rollout",this),b.addEventListener("mousedown",this),b.addEventListener("pressup",this),b._reset&&(b.__reset=b._reset,b._reset=this._reset)):(b.cursor=null,b.removeEventListener("rollover",this),b.removeEventListener("rollout",this),b.removeEventListener("mousedown",this),b.removeEventListener("pressup",this),b.__reset&&(b._reset=b.__reset,delete b.__reset))}},b.setEnabled=createjs.deprecate(b._setEnabled,"ButtonHelper.setEnabled"),b._getEnabled=function(){return this._enabled},b.getEnabled=createjs.deprecate(b._getEnabled,"ButtonHelper.getEnabled");try{Object.defineProperties(b,{enabled:{get:b._getEnabled,set:b._setEnabled}})}catch(c){}b.toString=function(){return"[ButtonHelper]"},b.handleEvent=function(a){var b,c=this.target,d=a.type;"mousedown"==d?(this._isPressed=!0,b=this.downLabel):"pressup"==d?(this._isPressed=!1,b=this._isOver?this.overLabel:this.outLabel):"rollover"==d?(this._isOver=!0,b=this._isPressed?this.downLabel:this.overLabel):(this._isOver=!1,b=this._isPressed?this.overLabel:this.outLabel),this.play?c.gotoAndPlay&&c.gotoAndPlay(b):c.gotoAndStop&&c.gotoAndStop(b)},b._reset=function(){var a=this.paused;this.__reset(),this.paused=a},createjs.ButtonHelper=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d){this.color=a||"black",this.offsetX=b||0,this.offsetY=c||0,this.blur=d||0}var b=a.prototype;a.identity=new a("transparent",0,0,0),b.toString=function(){return"[Shadow]"},b.clone=function(){return new a(this.color,this.offsetX,this.offsetY,this.blur)},createjs.Shadow=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.EventDispatcher_constructor(),this.complete=!0,this.framerate=0,this._animations=null,this._frames=null,this._images=null,this._data=null,this._loadCount=0,this._frameHeight=0,this._frameWidth=0,this._numFrames=0,this._regX=0,this._regY=0,this._spacing=0,this._margin=0,this._parseData(a)}var b=createjs.extend(a,createjs.EventDispatcher);b._getAnimations=function(){return this._animations.slice()},b.getAnimations=createjs.deprecate(b._getAnimations,"SpriteSheet.getAnimations");try{Object.defineProperties(b,{animations:{get:b._getAnimations}})}catch(c){}b.getNumFrames=function(a){if(null==a)return this._frames?this._frames.length:this._numFrames||0;var b=this._data[a];return null==b?0:b.frames.length},b.getAnimation=function(a){return this._data[a]},b.getFrame=function(a){var b;return this._frames&&(b=this._frames[a])?b:null},b.getFrameBounds=function(a,b){var c=this.getFrame(a);return c?(b||new createjs.Rectangle).setValues(-c.regX,-c.regY,c.rect.width,c.rect.height):null},b.toString=function(){return"[SpriteSheet]"},b.clone=function(){throw"SpriteSheet cannot be cloned."},b._parseData=function(a){var b,c,d,e;if(null!=a){if(this.framerate=a.framerate||0,a.images&&(c=a.images.length)>0)for(e=this._images=[],b=0;c>b;b++){var f=a.images[b];if("string"==typeof f){var g=f;f=document.createElement("img"),f.src=g}e.push(f),f.getContext||f.naturalWidth||(this._loadCount++,this.complete=!1,function(a,b){f.onload=function(){a._handleImageLoad(b)}}(this,g),function(a,b){f.onerror=function(){a._handleImageError(b)}}(this,g))}if(null==a.frames);else if(Array.isArray(a.frames))for(this._frames=[],e=a.frames,b=0,c=e.length;c>b;b++){var h=e[b];this._frames.push({image:this._images[h[4]?h[4]:0],rect:new createjs.Rectangle(h[0],h[1],h[2],h[3]),regX:h[5]||0,regY:h[6]||0})}else d=a.frames,this._frameWidth=d.width,this._frameHeight=d.height,this._regX=d.regX||0,this._regY=d.regY||0,this._spacing=d.spacing||0,this._margin=d.margin||0,this._numFrames=d.count,0==this._loadCount&&this._calculateFrames();if(this._animations=[],null!=(d=a.animations)){this._data={};var i;for(i in d){var j={name:i},k=d[i];if("number"==typeof k)e=j.frames=[k];else if(Array.isArray(k))if(1==k.length)j.frames=[k[0]];else for(j.speed=k[3],j.next=k[2],e=j.frames=[],b=k[0];b<=k[1];b++)e.push(b);else{j.speed=k.speed,j.next=k.next;var l=k.frames;e=j.frames="number"==typeof l?[l]:l.slice(0)}(j.next===!0||void 0===j.next)&&(j.next=i),(j.next===!1||e.length<2&&j.next==i)&&(j.next=null),j.speed||(j.speed=1),this._animations.push(i),this._data[i]=j}}}},b._handleImageLoad=function(){0==--this._loadCount&&(this._calculateFrames(),this.complete=!0,this.dispatchEvent("complete"))},b._handleImageError=function(a){var b=new createjs.Event("error");b.src=a,this.dispatchEvent(b),0==--this._loadCount&&this.dispatchEvent("complete")},b._calculateFrames=function(){if(!this._frames&&0!=this._frameWidth){this._frames=[];var a=this._numFrames||1e5,b=0,c=this._frameWidth,d=this._frameHeight,e=this._spacing,f=this._margin;a:for(var g=0,h=this._images;g<h.length;g++)for(var i=h[g],j=i.width||i.naturalWidth,k=i.height||i.naturalHeight,l=f;k-f-d>=l;){for(var m=f;j-f-c>=m;){if(b>=a)break a;b++,this._frames.push({image:i,rect:new createjs.Rectangle(m,l,c,d),regX:this._regX,regY:this._regY}),m+=c+e}l+=d+e}this._numFrames=b}},createjs.SpriteSheet=createjs.promote(a,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.command=null,this._stroke=null,this._strokeStyle=null,this._oldStrokeStyle=null,this._strokeDash=null,this._oldStrokeDash=null,this._strokeIgnoreScale=!1,this._fill=null,this._instructions=[],this._commitIndex=0,this._activeInstructions=[],this._dirty=!1,this._storeIndex=0,this.clear()}var b=a.prototype,c=a;a.getRGB=function(a,b,c,d){return null!=a&&null==c&&(d=b,c=255&a,b=a>>8&255,a=a>>16&255),null==d?"rgb("+a+","+b+","+c+")":"rgba("+a+","+b+","+c+","+d+")"},a.getHSL=function(a,b,c,d){return null==d?"hsl("+a%360+","+b+"%,"+c+"%)":"hsla("+a%360+","+b+"%,"+c+"%,"+d+")"},a.BASE_64={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,a:26,b:27,c:28,d:29,e:30,f:31,g:32,h:33,i:34,j:35,k:36,l:37,m:38,n:39,o:40,p:41,q:42,r:43,s:44,t:45,u:46,v:47,w:48,x:49,y:50,z:51,0:52,1:53,2:54,3:55,4:56,5:57,6:58,7:59,8:60,9:61,"+":62,"/":63},a.STROKE_CAPS_MAP=["butt","round","square"],a.STROKE_JOINTS_MAP=["miter","round","bevel"];var d=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");d.getContext&&(a._ctx=d.getContext("2d"),d.width=d.height=1),b._getInstructions=function(){return this._updateInstructions(),this._instructions},b.getInstructions=createjs.deprecate(b._getInstructions,"Graphics.getInstructions");try{Object.defineProperties(b,{instructions:{get:b._getInstructions}})}catch(e){}b.isEmpty=function(){return!(this._instructions.length||this._activeInstructions.length)},b.draw=function(a,b){this._updateInstructions();for(var c=this._instructions,d=this._storeIndex,e=c.length;e>d;d++)c[d].exec(a,b)},b.drawAsPath=function(a){this._updateInstructions();for(var b,c=this._instructions,d=this._storeIndex,e=c.length;e>d;d++)(b=c[d]).path!==!1&&b.exec(a)},b.moveTo=function(a,b){return this.append(new c.MoveTo(a,b),!0)},b.lineTo=function(a,b){return this.append(new c.LineTo(a,b))},b.arcTo=function(a,b,d,e,f){return this.append(new c.ArcTo(a,b,d,e,f))},b.arc=function(a,b,d,e,f,g){return this.append(new c.Arc(a,b,d,e,f,g))},b.quadraticCurveTo=function(a,b,d,e){return this.append(new c.QuadraticCurveTo(a,b,d,e))},b.bezierCurveTo=function(a,b,d,e,f,g){return this.append(new c.BezierCurveTo(a,b,d,e,f,g))},b.rect=function(a,b,d,e){return this.append(new c.Rect(a,b,d,e))},b.closePath=function(){return this._activeInstructions.length?this.append(new c.ClosePath):this},b.clear=function(){return this._instructions.length=this._activeInstructions.length=this._commitIndex=0,this._strokeStyle=this._oldStrokeStyle=this._stroke=this._fill=this._strokeDash=this._oldStrokeDash=null,this._dirty=this._strokeIgnoreScale=!1,this},b.beginFill=function(a){return this._setFill(a?new c.Fill(a):null)},b.beginLinearGradientFill=function(a,b,d,e,f,g){return this._setFill((new c.Fill).linearGradient(a,b,d,e,f,g))},b.beginRadialGradientFill=function(a,b,d,e,f,g,h,i){return this._setFill((new c.Fill).radialGradient(a,b,d,e,f,g,h,i))},b.beginBitmapFill=function(a,b,d){return this._setFill(new c.Fill(null,d).bitmap(a,b))},b.endFill=function(){return this.beginFill()},b.setStrokeStyle=function(a,b,d,e,f){return this._updateInstructions(!0),this._strokeStyle=this.command=new c.StrokeStyle(a,b,d,e,f),this._stroke&&(this._stroke.ignoreScale=f),this._strokeIgnoreScale=f,this},b.setStrokeDash=function(a,b){return this._updateInstructions(!0),this._strokeDash=this.command=new c.StrokeDash(a,b),this},b.beginStroke=function(a){return this._setStroke(a?new c.Stroke(a):null)},b.beginLinearGradientStroke=function(a,b,d,e,f,g){return this._setStroke((new c.Stroke).linearGradient(a,b,d,e,f,g))},b.beginRadialGradientStroke=function(a,b,d,e,f,g,h,i){return this._setStroke((new c.Stroke).radialGradient(a,b,d,e,f,g,h,i))},b.beginBitmapStroke=function(a,b){return this._setStroke((new c.Stroke).bitmap(a,b))},b.endStroke=function(){return this.beginStroke()},b.curveTo=b.quadraticCurveTo,b.drawRect=b.rect,b.drawRoundRect=function(a,b,c,d,e){return this.drawRoundRectComplex(a,b,c,d,e,e,e,e)},b.drawRoundRectComplex=function(a,b,d,e,f,g,h,i){return this.append(new c.RoundRect(a,b,d,e,f,g,h,i))},b.drawCircle=function(a,b,d){return this.append(new c.Circle(a,b,d))},b.drawEllipse=function(a,b,d,e){return this.append(new c.Ellipse(a,b,d,e))},b.drawPolyStar=function(a,b,d,e,f,g){return this.append(new c.PolyStar(a,b,d,e,f,g))},b.append=function(a,b){return this._activeInstructions.push(a),this.command=a,b||(this._dirty=!0),this},b.decodePath=function(b){for(var c=[this.moveTo,this.lineTo,this.quadraticCurveTo,this.bezierCurveTo,this.closePath],d=[2,2,4,6,0],e=0,f=b.length,g=[],h=0,i=0,j=a.BASE_64;f>e;){var k=b.charAt(e),l=j[k],m=l>>3,n=c[m];if(!n||3&l)throw"bad path data (@"+e+"): "+k;var o=d[m];m||(h=i=0),g.length=0,e++;for(var p=(l>>2&1)+2,q=0;o>q;q++){var r=j[b.charAt(e)],s=r>>5?-1:1;r=(31&r)<<6|j[b.charAt(e+1)],3==p&&(r=r<<6|j[b.charAt(e+2)]),r=s*r/10,q%2?h=r+=h:i=r+=i,g[q]=r,e+=p}n.apply(this,g)}return this},b.store=function(){return this._updateInstructions(!0),this._storeIndex=this._instructions.length,this},b.unstore=function(){return this._storeIndex=0,this},b.clone=function(){var b=new a;return b.command=this.command,b._stroke=this._stroke,b._strokeStyle=this._strokeStyle,b._strokeDash=this._strokeDash,b._strokeIgnoreScale=this._strokeIgnoreScale,b._fill=this._fill,b._instructions=this._instructions.slice(),b._commitIndex=this._commitIndex,b._activeInstructions=this._activeInstructions.slice(),b._dirty=this._dirty,b._storeIndex=this._storeIndex,b},b.toString=function(){return"[Graphics]"},b.mt=b.moveTo,b.lt=b.lineTo,b.at=b.arcTo,b.bt=b.bezierCurveTo,b.qt=b.quadraticCurveTo,b.a=b.arc,b.r=b.rect,b.cp=b.closePath,b.c=b.clear,b.f=b.beginFill,b.lf=b.beginLinearGradientFill,b.rf=b.beginRadialGradientFill,b.bf=b.beginBitmapFill,b.ef=b.endFill,b.ss=b.setStrokeStyle,b.sd=b.setStrokeDash,b.s=b.beginStroke,b.ls=b.beginLinearGradientStroke,b.rs=b.beginRadialGradientStroke,b.bs=b.beginBitmapStroke,b.es=b.endStroke,b.dr=b.drawRect,b.rr=b.drawRoundRect,b.rc=b.drawRoundRectComplex,b.dc=b.drawCircle,b.de=b.drawEllipse,b.dp=b.drawPolyStar,b.p=b.decodePath,b._updateInstructions=function(b){var c=this._instructions,d=this._activeInstructions,e=this._commitIndex;if(this._dirty&&d.length){c.length=e,c.push(a.beginCmd);var f=d.length,g=c.length;c.length=g+f;for(var h=0;f>h;h++)c[h+g]=d[h];this._fill&&c.push(this._fill),this._stroke&&(this._strokeDash!==this._oldStrokeDash&&c.push(this._strokeDash),this._strokeStyle!==this._oldStrokeStyle&&c.push(this._strokeStyle),b&&(this._oldStrokeStyle=this._strokeStyle,this._oldStrokeDash=this._strokeDash),c.push(this._stroke)),this._dirty=!1}b&&(d.length=0,this._commitIndex=c.length)},b._setFill=function(a){return this._updateInstructions(!0),this.command=this._fill=a,this},b._setStroke=function(a){return this._updateInstructions(!0),(this.command=this._stroke=a)&&(a.ignoreScale=this._strokeIgnoreScale),this},(c.LineTo=function(a,b){this.x=a,this.y=b}).prototype.exec=function(a){a.lineTo(this.x,this.y)},(c.MoveTo=function(a,b){this.x=a,this.y=b}).prototype.exec=function(a){a.moveTo(this.x,this.y)},(c.ArcTo=function(a,b,c,d,e){this.x1=a,this.y1=b,this.x2=c,this.y2=d,this.radius=e}).prototype.exec=function(a){a.arcTo(this.x1,this.y1,this.x2,this.y2,this.radius)},(c.Arc=function(a,b,c,d,e,f){this.x=a,this.y=b,this.radius=c,this.startAngle=d,this.endAngle=e,this.anticlockwise=!!f}).prototype.exec=function(a){a.arc(this.x,this.y,this.radius,this.startAngle,this.endAngle,this.anticlockwise)},(c.QuadraticCurveTo=function(a,b,c,d){this.cpx=a,this.cpy=b,this.x=c,this.y=d}).prototype.exec=function(a){a.quadraticCurveTo(this.cpx,this.cpy,this.x,this.y)},(c.BezierCurveTo=function(a,b,c,d,e,f){this.cp1x=a,this.cp1y=b,this.cp2x=c,this.cp2y=d,this.x=e,this.y=f}).prototype.exec=function(a){a.bezierCurveTo(this.cp1x,this.cp1y,this.cp2x,this.cp2y,this.x,this.y)},(c.Rect=function(a,b,c,d){this.x=a,this.y=b,this.w=c,this.h=d}).prototype.exec=function(a){a.rect(this.x,this.y,this.w,this.h)},(c.ClosePath=function(){}).prototype.exec=function(a){a.closePath()},(c.BeginPath=function(){}).prototype.exec=function(a){a.beginPath()},b=(c.Fill=function(a,b){this.style=a,this.matrix=b}).prototype,b.exec=function(a){if(this.style){a.fillStyle=this.style;var b=this.matrix;b&&(a.save(),a.transform(b.a,b.b,b.c,b.d,b.tx,b.ty)),a.fill(),b&&a.restore()}},b.linearGradient=function(b,c,d,e,f,g){for(var h=this.style=a._ctx.createLinearGradient(d,e,f,g),i=0,j=b.length;j>i;i++)h.addColorStop(c[i],b[i]);return h.props={colors:b,ratios:c,x0:d,y0:e,x1:f,y1:g,type:"linear"},this},b.radialGradient=function(b,c,d,e,f,g,h,i){for(var j=this.style=a._ctx.createRadialGradient(d,e,f,g,h,i),k=0,l=b.length;l>k;k++)j.addColorStop(c[k],b[k]);return j.props={colors:b,ratios:c,x0:d,y0:e,r0:f,x1:g,y1:h,r1:i,type:"radial"},this},b.bitmap=function(b,c){if(b.naturalWidth||b.getContext||b.readyState>=2){var d=this.style=a._ctx.createPattern(b,c||"");d.props={image:b,repetition:c,type:"bitmap"}}return this},b.path=!1,b=(c.Stroke=function(a,b){this.style=a,this.ignoreScale=b}).prototype,b.exec=function(a){this.style&&(a.strokeStyle=this.style,this.ignoreScale&&(a.save(),a.setTransform(1,0,0,1,0,0)),a.stroke(),this.ignoreScale&&a.restore())},b.linearGradient=c.Fill.prototype.linearGradient,b.radialGradient=c.Fill.prototype.radialGradient,b.bitmap=c.Fill.prototype.bitmap,b.path=!1,b=(c.StrokeStyle=function(a,b,c,d,e){this.width=a,this.caps=b,this.joints=c,this.miterLimit=d,this.ignoreScale=e}).prototype,b.exec=function(b){b.lineWidth=null==this.width?"1":this.width,b.lineCap=null==this.caps?"butt":isNaN(this.caps)?this.caps:a.STROKE_CAPS_MAP[this.caps],b.lineJoin=null==this.joints?"miter":isNaN(this.joints)?this.joints:a.STROKE_JOINTS_MAP[this.joints],b.miterLimit=null==this.miterLimit?"10":this.miterLimit,b.ignoreScale=null==this.ignoreScale?!1:this.ignoreScale},b.path=!1,(c.StrokeDash=function(a,b){this.segments=a,this.offset=b||0}).prototype.exec=function(a){a.setLineDash&&(a.setLineDash(this.segments||c.StrokeDash.EMPTY_SEGMENTS),a.lineDashOffset=this.offset||0)},c.StrokeDash.EMPTY_SEGMENTS=[],(c.RoundRect=function(a,b,c,d,e,f,g,h){this.x=a,this.y=b,this.w=c,this.h=d,this.radiusTL=e,this.radiusTR=f,this.radiusBR=g,this.radiusBL=h}).prototype.exec=function(a){var b=(j>i?i:j)/2,c=0,d=0,e=0,f=0,g=this.x,h=this.y,i=this.w,j=this.h,k=this.radiusTL,l=this.radiusTR,m=this.radiusBR,n=this.radiusBL;0>k&&(k*=c=-1),k>b&&(k=b),0>l&&(l*=d=-1),l>b&&(l=b),0>m&&(m*=e=-1),m>b&&(m=b),0>n&&(n*=f=-1),n>b&&(n=b),a.moveTo(g+i-l,h),a.arcTo(g+i+l*d,h-l*d,g+i,h+l,l),a.lineTo(g+i,h+j-m),a.arcTo(g+i+m*e,h+j+m*e,g+i-m,h+j,m),a.lineTo(g+n,h+j),a.arcTo(g-n*f,h+j+n*f,g,h+j-n,n),a.lineTo(g,h+k),a.arcTo(g-k*c,h-k*c,g+k,h,k),a.closePath()
},(c.Circle=function(a,b,c){this.x=a,this.y=b,this.radius=c}).prototype.exec=function(a){a.arc(this.x,this.y,this.radius,0,2*Math.PI)},(c.Ellipse=function(a,b,c,d){this.x=a,this.y=b,this.w=c,this.h=d}).prototype.exec=function(a){var b=this.x,c=this.y,d=this.w,e=this.h,f=.5522848,g=d/2*f,h=e/2*f,i=b+d,j=c+e,k=b+d/2,l=c+e/2;a.moveTo(b,l),a.bezierCurveTo(b,l-h,k-g,c,k,c),a.bezierCurveTo(k+g,c,i,l-h,i,l),a.bezierCurveTo(i,l+h,k+g,j,k,j),a.bezierCurveTo(k-g,j,b,l+h,b,l)},(c.PolyStar=function(a,b,c,d,e,f){this.x=a,this.y=b,this.radius=c,this.sides=d,this.pointSize=e,this.angle=f}).prototype.exec=function(a){var b=this.x,c=this.y,d=this.radius,e=(this.angle||0)/180*Math.PI,f=this.sides,g=1-(this.pointSize||0),h=Math.PI/f;a.moveTo(b+Math.cos(e)*d,c+Math.sin(e)*d);for(var i=0;f>i;i++)e+=h,1!=g&&a.lineTo(b+Math.cos(e)*d*g,c+Math.sin(e)*d*g),e+=h,a.lineTo(b+Math.cos(e)*d,c+Math.sin(e)*d);a.closePath()},a.beginCmd=new c.BeginPath,createjs.Graphics=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.EventDispatcher_constructor(),this.alpha=1,this.cacheCanvas=null,this.bitmapCache=null,this.id=createjs.UID.get(),this.mouseEnabled=!0,this.tickEnabled=!0,this.name=null,this.parent=null,this.regX=0,this.regY=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.skewX=0,this.skewY=0,this.shadow=null,this.visible=!0,this.x=0,this.y=0,this.transformMatrix=null,this.compositeOperation=null,this.snapToPixel=!0,this.filters=null,this.mask=null,this.hitArea=null,this.cursor=null,this._props=new createjs.DisplayProps,this._rectangle=new createjs.Rectangle,this._bounds=null,this._webGLRenderStyle=a._StageGL_NONE}var b=createjs.extend(a,createjs.EventDispatcher);a._MOUSE_EVENTS=["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"],a.suppressCrossDomainErrors=!1,a._snapToPixelEnabled=!1,a._StageGL_NONE=0,a._StageGL_SPRITE=1,a._StageGL_BITMAP=2;var c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");c.getContext&&(a._hitTestCanvas=c,a._hitTestContext=c.getContext("2d"),c.width=c.height=1),b._getStage=function(){for(var a=this,b=createjs.Stage;a.parent;)a=a.parent;return a instanceof b?a:null},b.getStage=createjs.deprecate(b._getStage,"DisplayObject.getStage");try{Object.defineProperties(b,{stage:{get:b._getStage},cacheID:{get:function(){return this.bitmapCache&&this.bitmapCache.cacheID},set:function(a){this.bitmapCache&&(this.bitmapCache.cacheID=a)}},scale:{get:function(){return this.scaleX},set:function(a){this.scaleX=this.scaleY=a}}})}catch(d){}b.isVisible=function(){return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY)},b.draw=function(a,b){var c=this.bitmapCache;return c&&!b?c.draw(a):!1},b.updateContext=function(b){var c=this,d=c.mask,e=c._props.matrix;d&&d.graphics&&!d.graphics.isEmpty()&&(d.getMatrix(e),b.transform(e.a,e.b,e.c,e.d,e.tx,e.ty),d.graphics.drawAsPath(b),b.clip(),e.invert(),b.transform(e.a,e.b,e.c,e.d,e.tx,e.ty)),this.getMatrix(e);var f=e.tx,g=e.ty;a._snapToPixelEnabled&&c.snapToPixel&&(f=f+(0>f?-.5:.5)|0,g=g+(0>g?-.5:.5)|0),b.transform(e.a,e.b,e.c,e.d,f,g),b.globalAlpha*=c.alpha,c.compositeOperation&&(b.globalCompositeOperation=c.compositeOperation),c.shadow&&this._applyShadow(b,c.shadow)},b.cache=function(a,b,c,d,e,f){this.bitmapCache||(this.bitmapCache=new createjs.BitmapCache),this.bitmapCache.define(this,a,b,c,d,e,f)},b.updateCache=function(a){if(!this.bitmapCache)throw"cache() must be called before updateCache()";this.bitmapCache.update(a)},b.uncache=function(){this.bitmapCache&&(this.bitmapCache.release(),this.bitmapCache=void 0)},b.getCacheDataURL=function(){return this.bitmapCache?this.bitmapCache.getDataURL():null},b.localToGlobal=function(a,b,c){return this.getConcatenatedMatrix(this._props.matrix).transformPoint(a,b,c||new createjs.Point)},b.globalToLocal=function(a,b,c){return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(a,b,c||new createjs.Point)},b.localToLocal=function(a,b,c,d){return d=this.localToGlobal(a,b,d),c.globalToLocal(d.x,d.y,d)},b.setTransform=function(a,b,c,d,e,f,g,h,i){return this.x=a||0,this.y=b||0,this.scaleX=null==c?1:c,this.scaleY=null==d?1:d,this.rotation=e||0,this.skewX=f||0,this.skewY=g||0,this.regX=h||0,this.regY=i||0,this},b.getMatrix=function(a){var b=this,c=a&&a.identity()||new createjs.Matrix2D;return b.transformMatrix?c.copy(b.transformMatrix):c.appendTransform(b.x,b.y,b.scaleX,b.scaleY,b.rotation,b.skewX,b.skewY,b.regX,b.regY)},b.getConcatenatedMatrix=function(a){for(var b=this,c=this.getMatrix(a);b=b.parent;)c.prependMatrix(b.getMatrix(b._props.matrix));return c},b.getConcatenatedDisplayProps=function(a){a=a?a.identity():new createjs.DisplayProps;var b=this,c=b.getMatrix(a.matrix);do a.prepend(b.visible,b.alpha,b.shadow,b.compositeOperation),b!=this&&c.prependMatrix(b.getMatrix(b._props.matrix));while(b=b.parent);return a},b.hitTest=function(b,c){var d=a._hitTestContext;d.setTransform(1,0,0,1,-b,-c),this.draw(d);var e=this._testHit(d);return d.setTransform(1,0,0,1,0,0),d.clearRect(0,0,2,2),e},b.set=function(a){for(var b in a)this[b]=a[b];return this},b.getBounds=function(){if(this._bounds)return this._rectangle.copy(this._bounds);var a=this.cacheCanvas;if(a){var b=this._cacheScale;return this._rectangle.setValues(this._cacheOffsetX,this._cacheOffsetY,a.width/b,a.height/b)}return null},b.getTransformedBounds=function(){return this._getBounds()},b.setBounds=function(a,b,c,d){return null==a?void(this._bounds=a):void(this._bounds=(this._bounds||new createjs.Rectangle).setValues(a,b,c,d))},b.clone=function(){return this._cloneProps(new a)},b.toString=function(){return"[DisplayObject (name="+this.name+")]"},b._updateState=null,b._cloneProps=function(a){return a.alpha=this.alpha,a.mouseEnabled=this.mouseEnabled,a.tickEnabled=this.tickEnabled,a.name=this.name,a.regX=this.regX,a.regY=this.regY,a.rotation=this.rotation,a.scaleX=this.scaleX,a.scaleY=this.scaleY,a.shadow=this.shadow,a.skewX=this.skewX,a.skewY=this.skewY,a.visible=this.visible,a.x=this.x,a.y=this.y,a.compositeOperation=this.compositeOperation,a.snapToPixel=this.snapToPixel,a.filters=null==this.filters?null:this.filters.slice(0),a.mask=this.mask,a.hitArea=this.hitArea,a.cursor=this.cursor,a._bounds=this._bounds,a},b._applyShadow=function(a,b){b=b||Shadow.identity,a.shadowColor=b.color,a.shadowOffsetX=b.offsetX,a.shadowOffsetY=b.offsetY,a.shadowBlur=b.blur},b._tick=function(a){var b=this._listeners;b&&b.tick&&(a.target=null,a.propagationStopped=a.immediatePropagationStopped=!1,this.dispatchEvent(a))},b._testHit=function(b){try{var c=b.getImageData(0,0,1,1).data[3]>1}catch(d){if(!a.suppressCrossDomainErrors)throw"An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images."}return c},b._getBounds=function(a,b){return this._transformBounds(this.getBounds(),a,b)},b._transformBounds=function(a,b,c){if(!a)return a;var d=a.x,e=a.y,f=a.width,g=a.height,h=this._props.matrix;h=c?h.identity():this.getMatrix(h),(d||e)&&h.appendTransform(0,0,1,1,0,0,0,-d,-e),b&&h.prependMatrix(b);var i=f*h.a,j=f*h.b,k=g*h.c,l=g*h.d,m=h.tx,n=h.ty,o=m,p=m,q=n,r=n;return(d=i+m)<o?o=d:d>p&&(p=d),(d=i+k+m)<o?o=d:d>p&&(p=d),(d=k+m)<o?o=d:d>p&&(p=d),(e=j+n)<q?q=e:e>r&&(r=e),(e=j+l+n)<q?q=e:e>r&&(r=e),(e=l+n)<q?q=e:e>r&&(r=e),a.setValues(o,q,p-o,r-q)},b._hasMouseEventListener=function(){for(var b=a._MOUSE_EVENTS,c=0,d=b.length;d>c;c++)if(this.hasEventListener(b[c]))return!0;return!!this.cursor},createjs.DisplayObject=createjs.promote(a,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.DisplayObject_constructor(),this.children=[],this.mouseChildren=!0,this.tickChildren=!0}var b=createjs.extend(a,createjs.DisplayObject);b._getNumChildren=function(){return this.children.length},b.getNumChildren=createjs.deprecate(b._getNumChildren,"Container.getNumChildren");try{Object.defineProperties(b,{numChildren:{get:b._getNumChildren}})}catch(c){}b.initialize=a,b.isVisible=function(){var a=this.cacheCanvas||this.children.length;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;for(var c=this.children.slice(),d=0,e=c.length;e>d;d++){var f=c[d];f.isVisible()&&(a.save(),f.updateContext(a),f.draw(a),a.restore())}return!0},b.addChild=function(a){if(null==a)return a;var b=arguments.length;if(b>1){for(var c=0;b>c;c++)this.addChild(arguments[c]);return arguments[b-1]}var d=a.parent,e=d===this;return d&&d._removeChildAt(createjs.indexOf(d.children,a),e),a.parent=this,this.children.push(a),e||a.dispatchEvent("added"),a},b.addChildAt=function(a,b){var c=arguments.length,d=arguments[c-1];if(0>d||d>this.children.length)return arguments[c-2];if(c>2){for(var e=0;c-1>e;e++)this.addChildAt(arguments[e],d+e);return arguments[c-2]}var f=a.parent,g=f===this;return f&&f._removeChildAt(createjs.indexOf(f.children,a),g),a.parent=this,this.children.splice(b,0,a),g||a.dispatchEvent("added"),a},b.removeChild=function(a){var b=arguments.length;if(b>1){for(var c=!0,d=0;b>d;d++)c=c&&this.removeChild(arguments[d]);return c}return this._removeChildAt(createjs.indexOf(this.children,a))},b.removeChildAt=function(a){var b=arguments.length;if(b>1){for(var c=[],d=0;b>d;d++)c[d]=arguments[d];c.sort(function(a,b){return b-a});for(var e=!0,d=0;b>d;d++)e=e&&this._removeChildAt(c[d]);return e}return this._removeChildAt(a)},b.removeAllChildren=function(){for(var a=this.children;a.length;)this._removeChildAt(0)},b.getChildAt=function(a){return this.children[a]},b.getChildByName=function(a){for(var b=this.children,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null},b.sortChildren=function(a){this.children.sort(a)},b.getChildIndex=function(a){return createjs.indexOf(this.children,a)},b.swapChildrenAt=function(a,b){var c=this.children,d=c[a],e=c[b];d&&e&&(c[a]=e,c[b]=d)},b.swapChildren=function(a,b){for(var c,d,e=this.children,f=0,g=e.length;g>f&&(e[f]==a&&(c=f),e[f]==b&&(d=f),null==c||null==d);f++);f!=g&&(e[c]=b,e[d]=a)},b.setChildIndex=function(a,b){var c=this.children,d=c.length;if(!(a.parent!=this||0>b||b>=d)){for(var e=0;d>e&&c[e]!=a;e++);e!=d&&e!=b&&(c.splice(e,1),c.splice(b,0,a))}},b.contains=function(a){for(;a;){if(a==this)return!0;a=a.parent}return!1},b.hitTest=function(a,b){return null!=this.getObjectUnderPoint(a,b)},b.getObjectsUnderPoint=function(a,b,c){var d=[],e=this.localToGlobal(a,b);return this._getObjectsUnderPoint(e.x,e.y,d,c>0,1==c),d},b.getObjectUnderPoint=function(a,b,c){var d=this.localToGlobal(a,b);return this._getObjectsUnderPoint(d.x,d.y,null,c>0,1==c)},b.getBounds=function(){return this._getBounds(null,!0)},b.getTransformedBounds=function(){return this._getBounds()},b.clone=function(b){var c=this._cloneProps(new a);return b&&this._cloneChildren(c),c},b.toString=function(){return"[Container (name="+this.name+")]"},b._tick=function(a){if(this.tickChildren)for(var b=this.children.length-1;b>=0;b--){var c=this.children[b];c.tickEnabled&&c._tick&&c._tick(a)}this.DisplayObject__tick(a)},b._cloneChildren=function(a){a.children.length&&a.removeAllChildren();for(var b=a.children,c=0,d=this.children.length;d>c;c++){var e=this.children[c].clone(!0);e.parent=a,b.push(e)}},b._removeChildAt=function(a,b){if(0>a||a>this.children.length-1)return!1;var c=this.children[a];return c&&(c.parent=null),this.children.splice(a,1),b||c.dispatchEvent("removed"),!0},b._getObjectsUnderPoint=function(b,c,d,e,f,g){if(g=g||0,!g&&!this._testMask(this,b,c))return null;var h,i=createjs.DisplayObject._hitTestContext;f=f||e&&this._hasMouseEventListener();for(var j=this.children,k=j.length,l=k-1;l>=0;l--){var m=j[l],n=m.hitArea;if(m.visible&&(n||m.isVisible())&&(!e||m.mouseEnabled)&&(n||this._testMask(m,b,c)))if(!n&&m instanceof a){var o=m._getObjectsUnderPoint(b,c,d,e,f,g+1);if(!d&&o)return e&&!this.mouseChildren?this:o}else{if(e&&!f&&!m._hasMouseEventListener())continue;var p=m.getConcatenatedDisplayProps(m._props);if(h=p.matrix,n&&(h.appendMatrix(n.getMatrix(n._props.matrix)),p.alpha=n.alpha),i.globalAlpha=p.alpha,i.setTransform(h.a,h.b,h.c,h.d,h.tx-b,h.ty-c),(n||m).draw(i),!this._testHit(i))continue;if(i.setTransform(1,0,0,1,0,0),i.clearRect(0,0,2,2),!d)return e&&!this.mouseChildren?this:m;d.push(m)}}return null},b._testMask=function(a,b,c){var d=a.mask;if(!d||!d.graphics||d.graphics.isEmpty())return!0;var e=this._props.matrix,f=a.parent;e=f?f.getConcatenatedMatrix(e):e.identity(),e=d.getMatrix(d._props.matrix).prependMatrix(e);var g=createjs.DisplayObject._hitTestContext;return g.setTransform(e.a,e.b,e.c,e.d,e.tx-b,e.ty-c),d.graphics.drawAsPath(g),g.fillStyle="#000",g.fill(),this._testHit(g)?(g.setTransform(1,0,0,1,0,0),g.clearRect(0,0,2,2),!0):!1},b._getBounds=function(a,b){var c=this.DisplayObject_getBounds();if(c)return this._transformBounds(c,a,b);var d=this._props.matrix;d=b?d.identity():this.getMatrix(d),a&&d.prependMatrix(a);for(var e=this.children.length,f=null,g=0;e>g;g++){var h=this.children[g];h.visible&&(c=h._getBounds(d))&&(f?f.extend(c.x,c.y,c.width,c.height):f=c.clone())}return f},createjs.Container=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.Container_constructor(),this.autoClear=!0,this.canvas="string"==typeof a?document.getElementById(a):a,this.mouseX=0,this.mouseY=0,this.drawRect=null,this.snapToPixelEnabled=!1,this.mouseInBounds=!1,this.tickOnUpdate=!0,this.mouseMoveOutside=!1,this.preventSelection=!0,this._pointerData={},this._pointerCount=0,this._primaryPointerID=null,this._mouseOverIntervalID=null,this._nextStage=null,this._prevStage=null,this.enableDOMEvents(!0)}var b=createjs.extend(a,createjs.Container);b._get_nextStage=function(){return this._nextStage},b._set_nextStage=function(a){this._nextStage&&(this._nextStage._prevStage=null),a&&(a._prevStage=this),this._nextStage=a};try{Object.defineProperties(b,{nextStage:{get:b._get_nextStage,set:b._set_nextStage}})}catch(c){}b.update=function(a){if(this.canvas&&(this.tickOnUpdate&&this.tick(a),this.dispatchEvent("drawstart",!1,!0)!==!1)){createjs.DisplayObject._snapToPixelEnabled=this.snapToPixelEnabled;var b=this.drawRect,c=this.canvas.getContext("2d");c.setTransform(1,0,0,1,0,0),this.autoClear&&(b?c.clearRect(b.x,b.y,b.width,b.height):c.clearRect(0,0,this.canvas.width+1,this.canvas.height+1)),c.save(),this.drawRect&&(c.beginPath(),c.rect(b.x,b.y,b.width,b.height),c.clip()),this.updateContext(c),this.draw(c,!1),c.restore(),this.dispatchEvent("drawend")}},b.tick=function(a){if(this.tickEnabled&&this.dispatchEvent("tickstart",!1,!0)!==!1){var b=new createjs.Event("tick");if(a)for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);this._tick(b),this.dispatchEvent("tickend")}},b.handleEvent=function(a){"tick"==a.type&&this.update(a)},b.clear=function(){if(this.canvas){var a=this.canvas.getContext("2d");a.setTransform(1,0,0,1,0,0),a.clearRect(0,0,this.canvas.width+1,this.canvas.height+1)}},b.toDataURL=function(a,b){var c,d=this.canvas.getContext("2d"),e=this.canvas.width,f=this.canvas.height;if(a){c=d.getImageData(0,0,e,f);var g=d.globalCompositeOperation;d.globalCompositeOperation="destination-over",d.fillStyle=a,d.fillRect(0,0,e,f)}var h=this.canvas.toDataURL(b||"image/png");return a&&(d.putImageData(c,0,0),d.globalCompositeOperation=g),h},b.enableMouseOver=function(a){if(this._mouseOverIntervalID&&(clearInterval(this._mouseOverIntervalID),this._mouseOverIntervalID=null,0==a&&this._testMouseOver(!0)),null==a)a=20;else if(0>=a)return;var b=this;this._mouseOverIntervalID=setInterval(function(){b._testMouseOver()},1e3/Math.min(50,a))},b.enableDOMEvents=function(a){null==a&&(a=!0);var b,c,d=this._eventListeners;if(!a&&d){for(b in d)c=d[b],c.t.removeEventListener(b,c.f,!1);this._eventListeners=null}else if(a&&!d&&this.canvas){var e=window.addEventListener?window:document,f=this;d=this._eventListeners={},d.mouseup={t:e,f:function(a){f._handleMouseUp(a)}},d.mousemove={t:e,f:function(a){f._handleMouseMove(a)}},d.dblclick={t:this.canvas,f:function(a){f._handleDoubleClick(a)}},d.mousedown={t:this.canvas,f:function(a){f._handleMouseDown(a)}};for(b in d)c=d[b],c.t.addEventListener(b,c.f,!1)}},b.clone=function(){throw"Stage cannot be cloned."},b.toString=function(){return"[Stage (name="+this.name+")]"},b._getElementRect=function(a){var b;try{b=a.getBoundingClientRect()}catch(c){b={top:a.offsetTop,left:a.offsetLeft,width:a.offsetWidth,height:a.offsetHeight}}var d=(window.pageXOffset||document.scrollLeft||0)-(document.clientLeft||document.body.clientLeft||0),e=(window.pageYOffset||document.scrollTop||0)-(document.clientTop||document.body.clientTop||0),f=window.getComputedStyle?getComputedStyle(a,null):a.currentStyle,g=parseInt(f.paddingLeft)+parseInt(f.borderLeftWidth),h=parseInt(f.paddingTop)+parseInt(f.borderTopWidth),i=parseInt(f.paddingRight)+parseInt(f.borderRightWidth),j=parseInt(f.paddingBottom)+parseInt(f.borderBottomWidth);return{left:b.left+d+g,right:b.right+d-i,top:b.top+e+h,bottom:b.bottom+e-j}},b._getPointerData=function(a){var b=this._pointerData[a];return b||(b=this._pointerData[a]={x:0,y:0}),b},b._handleMouseMove=function(a){a||(a=window.event),this._handlePointerMove(-1,a,a.pageX,a.pageY)},b._handlePointerMove=function(a,b,c,d,e){if((!this._prevStage||void 0!==e)&&this.canvas){var f=this._nextStage,g=this._getPointerData(a),h=g.inBounds;this._updatePointerPosition(a,b,c,d),(h||g.inBounds||this.mouseMoveOutside)&&(-1===a&&g.inBounds==!h&&this._dispatchMouseEvent(this,h?"mouseleave":"mouseenter",!1,a,g,b),this._dispatchMouseEvent(this,"stagemousemove",!1,a,g,b),this._dispatchMouseEvent(g.target,"pressmove",!0,a,g,b)),f&&f._handlePointerMove(a,b,c,d,null)}},b._updatePointerPosition=function(a,b,c,d){var e=this._getElementRect(this.canvas);c-=e.left,d-=e.top;var f=this.canvas.width,g=this.canvas.height;c/=(e.right-e.left)/f,d/=(e.bottom-e.top)/g;var h=this._getPointerData(a);(h.inBounds=c>=0&&d>=0&&f-1>=c&&g-1>=d)?(h.x=c,h.y=d):this.mouseMoveOutside&&(h.x=0>c?0:c>f-1?f-1:c,h.y=0>d?0:d>g-1?g-1:d),h.posEvtObj=b,h.rawX=c,h.rawY=d,(a===this._primaryPointerID||-1===a)&&(this.mouseX=h.x,this.mouseY=h.y,this.mouseInBounds=h.inBounds)},b._handleMouseUp=function(a){this._handlePointerUp(-1,a,!1)},b._handlePointerUp=function(a,b,c,d){var e=this._nextStage,f=this._getPointerData(a);if(!this._prevStage||void 0!==d){var g=null,h=f.target;d||!h&&!e||(g=this._getObjectsUnderPoint(f.x,f.y,null,!0)),f.down&&(this._dispatchMouseEvent(this,"stagemouseup",!1,a,f,b,g),f.down=!1),g==h&&this._dispatchMouseEvent(h,"click",!0,a,f,b),this._dispatchMouseEvent(h,"pressup",!0,a,f,b),c?(a==this._primaryPointerID&&(this._primaryPointerID=null),delete this._pointerData[a]):f.target=null,e&&e._handlePointerUp(a,b,c,d||g&&this)}},b._handleMouseDown=function(a){this._handlePointerDown(-1,a,a.pageX,a.pageY)},b._handlePointerDown=function(a,b,c,d,e){this.preventSelection&&b.preventDefault(),(null==this._primaryPointerID||-1===a)&&(this._primaryPointerID=a),null!=d&&this._updatePointerPosition(a,b,c,d);var f=null,g=this._nextStage,h=this._getPointerData(a);e||(f=h.target=this._getObjectsUnderPoint(h.x,h.y,null,!0)),h.inBounds&&(this._dispatchMouseEvent(this,"stagemousedown",!1,a,h,b,f),h.down=!0),this._dispatchMouseEvent(f,"mousedown",!0,a,h,b),g&&g._handlePointerDown(a,b,c,d,e||f&&this)},b._testMouseOver=function(a,b,c){if(!this._prevStage||void 0!==b){var d=this._nextStage;if(!this._mouseOverIntervalID)return void(d&&d._testMouseOver(a,b,c));var e=this._getPointerData(-1);if(e&&(a||this.mouseX!=this._mouseOverX||this.mouseY!=this._mouseOverY||!this.mouseInBounds)){var f,g,h,i=e.posEvtObj,j=c||i&&i.target==this.canvas,k=null,l=-1,m="";!b&&(a||this.mouseInBounds&&j)&&(k=this._getObjectsUnderPoint(this.mouseX,this.mouseY,null,!0),this._mouseOverX=this.mouseX,this._mouseOverY=this.mouseY);var n=this._mouseOverTarget||[],o=n[n.length-1],p=this._mouseOverTarget=[];for(f=k;f;)p.unshift(f),m||(m=f.cursor),f=f.parent;for(this.canvas.style.cursor=m,!b&&c&&(c.canvas.style.cursor=m),g=0,h=p.length;h>g&&p[g]==n[g];g++)l=g;for(o!=k&&this._dispatchMouseEvent(o,"mouseout",!0,-1,e,i,k),g=n.length-1;g>l;g--)this._dispatchMouseEvent(n[g],"rollout",!1,-1,e,i,k);for(g=p.length-1;g>l;g--)this._dispatchMouseEvent(p[g],"rollover",!1,-1,e,i,o);o!=k&&this._dispatchMouseEvent(k,"mouseover",!0,-1,e,i,o),d&&d._testMouseOver(a,b||k&&this,c||j&&this)}}},b._handleDoubleClick=function(a,b){var c=null,d=this._nextStage,e=this._getPointerData(-1);b||(c=this._getObjectsUnderPoint(e.x,e.y,null,!0),this._dispatchMouseEvent(c,"dblclick",!0,-1,e,a)),d&&d._handleDoubleClick(a,b||c&&this)},b._dispatchMouseEvent=function(a,b,c,d,e,f,g){if(a&&(c||a.hasEventListener(b))){var h=new createjs.MouseEvent(b,c,!1,e.x,e.y,f,d,d===this._primaryPointerID||-1===d,e.rawX,e.rawY,g);a.dispatchEvent(h)}},createjs.Stage=createjs.promote(a,"Container")}(),this.createjs=this.createjs||{},function(){"use strict";function a(b,c){if(this.Stage_constructor(b),void 0!==c){if("object"!=typeof c)throw"Invalid options object";var d=c.premultiply,e=c.transparent,f=c.antialias,g=c.preserveBuffer,h=c.autoPurge}this.vocalDebug=!1,this._preserveBuffer=g||!1,this._antialias=f||!1,this._transparent=e||!1,this._premultiply=d||!1,this._autoPurge=void 0,this.autoPurge=h,this._viewportWidth=0,this._viewportHeight=0,this._projectionMatrix=null,this._webGLContext=null,this._clearColor={r:.5,g:.5,b:.5,a:0},this._maxCardsPerBatch=a.DEFAULT_MAX_BATCH_SIZE,this._activeShader=null,this._vertices=null,this._vertexPositionBuffer=null,this._uvs=null,this._uvPositionBuffer=null,this._indices=null,this._textureIndexBuffer=null,this._alphas=null,this._alphaBuffer=null,this._textureDictionary=[],this._textureIDs={},this._batchTextures=[],this._baseTextures=[],this._batchTextureCount=8,this._lastTextureInsert=-1,this._batchID=0,this._drawID=0,this._slotBlacklist=[],this._isDrawing=0,this._lastTrackedCanvas=0,this.isCacheControlled=!1,this._cacheContainer=new createjs.Container,this._initializeWebGL()}var b=createjs.extend(a,createjs.Stage);a.buildUVRects=function(a,b,c){if(!a||!a._frames)return null;void 0===b&&(b=-1),void 0===c&&(c=!1);for(var d=-1!=b&&c?b:0,e=-1!=b&&c?b+1:a._frames.length,f=d;e>f;f++){var g=a._frames[f];if(!(g.uvRect||g.image.width<=0||g.image.height<=0)){var h=g.rect;g.uvRect={t:h.y/g.image.height,l:h.x/g.image.width,b:(h.y+h.height)/g.image.height,r:(h.x+h.width)/g.image.width}}}return a._frames[-1!=b?b:0].uvRect||{t:0,l:0,b:1,r:1}},a.isWebGLActive=function(a){return a&&a instanceof WebGLRenderingContext&&"undefined"!=typeof WebGLRenderingContext},a.VERTEX_PROPERTY_COUNT=6,a.INDICIES_PER_CARD=6,a.DEFAULT_MAX_BATCH_SIZE=1e4,a.WEBGL_MAX_INDEX_NUM=Math.pow(2,16),a.UV_RECT={t:0,l:0,b:1,r:1};try{a.COVER_VERT=new Float32Array([-1,1,1,1,-1,-1,1,1,1,-1,-1,-1]),a.COVER_UV=new Float32Array([0,0,1,0,0,1,1,0,1,1,0,1]),a.COVER_UV_FLIP=new Float32Array([0,1,1,1,0,0,1,1,1,0,0,0])}catch(c){}a.REGULAR_VARYING_HEADER="precision mediump float;varying vec2 vTextureCoord;varying lowp float indexPicker;varying lowp float alphaValue;",a.REGULAR_VERTEX_HEADER=a.REGULAR_VARYING_HEADER+"attribute vec2 vertexPosition;attribute vec2 uvPosition;attribute lowp float textureIndex;attribute lowp float objectAlpha;uniform mat4 pMatrix;",a.REGULAR_FRAGMENT_HEADER=a.REGULAR_VARYING_HEADER+"uniform sampler2D uSampler[{{count}}];",a.REGULAR_VERTEX_BODY="void main(void) {gl_Position = vec4((vertexPosition.x * pMatrix[0][0]) + pMatrix[3][0],(vertexPosition.y * pMatrix[1][1]) + pMatrix[3][1],pMatrix[3][2],1.0);alphaValue = objectAlpha;indexPicker = textureIndex;vTextureCoord = uvPosition;}",a.REGULAR_FRAGMENT_BODY="void main(void) {vec4 color = vec4(1.0, 0.0, 0.0, 1.0);if (indexPicker <= 0.5) {color = texture2D(uSampler[0], vTextureCoord);{{alternates}}}{{fragColor}}}",a.REGULAR_FRAG_COLOR_NORMAL="gl_FragColor = vec4(color.rgb, color.a * alphaValue);",a.REGULAR_FRAG_COLOR_PREMULTIPLY="if(color.a > 0.0035) {gl_FragColor = vec4(color.rgb/color.a, color.a * alphaValue);} else {gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);}",a.PARTICLE_VERTEX_BODY=a.REGULAR_VERTEX_BODY,a.PARTICLE_FRAGMENT_BODY=a.REGULAR_FRAGMENT_BODY,a.COVER_VARYING_HEADER="precision mediump float;varying highp vec2 vRenderCoord;varying highp vec2 vTextureCoord;",a.COVER_VERTEX_HEADER=a.COVER_VARYING_HEADER+"attribute vec2 vertexPosition;attribute vec2 uvPosition;uniform float uUpright;",a.COVER_FRAGMENT_HEADER=a.COVER_VARYING_HEADER+"uniform sampler2D uSampler;",a.COVER_VERTEX_BODY="void main(void) {gl_Position = vec4(vertexPosition.x, vertexPosition.y, 0.0, 1.0);vRenderCoord = uvPosition;vTextureCoord = vec2(uvPosition.x, abs(uUpright - uvPosition.y));}",a.COVER_FRAGMENT_BODY="void main(void) {vec4 color = texture2D(uSampler, vRenderCoord);gl_FragColor = color;}",b._get_isWebGL=function(){return!!this._webGLContext},b._set_autoPurge=function(a){a=isNaN(a)?1200:a,-1!=a&&(a=10>a?10:a),this._autoPurge=a},b._get_autoPurge=function(){return Number(this._autoPurge)};try{Object.defineProperties(b,{isWebGL:{get:b._get_isWebGL},autoPurge:{get:b._get_autoPurge,set:b._set_autoPurge}})}catch(c){}b._initializeWebGL=function(){if(this.canvas){if(!this._webGLContext||this._webGLContext.canvas!==this.canvas){var a={depth:!1,alpha:this._transparent,stencil:!0,antialias:this._antialias,premultipliedAlpha:this._premultiply,preserveDrawingBuffer:this._preserveBuffer},b=this._webGLContext=this._fetchWebGLContext(this.canvas,a);if(!b)return null;this.updateSimultaneousTextureCount(b.getParameter(b.MAX_TEXTURE_IMAGE_UNITS)),this._maxTextureSlots=b.getParameter(b.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this._createBuffers(b),this._initTextures(b),b.disable(b.DEPTH_TEST),b.enable(b.BLEND),b.blendFuncSeparate(b.SRC_ALPHA,b.ONE_MINUS_SRC_ALPHA,b.ONE,b.ONE_MINUS_SRC_ALPHA),b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this._premultiply),this._webGLContext.clearColor(this._clearColor.r,this._clearColor.g,this._clearColor.b,this._clearColor.a),this.updateViewport(this._viewportWidth||this.canvas.width,this._viewportHeight||this.canvas.height)}}else this._webGLContext=null;return this._webGLContext},b.update=function(a){if(this.canvas){if(this.tickOnUpdate&&this.tick(a),this.dispatchEvent("drawstart"),this.autoClear&&this.clear(),this._webGLContext)this._batchDraw(this,this._webGLContext),-1==this._autoPurge||this._drawID%(this._autoPurge/2|0)||this.purgeTextures(this._autoPurge);else{var b=this.canvas.getContext("2d");b.save(),this.updateContext(b),this.draw(b,!1),b.restore()}this.dispatchEvent("drawend")}},b.clear=function(){if(this.canvas)if(a.isWebGLActive(this._webGLContext)){var b=this._webGLContext,c=this._clearColor,d=this._transparent?c.a:1;this._webGLContext.clearColor(c.r*d,c.g*d,c.b*d,d),b.clear(b.COLOR_BUFFER_BIT),this._webGLContext.clearColor(c.r,c.g,c.b,c.a)}else this.Stage_clear()},b.draw=function(b,c){if(b===this._webGLContext&&a.isWebGLActive(this._webGLContext)){var d=this._webGLContext;return this._batchDraw(this,d,c),!0}return this.Stage_draw(b,c)},b.cacheDraw=function(b,c,d){if(a.isWebGLActive(this._webGLContext)){var e=this._webGLContext;return this._cacheDraw(e,b,c,d),!0}return!1},b.protectTextureSlot=function(a,b){if(a>this._maxTextureSlots||0>a)throw"Slot outside of acceptable range";this._slotBlacklist[a]=!!b},b.getTargetRenderTexture=function(a,b,c){var d,e=!1,f=this._webGLContext;if(void 0!==a.__lastRT&&a.__lastRT===a.__rtA&&(e=!0),e?(void 0===a.__rtB?a.__rtB=this.getRenderBufferTexture(b,c):((b!=a.__rtB._width||c!=a.__rtB._height)&&this.resizeTexture(a.__rtB,b,c),this.setTextureParams(f)),d=a.__rtB):(void 0===a.__rtA?a.__rtA=this.getRenderBufferTexture(b,c):((b!=a.__rtA._width||c!=a.__rtA._height)&&this.resizeTexture(a.__rtA,b,c),this.setTextureParams(f)),d=a.__rtA),!d)throw"Problems creating render textures, known causes include using too much VRAM by not releasing WebGL texture instances";return a.__lastRT=d,d},b.releaseTexture=function(a){var b,c;if(a){if(a.children)for(b=0,c=a.children.length;c>b;b++)this.releaseTexture(a.children[b]);a.cacheCanvas&&a.uncache();var d=void 0;if(void 0!==a._storeID){if(a===this._textureDictionary[a._storeID])return this._killTextureObject(a),void(a._storeID=void 0);d=a}else if(2===a._webGLRenderStyle)d=a.image;else if(1===a._webGLRenderStyle){for(b=0,c=a.spriteSheet._images.length;c>b;b++)this.releaseTexture(a.spriteSheet._images[b]);return}if(void 0===d)return void(this.vocalDebug&&console.log("No associated texture found on release"));this._killTextureObject(this._textureDictionary[d._storeID]),d._storeID=void 0}},b.purgeTextures=function(a){void 0==a&&(a=100);for(var b=this._textureDictionary,c=b.length,d=0;c>d;d++){var e=b[d];e&&e._drawID+a<=this._drawID&&this._killTextureObject(e)}},b.updateSimultaneousTextureCount=function(a){var b=this._webGLContext,c=!1;for((1>a||isNaN(a))&&(a=1),this._batchTextureCount=a;!c;)try{this._activeShader=this._fetchShaderProgram(b),c=!0}catch(d){if(1==this._batchTextureCount)throw"Cannot compile shader "+d;this._batchTextureCount-=4,this._batchTextureCount<1&&(this._batchTextureCount=1),this.vocalDebug&&console.log("Reducing desired texture count due to errors: "+this._batchTextureCount)}},b.updateViewport=function(a,b){this._viewportWidth=0|a,this._viewportHeight=0|b;var c=this._webGLContext;c&&(c.viewport(0,0,this._viewportWidth,this._viewportHeight),this._projectionMatrix=new Float32Array([2/this._viewportWidth,0,0,0,0,-2/this._viewportHeight,1,0,0,0,1,0,-1,1,.1,0]),this._projectionMatrixFlip=new Float32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),this._projectionMatrixFlip.set(this._projectionMatrix),this._projectionMatrixFlip[5]*=-1,this._projectionMatrixFlip[13]*=-1)},b.getFilterShader=function(a){a||(a=this);var b=this._webGLContext,c=this._activeShader;if(a._builtShader)c=a._builtShader,a.shaderParamSetup&&(b.useProgram(c),a.shaderParamSetup(b,this,c));else try{c=this._fetchShaderProgram(b,"filter",a.VTX_SHADER_BODY,a.FRAG_SHADER_BODY,a.shaderParamSetup&&a.shaderParamSetup.bind(a)),a._builtShader=c,c._name=a.toString()}catch(d){console&&console.log("SHADER SWITCH FAILURE",d)}return c},b.getBaseTexture=function(a,b){var c=Math.ceil(a>0?a:1)||1,d=Math.ceil(b>0?b:1)||1,e=this._webGLContext,f=e.createTexture();return this.resizeTexture(f,c,d),this.setTextureParams(e,!1),f},b.resizeTexture=function(a,b,c){var d=this._webGLContext;d.bindTexture(d.TEXTURE_2D,a),d.texImage2D(d.TEXTURE_2D,0,d.RGBA,b,c,0,d.RGBA,d.UNSIGNED_BYTE,null),a.width=b,a.height=c},b.getRenderBufferTexture=function(a,b){var c=this._webGLContext,d=this.getBaseTexture(a,b);if(!d)return null;var e=c.createFramebuffer();return e?(d.width=a,d.height=b,c.bindFramebuffer(c.FRAMEBUFFER,e),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,d,0),e._renderTexture=d,d._frameBuffer=e,d._storeID=this._textureDictionary.length,this._textureDictionary[d._storeID]=d,c.bindFramebuffer(c.FRAMEBUFFER,null),d):null},b.setTextureParams=function(a,b){b&&this._antialias?(a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR)):(a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST)),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE)},b.setClearColor=function(a){var b,c,d,e,f;"string"==typeof a?0==a.indexOf("#")?(4==a.length&&(a="#"+a.charAt(1)+a.charAt(1)+a.charAt(2)+a.charAt(2)+a.charAt(3)+a.charAt(3)),b=Number("0x"+a.slice(1,3))/255,c=Number("0x"+a.slice(3,5))/255,d=Number("0x"+a.slice(5,7))/255,e=Number("0x"+a.slice(7,9))/255):0==a.indexOf("rgba(")&&(f=a.slice(5,-1).split(","),b=Number(f[0])/255,c=Number(f[1])/255,d=Number(f[2])/255,e=Number(f[3])):(b=((4278190080&a)>>>24)/255,c=((16711680&a)>>>16)/255,d=((65280&a)>>>8)/255,e=(255&a)/255),this._clearColor.r=b||0,this._clearColor.g=c||0,this._clearColor.b=d||0,this._clearColor.a=e||0,this._webGLContext&&this._webGLContext.clearColor(this._clearColor.r,this._clearColor.g,this._clearColor.b,this._clearColor.a)},b.toString=function(){return"[StageGL (name="+this.name+")]"
},b._fetchWebGLContext=function(a,b){var c;try{c=a.getContext("webgl",b)||a.getContext("experimental-webgl",b)}catch(d){}if(c)c.viewportWidth=a.width,c.viewportHeight=a.height;else{var e="Could not initialize WebGL";console.error?console.error(e):console.log(e)}return c},b._fetchShaderProgram=function(b,c,d,e,f){b.useProgram(null);var g,h;switch(c){case"filter":h=a.COVER_VERTEX_HEADER+(d||a.COVER_VERTEX_BODY),g=a.COVER_FRAGMENT_HEADER+(e||a.COVER_FRAGMENT_BODY);break;case"particle":h=a.REGULAR_VERTEX_HEADER+a.PARTICLE_VERTEX_BODY,g=a.REGULAR_FRAGMENT_HEADER+a.PARTICLE_FRAGMENT_BODY;break;case"override":h=a.REGULAR_VERTEX_HEADER+(d||a.REGULAR_VERTEX_BODY),g=a.REGULAR_FRAGMENT_HEADER+(e||a.REGULAR_FRAGMENT_BODY);break;case"regular":default:h=a.REGULAR_VERTEX_HEADER+a.REGULAR_VERTEX_BODY,g=a.REGULAR_FRAGMENT_HEADER+a.REGULAR_FRAGMENT_BODY}var i=this._createShader(b,b.VERTEX_SHADER,h),j=this._createShader(b,b.FRAGMENT_SHADER,g),k=b.createProgram();if(b.attachShader(k,i),b.attachShader(k,j),b.linkProgram(k),k._type=c,!b.getProgramParameter(k,b.LINK_STATUS))throw b.useProgram(this._activeShader),b.getProgramInfoLog(k);switch(b.useProgram(k),c){case"filter":k.vertexPositionAttribute=b.getAttribLocation(k,"vertexPosition"),b.enableVertexAttribArray(k.vertexPositionAttribute),k.uvPositionAttribute=b.getAttribLocation(k,"uvPosition"),b.enableVertexAttribArray(k.uvPositionAttribute),k.samplerUniform=b.getUniformLocation(k,"uSampler"),b.uniform1i(k.samplerUniform,0),k.uprightUniform=b.getUniformLocation(k,"uUpright"),b.uniform1f(k.uprightUniform,0),f&&f(b,this,k);break;case"override":case"particle":case"regular":default:k.vertexPositionAttribute=b.getAttribLocation(k,"vertexPosition"),b.enableVertexAttribArray(k.vertexPositionAttribute),k.uvPositionAttribute=b.getAttribLocation(k,"uvPosition"),b.enableVertexAttribArray(k.uvPositionAttribute),k.textureIndexAttribute=b.getAttribLocation(k,"textureIndex"),b.enableVertexAttribArray(k.textureIndexAttribute),k.alphaAttribute=b.getAttribLocation(k,"objectAlpha"),b.enableVertexAttribArray(k.alphaAttribute);for(var l=[],m=0;m<this._batchTextureCount;m++)l[m]=m;k.samplerData=l,k.samplerUniform=b.getUniformLocation(k,"uSampler"),b.uniform1iv(k.samplerUniform,l),k.pMatrixUniform=b.getUniformLocation(k,"pMatrix")}return b.useProgram(this._activeShader),k},b._createShader=function(b,c,d){d=d.replace(/{{count}}/g,this._batchTextureCount);for(var e="",f=1;f<this._batchTextureCount;f++)e+="} else if (indexPicker <= "+f+".5) { color = texture2D(uSampler["+f+"], vTextureCoord);";d=d.replace(/{{alternates}}/g,e),d=d.replace(/{{fragColor}}/g,this._premultiply?a.REGULAR_FRAG_COLOR_PREMULTIPLY:a.REGULAR_FRAG_COLOR_NORMAL);var g=b.createShader(c);if(b.shaderSource(g,d),b.compileShader(g),!b.getShaderParameter(g,b.COMPILE_STATUS))throw b.getShaderInfoLog(g);return g},b._createBuffers=function(b){var c,d,e,f=this._maxCardsPerBatch*a.INDICIES_PER_CARD,g=this._vertexPositionBuffer=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,g),c=2;var h=this._vertices=new Float32Array(f*c);for(d=0,e=h.length;e>d;d+=c)h[d]=h[d+1]=0;b.bufferData(b.ARRAY_BUFFER,h,b.DYNAMIC_DRAW),g.itemSize=c,g.numItems=f;var i=this._uvPositionBuffer=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,i),c=2;var j=this._uvs=new Float32Array(f*c);for(d=0,e=j.length;e>d;d+=c)j[d]=j[d+1]=0;b.bufferData(b.ARRAY_BUFFER,j,b.DYNAMIC_DRAW),i.itemSize=c,i.numItems=f;var k=this._textureIndexBuffer=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,k),c=1;var l=this._indices=new Float32Array(f*c);for(d=0,e=l.length;e>d;d++)l[d]=0;b.bufferData(b.ARRAY_BUFFER,l,b.DYNAMIC_DRAW),k.itemSize=c,k.numItems=f;var m=this._alphaBuffer=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,m),c=1;var n=this._alphas=new Float32Array(f*c);for(d=0,e=n.length;e>d;d++)n[d]=1;b.bufferData(b.ARRAY_BUFFER,n,b.DYNAMIC_DRAW),m.itemSize=c,m.numItems=f},b._initTextures=function(){this._lastTextureInsert=-1,this._textureDictionary=[],this._textureIDs={},this._baseTextures=[],this._batchTextures=[];for(var a=0;a<this._batchTextureCount;a++){var b=this.getBaseTexture();if(this._baseTextures[a]=this._batchTextures[a]=b,!b)throw"Problems creating basic textures, known causes include using too much VRAM by not releasing WebGL texture instances"}},b._loadTextureImage=function(a,b){var c=b.src;c||(b._isCanvas=!0,c=b.src="canvas_"+this._lastTrackedCanvas++);var d=this._textureIDs[c];void 0===d&&(d=this._textureIDs[c]=this._textureDictionary.length),void 0===this._textureDictionary[d]&&(this._textureDictionary[d]=this.getBaseTexture());var e=this._textureDictionary[d];if(e)e._batchID=this._batchID,e._storeID=d,e._imageData=b,this._insertTextureInBatch(a,e),b._storeID=d,b.complete||b.naturalWidth||b._isCanvas?this._updateTextureImageData(a,b):b.addEventListener("load",this._updateTextureImageData.bind(this,a,b));else{var f="Problem creating desired texture, known causes include using too much VRAM by not releasing WebGL texture instances";console.error&&console.error(f)||console.log(f),e=this._baseTextures[0],e._batchID=this._batchID,e._storeID=-1,e._imageData=e,this._insertTextureInBatch(a,e)}return e},b._updateTextureImageData=function(a,b){var c=b.width&b.width-1||b.height&b.height-1,d=this._textureDictionary[b._storeID];a.activeTexture(a.TEXTURE0+d._activeIndex),a.bindTexture(a.TEXTURE_2D,d),d.isPOT=!c,this.setTextureParams(a,d.isPOT);try{a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,b)}catch(e){var f="\nAn error has occurred. This is most likely due to security restrictions on WebGL images with local or cross-domain origins";console.error?(console.error(f),console.error(e)):console&&(console.log(f),console.log(e))}b._invalid=!1,d._w=b.width,d._h=b.height,this.vocalDebug&&(c&&console.warn("NPOT(Non Power of Two) Texture: "+b.src),(b.width>a.MAX_TEXTURE_SIZE||b.height>a.MAX_TEXTURE_SIZE)&&console&&console.error("Oversized Texture: "+b.width+"x"+b.height+" vs "+a.MAX_TEXTURE_SIZE+"max"))},b._insertTextureInBatch=function(a,b){if(this._batchTextures[b._activeIndex]!==b){var c=-1,d=(this._lastTextureInsert+1)%this._batchTextureCount,e=d;do{if(this._batchTextures[e]._batchID!=this._batchID&&!this._slotBlacklist[e]){c=e;break}e=(e+1)%this._batchTextureCount}while(e!==d);-1===c&&(this.batchReason="textureOverflow",this._drawBuffers(a),this.batchCardCount=0,c=d),this._batchTextures[c]=b,b._activeIndex=c;var f=b._imageData;f&&f._invalid&&void 0!==b._drawID?this._updateTextureImageData(a,f):(a.activeTexture(a.TEXTURE0+c),a.bindTexture(a.TEXTURE_2D,b),this.setTextureParams(a)),this._lastTextureInsert=c}else{var f=b._imageData;void 0!=b._storeID&&f&&f._invalid&&this._updateTextureImageData(a,f)}b._drawID=this._drawID,b._batchID=this._batchID},b._killTextureObject=function(a){if(a){var b=this._webGLContext;if(void 0!==a._storeID&&a._storeID>=0){this._textureDictionary[a._storeID]=void 0;for(var c in this._textureIDs)this._textureIDs[c]==a._storeID&&delete this._textureIDs[c];a._imageData&&(a._imageData._storeID=void 0),a._imageData=a._storeID=void 0}void 0!==a._activeIndex&&this._batchTextures[a._activeIndex]===a&&(this._batchTextures[a._activeIndex]=this._baseTextures[a._activeIndex]);try{a._frameBuffer&&b.deleteFramebuffer(a._frameBuffer),a._frameBuffer=void 0}catch(d){this.vocalDebug&&console.log(d)}try{b.deleteTexture(a)}catch(d){this.vocalDebug&&console.log(d)}}},b._backupBatchTextures=function(a,b){var c=this._webGLContext;this._backupTextures||(this._backupTextures=[]),void 0===b&&(b=this._backupTextures);for(var d=0;d<this._batchTextureCount;d++)c.activeTexture(c.TEXTURE0+d),a?this._batchTextures[d]=b[d]:(b[d]=this._batchTextures[d],this._batchTextures[d]=this._baseTextures[d]),c.bindTexture(c.TEXTURE_2D,this._batchTextures[d]),this.setTextureParams(c,this._batchTextures[d].isPOT);a&&b===this._backupTextures&&(this._backupTextures=[])},b._batchDraw=function(a,b,c){this._isDrawing>0&&this._drawBuffers(b),this._isDrawing++,this._drawID++,this.batchCardCount=0,this.depth=0,this._appendToBatchGroup(a,b,new createjs.Matrix2D,this.alpha,c),this.batchReason="drawFinish",this._drawBuffers(b),this._isDrawing--},b._cacheDraw=function(a,b,c,d){var e,f=this._activeShader,g=this._slotBlacklist,h=this._maxTextureSlots-1,i=this._viewportWidth,j=this._viewportHeight;this.protectTextureSlot(h,!0);var k=b.getMatrix();k=k.clone(),k.scale(1/d.scale,1/d.scale),k=k.invert(),k.translate(-d.offX/d.scale*b.scaleX,-d.offY/d.scale*b.scaleY);var l=this._cacheContainer;l.children=[b],l.transformMatrix=k,this._backupBatchTextures(!1),c&&c.length?this._drawFilters(b,c,d):this.isCacheControlled?(a.clear(a.COLOR_BUFFER_BIT),this._batchDraw(l,a,!0)):(a.activeTexture(a.TEXTURE0+h),b.cacheCanvas=this.getTargetRenderTexture(b,d._drawWidth,d._drawHeight),e=b.cacheCanvas,a.bindFramebuffer(a.FRAMEBUFFER,e._frameBuffer),this.updateViewport(d._drawWidth,d._drawHeight),this._projectionMatrix=this._projectionMatrixFlip,a.clear(a.COLOR_BUFFER_BIT),this._batchDraw(l,a,!0),a.bindFramebuffer(a.FRAMEBUFFER,null),this.updateViewport(i,j)),this._backupBatchTextures(!0),this.protectTextureSlot(h,!1),this._activeShader=f,this._slotBlacklist=g},b._drawFilters=function(a,b,c){var d,e=this._webGLContext,f=this._maxTextureSlots-1,g=this._viewportWidth,h=this._viewportHeight,i=this._cacheContainer,j=b.length;e.activeTexture(e.TEXTURE0+f),d=this.getTargetRenderTexture(a,c._drawWidth,c._drawHeight),e.bindFramebuffer(e.FRAMEBUFFER,d._frameBuffer),this.updateViewport(c._drawWidth,c._drawHeight),e.clear(e.COLOR_BUFFER_BIT),this._batchDraw(i,e,!0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,d),this.setTextureParams(e);var k=!1,l=0,m=b[l];do this._activeShader=this.getFilterShader(m),this._activeShader&&(e.activeTexture(e.TEXTURE0+f),d=this.getTargetRenderTexture(a,c._drawWidth,c._drawHeight),e.bindFramebuffer(e.FRAMEBUFFER,d._frameBuffer),e.viewport(0,0,c._drawWidth,c._drawHeight),e.clear(e.COLOR_BUFFER_BIT),this._drawCover(e,k),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,d),this.setTextureParams(e),(j>1||b[0]._multiPass)&&(k=!k),m=null!==m._multiPass?m._multiPass:b[++l]);while(m);this.isCacheControlled?(e.bindFramebuffer(e.FRAMEBUFFER,null),this.updateViewport(g,h),this._activeShader=this.getFilterShader(this),e.clear(e.COLOR_BUFFER_BIT),this._drawCover(e,k)):(k&&(e.activeTexture(e.TEXTURE0+f),d=this.getTargetRenderTexture(a,c._drawWidth,c._drawHeight),e.bindFramebuffer(e.FRAMEBUFFER,d._frameBuffer),this._activeShader=this.getFilterShader(this),e.viewport(0,0,c._drawWidth,c._drawHeight),e.clear(e.COLOR_BUFFER_BIT),this._drawCover(e,!k)),e.bindFramebuffer(e.FRAMEBUFFER,null),this.updateViewport(g,h),a.cacheCanvas=d)},b._appendToBatchGroup=function(b,c,d,e,f){b._glMtx||(b._glMtx=new createjs.Matrix2D);var g=b._glMtx;g.copy(d),b.transformMatrix?g.appendMatrix(b.transformMatrix):g.appendTransform(b.x,b.y,b.scaleX,b.scaleY,b.rotation,b.skewX,b.skewY,b.regX,b.regY);for(var h,i,j,k,l=b.children.length,m=0;l>m;m++){var n=b.children[m];if(n.visible&&e)if(n.cacheCanvas&&!f||(n._updateState&&n._updateState(),!n.children)){this.batchCardCount+1>this._maxCardsPerBatch&&(this.batchReason="vertexOverflow",this._drawBuffers(c),this.batchCardCount=0),n._glMtx||(n._glMtx=new createjs.Matrix2D);var o=n._glMtx;o.copy(g),n.transformMatrix?o.appendMatrix(n.transformMatrix):o.appendTransform(n.x,n.y,n.scaleX,n.scaleY,n.rotation,n.skewX,n.skewY,n.regX,n.regY);var p,q,r,s,t,u,v=n.cacheCanvas&&!f;if(2===n._webGLRenderStyle||v)r=(f?!1:n.cacheCanvas)||n.image;else{if(1!==n._webGLRenderStyle)continue;if(s=n.spriteSheet.getFrame(n.currentFrame),null===s)continue;r=s.image}var w=this._uvs,x=this._vertices,y=this._indices,z=this._alphas;if(r){if(void 0===r._storeID)t=this._loadTextureImage(c,r),this._insertTextureInBatch(c,t);else{if(t=this._textureDictionary[r._storeID],!t){this.vocalDebug&&console.log("Texture should not be looked up while not being stored.");continue}t._batchID!==this._batchID&&this._insertTextureInBatch(c,t)}if(q=t._activeIndex,2===n._webGLRenderStyle||v)!v&&n.sourceRect?(n._uvRect||(n._uvRect={}),u=n.sourceRect,p=n._uvRect,p.t=u.y/r.height,p.l=u.x/r.width,p.b=(u.y+u.height)/r.height,p.r=(u.x+u.width)/r.width,h=0,i=0,j=u.width+h,k=u.height+i):(p=a.UV_RECT,v?(u=n.bitmapCache,h=u.x+u._filterOffX/u.scale,i=u.y+u._filterOffY/u.scale,j=u._drawWidth/u.scale+h,k=u._drawHeight/u.scale+i):(h=0,i=0,j=r.width+h,k=r.height+i));else if(1===n._webGLRenderStyle){var A=s.rect;p=s.uvRect,p||(p=a.buildUVRects(n.spriteSheet,n.currentFrame,!1)),h=-s.regX,i=-s.regY,j=A.width-s.regX,k=A.height-s.regY}var B=this.batchCardCount*a.INDICIES_PER_CARD,C=2*B;x[C]=h*o.a+i*o.c+o.tx,x[C+1]=h*o.b+i*o.d+o.ty,x[C+2]=h*o.a+k*o.c+o.tx,x[C+3]=h*o.b+k*o.d+o.ty,x[C+4]=j*o.a+i*o.c+o.tx,x[C+5]=j*o.b+i*o.d+o.ty,x[C+6]=x[C+2],x[C+7]=x[C+3],x[C+8]=x[C+4],x[C+9]=x[C+5],x[C+10]=j*o.a+k*o.c+o.tx,x[C+11]=j*o.b+k*o.d+o.ty,w[C]=p.l,w[C+1]=p.t,w[C+2]=p.l,w[C+3]=p.b,w[C+4]=p.r,w[C+5]=p.t,w[C+6]=p.l,w[C+7]=p.b,w[C+8]=p.r,w[C+9]=p.t,w[C+10]=p.r,w[C+11]=p.b,y[B]=y[B+1]=y[B+2]=y[B+3]=y[B+4]=y[B+5]=q,z[B]=z[B+1]=z[B+2]=z[B+3]=z[B+4]=z[B+5]=n.alpha*e,this.batchCardCount++}}else this._appendToBatchGroup(n,c,g,n.alpha*e)}},b._drawBuffers=function(b){if(!(this.batchCardCount<=0)){this.vocalDebug&&console.log("Draw["+this._drawID+":"+this._batchID+"] : "+this.batchReason);var c=this._activeShader,d=this._vertexPositionBuffer,e=this._textureIndexBuffer,f=this._uvPositionBuffer,g=this._alphaBuffer;b.useProgram(c),b.bindBuffer(b.ARRAY_BUFFER,d),b.vertexAttribPointer(c.vertexPositionAttribute,d.itemSize,b.FLOAT,!1,0,0),b.bufferSubData(b.ARRAY_BUFFER,0,this._vertices),b.bindBuffer(b.ARRAY_BUFFER,e),b.vertexAttribPointer(c.textureIndexAttribute,e.itemSize,b.FLOAT,!1,0,0),b.bufferSubData(b.ARRAY_BUFFER,0,this._indices),b.bindBuffer(b.ARRAY_BUFFER,f),b.vertexAttribPointer(c.uvPositionAttribute,f.itemSize,b.FLOAT,!1,0,0),b.bufferSubData(b.ARRAY_BUFFER,0,this._uvs),b.bindBuffer(b.ARRAY_BUFFER,g),b.vertexAttribPointer(c.alphaAttribute,g.itemSize,b.FLOAT,!1,0,0),b.bufferSubData(b.ARRAY_BUFFER,0,this._alphas),b.uniformMatrix4fv(c.pMatrixUniform,b.FALSE,this._projectionMatrix);for(var h=0;h<this._batchTextureCount;h++){var i=this._batchTextures[h];b.activeTexture(b.TEXTURE0+h),b.bindTexture(b.TEXTURE_2D,i),this.setTextureParams(b,i.isPOT)}b.drawArrays(b.TRIANGLES,0,this.batchCardCount*a.INDICIES_PER_CARD),this._batchID++}},b._drawCover=function(b,c){this._isDrawing>0&&this._drawBuffers(b),this.vocalDebug&&console.log("Draw["+this._drawID+":"+this._batchID+"] : Cover");var d=this._activeShader,e=this._vertexPositionBuffer,f=this._uvPositionBuffer;b.clear(b.COLOR_BUFFER_BIT),b.useProgram(d),b.bindBuffer(b.ARRAY_BUFFER,e),b.vertexAttribPointer(d.vertexPositionAttribute,e.itemSize,b.FLOAT,!1,0,0),b.bufferSubData(b.ARRAY_BUFFER,0,a.COVER_VERT),b.bindBuffer(b.ARRAY_BUFFER,f),b.vertexAttribPointer(d.uvPositionAttribute,f.itemSize,b.FLOAT,!1,0,0),b.bufferSubData(b.ARRAY_BUFFER,0,c?a.COVER_UV_FLIP:a.COVER_UV),b.uniform1i(d.samplerUniform,0),b.uniform1f(d.uprightUniform,c?0:1),b.drawArrays(b.TRIANGLES,0,a.INDICIES_PER_CARD)},createjs.StageGL=createjs.promote(a,"Stage")}(),this.createjs=this.createjs||{},function(){function a(a){this.DisplayObject_constructor(),"string"==typeof a?(this.image=document.createElement("img"),this.image.src=a):this.image=a,this.sourceRect=null,this._webGLRenderStyle=createjs.DisplayObject._StageGL_BITMAP}var b=createjs.extend(a,createjs.DisplayObject);b.initialize=a,b.isVisible=function(){var a=this.image,b=this.cacheCanvas||a&&(a.naturalWidth||a.getContext||a.readyState>=2);return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&b)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;var c=this.image,d=this.sourceRect;if(c.getImage&&(c=c.getImage()),!c)return!0;if(d){var e=d.x,f=d.y,g=e+d.width,h=f+d.height,i=0,j=0,k=c.width,l=c.height;0>e&&(i-=e,e=0),g>k&&(g=k),0>f&&(j-=f,f=0),h>l&&(h=l),a.drawImage(c,e,f,g-e,h-f,i,j,g-e,h-f)}else a.drawImage(c,0,0);return!0},b.getBounds=function(){var a=this.DisplayObject_getBounds();if(a)return a;var b=this.image,c=this.sourceRect||b,d=b&&(b.naturalWidth||b.getContext||b.readyState>=2);return d?this._rectangle.setValues(0,0,c.width,c.height):null},b.clone=function(b){var c=this.image;c&&b&&(c=c.cloneNode());var d=new a(c);return this.sourceRect&&(d.sourceRect=this.sourceRect.clone()),this._cloneProps(d),d},b.toString=function(){return"[Bitmap (name="+this.name+")]"},createjs.Bitmap=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.DisplayObject_constructor(),this.currentFrame=0,this.currentAnimation=null,this.paused=!0,this.spriteSheet=a,this.currentAnimationFrame=0,this.framerate=0,this._animation=null,this._currentFrame=null,this._skipAdvance=!1,this._webGLRenderStyle=createjs.DisplayObject._StageGL_SPRITE,null!=b&&this.gotoAndPlay(b)}var b=createjs.extend(a,createjs.DisplayObject);b.initialize=a,b.isVisible=function(){var a=this.cacheCanvas||this.spriteSheet.complete;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;this._normalizeFrame();var c=this.spriteSheet.getFrame(0|this._currentFrame);if(!c)return!1;var d=c.rect;return d.width&&d.height&&a.drawImage(c.image,d.x,d.y,d.width,d.height,-c.regX,-c.regY,d.width,d.height),!0},b.play=function(){this.paused=!1},b.stop=function(){this.paused=!0},b.gotoAndPlay=function(a){this.paused=!1,this._skipAdvance=!0,this._goto(a)},b.gotoAndStop=function(a){this.paused=!0,this._goto(a)},b.advance=function(a){var b=this.framerate||this.spriteSheet.framerate,c=b&&null!=a?a/(1e3/b):1;this._normalizeFrame(c)},b.getBounds=function(){return this.DisplayObject_getBounds()||this.spriteSheet.getFrameBounds(this.currentFrame,this._rectangle)},b.clone=function(){return this._cloneProps(new a(this.spriteSheet))},b.toString=function(){return"[Sprite (name="+this.name+")]"},b._cloneProps=function(a){return this.DisplayObject__cloneProps(a),a.currentFrame=this.currentFrame,a.currentAnimation=this.currentAnimation,a.paused=this.paused,a.currentAnimationFrame=this.currentAnimationFrame,a.framerate=this.framerate,a._animation=this._animation,a._currentFrame=this._currentFrame,a._skipAdvance=this._skipAdvance,a},b._tick=function(a){this.paused||(this._skipAdvance||this.advance(a&&a.delta),this._skipAdvance=!1),this.DisplayObject__tick(a)},b._normalizeFrame=function(a){a=a||0;var b,c=this._animation,d=this.paused,e=this._currentFrame;if(c){var f=c.speed||1,g=this.currentAnimationFrame;if(b=c.frames.length,g+a*f>=b){var h=c.next;if(this._dispatchAnimationEnd(c,e,d,h,b-1))return;if(h)return this._goto(h,a-(b-g)/f);this.paused=!0,g=c.frames.length-1}else g+=a*f;this.currentAnimationFrame=g,this._currentFrame=c.frames[0|g]}else if(e=this._currentFrame+=a,b=this.spriteSheet.getNumFrames(),e>=b&&b>0&&!this._dispatchAnimationEnd(c,e,d,b-1)&&(this._currentFrame-=b)>=b)return this._normalizeFrame();e=0|this._currentFrame,this.currentFrame!=e&&(this.currentFrame=e,this.dispatchEvent("change"))},b._dispatchAnimationEnd=function(a,b,c,d,e){var f=a?a.name:null;if(this.hasEventListener("animationend")){var g=new createjs.Event("animationend");g.name=f,g.next=d,this.dispatchEvent(g)}var h=this._animation!=a||this._currentFrame!=b;return h||c||!this.paused||(this.currentAnimationFrame=e,h=!0),h},b._goto=function(a,b){if(this.currentAnimationFrame=0,isNaN(a)){var c=this.spriteSheet.getAnimation(a);c&&(this._animation=c,this.currentAnimation=a,this._normalizeFrame(b))}else this.currentAnimation=this._animation=null,this._currentFrame=a,this._normalizeFrame()},createjs.Sprite=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.DisplayObject_constructor(),this.graphics=a?a:new createjs.Graphics}var b=createjs.extend(a,createjs.DisplayObject);b.isVisible=function(){var a=this.cacheCanvas||this.graphics&&!this.graphics.isEmpty();return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){return this.DisplayObject_draw(a,b)?!0:(this.graphics.draw(a,this),!0)},b.clone=function(b){var c=b&&this.graphics?this.graphics.clone():this.graphics;return this._cloneProps(new a(c))},b.toString=function(){return"[Shape (name="+this.name+")]"},createjs.Shape=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){this.DisplayObject_constructor(),this.text=a,this.font=b,this.color=c,this.textAlign="left",this.textBaseline="top",this.maxWidth=null,this.outline=0,this.lineHeight=0,this.lineWidth=null}var b=createjs.extend(a,createjs.DisplayObject),c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");c.getContext&&(a._workingContext=c.getContext("2d"),c.width=c.height=1),a.H_OFFSETS={start:0,left:0,center:-.5,end:-1,right:-1},a.V_OFFSETS={top:0,hanging:-.01,middle:-.4,alphabetic:-.8,ideographic:-.85,bottom:-1},b.isVisible=function(){var a=this.cacheCanvas||null!=this.text&&""!==this.text;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;var c=this.color||"#000";return this.outline?(a.strokeStyle=c,a.lineWidth=1*this.outline):a.fillStyle=c,this._drawText(this._prepContext(a)),!0},b.getMeasuredWidth=function(){return this._getMeasuredWidth(this.text)},b.getMeasuredLineHeight=function(){return 1.2*this._getMeasuredWidth("M")},b.getMeasuredHeight=function(){return this._drawText(null,{}).height},b.getBounds=function(){var b=this.DisplayObject_getBounds();if(b)return b;if(null==this.text||""===this.text)return null;var c=this._drawText(null,{}),d=this.maxWidth&&this.maxWidth<c.width?this.maxWidth:c.width,e=d*a.H_OFFSETS[this.textAlign||"left"],f=this.lineHeight||this.getMeasuredLineHeight(),g=f*a.V_OFFSETS[this.textBaseline||"top"];return this._rectangle.setValues(e,g,d,c.height)},b.getMetrics=function(){var b={lines:[]};return b.lineHeight=this.lineHeight||this.getMeasuredLineHeight(),b.vOffset=b.lineHeight*a.V_OFFSETS[this.textBaseline||"top"],this._drawText(null,b,b.lines)},b.clone=function(){return this._cloneProps(new a(this.text,this.font,this.color))},b.toString=function(){return"[Text (text="+(this.text.length>20?this.text.substr(0,17)+"...":this.text)+")]"},b._cloneProps=function(a){return this.DisplayObject__cloneProps(a),a.textAlign=this.textAlign,a.textBaseline=this.textBaseline,a.maxWidth=this.maxWidth,a.outline=this.outline,a.lineHeight=this.lineHeight,a.lineWidth=this.lineWidth,a},b._prepContext=function(a){return a.font=this.font||"10px sans-serif",a.textAlign=this.textAlign||"left",a.textBaseline=this.textBaseline||"top",a.lineJoin="miter",a.miterLimit=2.5,a},b._drawText=function(b,c,d){var e=!!b;e||(b=a._workingContext,b.save(),this._prepContext(b));for(var f=this.lineHeight||this.getMeasuredLineHeight(),g=0,h=0,i=String(this.text).split(/(?:\r\n|\r|\n)/),j=0,k=i.length;k>j;j++){var l=i[j],m=null;if(null!=this.lineWidth&&(m=b.measureText(l).width)>this.lineWidth){var n=l.split(/(\s)/);l=n[0],m=b.measureText(l).width;for(var o=1,p=n.length;p>o;o+=2){var q=b.measureText(n[o]+n[o+1]).width;m+q>this.lineWidth?(e&&this._drawTextLine(b,l,h*f),d&&d.push(l),m>g&&(g=m),l=n[o+1],m=b.measureText(l).width,h++):(l+=n[o]+n[o+1],m+=q)}}e&&this._drawTextLine(b,l,h*f),d&&d.push(l),c&&null==m&&(m=b.measureText(l).width),m>g&&(g=m),h++}return c&&(c.width=g,c.height=h*f),e||b.restore(),c},b._drawTextLine=function(a,b,c){this.outline?a.strokeText(b,0,c,this.maxWidth||65535):a.fillText(b,0,c,this.maxWidth||65535)},b._getMeasuredWidth=function(b){var c=a._workingContext;c.save();var d=this._prepContext(c).measureText(b).width;return c.restore(),d},createjs.Text=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.Container_constructor(),this.text=a||"",this.spriteSheet=b,this.lineHeight=0,this.letterSpacing=0,this.spaceWidth=0,this._oldProps={text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0},this._oldStage=null,this._drawAction=null}var b=createjs.extend(a,createjs.Container);a.maxPoolSize=100,a._spritePool=[],b.draw=function(a,b){this.DisplayObject_draw(a,b)||(this._updateState(),this.Container_draw(a,b))},b.getBounds=function(){return this._updateText(),this.Container_getBounds()},b.isVisible=function(){var a=this.cacheCanvas||this.spriteSheet&&this.spriteSheet.complete&&this.text;return!!(this.visible&&this.alpha>0&&0!==this.scaleX&&0!==this.scaleY&&a)},b.clone=function(){return this._cloneProps(new a(this.text,this.spriteSheet))},b.addChild=b.addChildAt=b.removeChild=b.removeChildAt=b.removeAllChildren=function(){},b._updateState=function(){this._updateText()},b._cloneProps=function(a){return this.Container__cloneProps(a),a.lineHeight=this.lineHeight,a.letterSpacing=this.letterSpacing,a.spaceWidth=this.spaceWidth,a},b._getFrameIndex=function(a,b){var c,d=b.getAnimation(a);return d||(a!=(c=a.toUpperCase())||a!=(c=a.toLowerCase())||(c=null),c&&(d=b.getAnimation(c))),d&&d.frames[0]},b._getFrame=function(a,b){var c=this._getFrameIndex(a,b);return null==c?c:b.getFrame(c)},b._getLineHeight=function(a){var b=this._getFrame("1",a)||this._getFrame("T",a)||this._getFrame("L",a)||a.getFrame(0);return b?b.rect.height:1},b._getSpaceWidth=function(a){var b=this._getFrame("1",a)||this._getFrame("l",a)||this._getFrame("e",a)||this._getFrame("a",a)||a.getFrame(0);return b?b.rect.width:1},b._updateText=function(){var b,c=0,d=0,e=this._oldProps,f=!1,g=this.spaceWidth,h=this.lineHeight,i=this.spriteSheet,j=a._spritePool,k=this.children,l=0,m=k.length;for(var n in e)e[n]!=this[n]&&(e[n]=this[n],f=!0);if(f){var o=!!this._getFrame(" ",i);o||g||(g=this._getSpaceWidth(i)),h||(h=this._getLineHeight(i));for(var p=0,q=this.text.length;q>p;p++){var r=this.text.charAt(p);if(" "!=r||o)if("\n"!=r&&"\r"!=r){var s=this._getFrameIndex(r,i);null!=s&&(m>l?b=k[l]:(k.push(b=j.length?j.pop():new createjs.Sprite),b.parent=this,m++),b.spriteSheet=i,b.gotoAndStop(s),b.x=c,b.y=d,l++,c+=b.getBounds().width+this.letterSpacing)}else"\r"==r&&"\n"==this.text.charAt(p+1)&&p++,c=0,d+=h;else c+=g}for(;m>l;)j.push(b=k.pop()),b.parent=null,m--;j.length>a.maxPoolSize&&(j.length=a.maxPoolSize)}},createjs.BitmapText=createjs.promote(a,"Container")}(),this.createjs=this.createjs||{},function(){"use strict";function a(b){this.Container_constructor(),!a.inited&&a.init();var c,d,e,f;b instanceof String||arguments.length>1?(c=b,d=arguments[1],e=arguments[2],f=arguments[3],null==e&&(e=-1),b=null):b&&(c=b.mode,d=b.startPosition,e=b.loop,f=b.labels),b||(b={labels:f}),this.mode=c||a.INDEPENDENT,this.startPosition=d||0,this.loop=e===!0?-1:e||0,this.currentFrame=0,this.paused=b.paused||!1,this.actionsEnabled=!0,this.autoReset=!0,this.frameBounds=this.frameBounds||b.frameBounds,this.framerate=null,b.useTicks=b.paused=!0,this.timeline=new createjs.Timeline(b),this._synchOffset=0,this._rawPosition=-1,this._bound_resolveState=this._resolveState.bind(this),this._t=0,this._managed={}}function b(){throw"MovieClipPlugin cannot be instantiated."}var c=createjs.extend(a,createjs.Container);a.INDEPENDENT="independent",a.SINGLE_FRAME="single",a.SYNCHED="synched",a.inited=!1,a.init=function(){a.inited||(b.install(),a.inited=!0)},c._getLabels=function(){return this.timeline.getLabels()},c.getLabels=createjs.deprecate(c._getLabels,"MovieClip.getLabels"),c._getCurrentLabel=function(){return this.timeline.currentLabel},c.getCurrentLabel=createjs.deprecate(c._getCurrentLabel,"MovieClip.getCurrentLabel"),c._getDuration=function(){return this.timeline.duration},c.getDuration=createjs.deprecate(c._getDuration,"MovieClip.getDuration");try{Object.defineProperties(c,{labels:{get:c._getLabels},currentLabel:{get:c._getCurrentLabel},totalFrames:{get:c._getDuration},duration:{get:c._getDuration}})}catch(d){}c.initialize=a,c.isVisible=function(){return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY)},c.draw=function(a,b){return this.DisplayObject_draw(a,b)?!0:(this._updateState(),this.Container_draw(a,b),!0)},c.play=function(){this.paused=!1},c.stop=function(){this.paused=!0},c.gotoAndPlay=function(a){this.paused=!1,this._goto(a)},c.gotoAndStop=function(a){this.paused=!0,this._goto(a)},c.advance=function(b){var c=a.INDEPENDENT;if(this.mode===c){for(var d=this,e=d.framerate;(d=d.parent)&&null===e;)d.mode===c&&(e=d._framerate);if(this._framerate=e,!this.paused){var f=null!==e&&-1!==e&&null!==b?b/(1e3/e)+this._t:1,g=0|f;for(this._t=f-g;g--;)this._updateTimeline(this._rawPosition+1,!1)}}},c.clone=function(){throw"MovieClip cannot be cloned."},c.toString=function(){return"[MovieClip (name="+this.name+")]"},c._updateState=function(){(-1===this._rawPosition||this.mode!==a.INDEPENDENT)&&this._updateTimeline(-1)},c._tick=function(a){this.advance(a&&a.delta),this.Container__tick(a)},c._goto=function(a){var b=this.timeline.resolve(a);null!=b&&(this._t=0,this._updateTimeline(b,!0))},c._reset=function(){this._rawPosition=-1,this._t=this.currentFrame=0,this.paused=!1},c._updateTimeline=function(b,c){var d=this.mode!==a.INDEPENDENT,e=this.timeline;d&&(b=this.startPosition+(this.mode===a.SINGLE_FRAME?0:this._synchOffset)),0>b&&(b=0),(this._rawPosition!==b||d)&&(this._rawPosition=b,e.loop=this.loop,e.setPosition(b,d||!this.actionsEnabled,c,this._bound_resolveState))},c._renderFirstFrame=function(){var a=this.timeline,b=a.rawPosition;a.setPosition(0,!0,!0,this._bound_resolveState),a.rawPosition=b},c._resolveState=function(){var a=this.timeline;this.currentFrame=a.position;for(var b in this._managed)this._managed[b]=1;for(var c=a.tweens,d=0,e=c.length;e>d;d++){var f=c[d],g=f.target;if(g!==this&&!f.passive){var h=f._stepPosition;g instanceof createjs.DisplayObject?this._addManagedChild(g,h):this._setState(g.state,h)}}var i=this.children;for(d=i.length-1;d>=0;d--){var j=i[d].id;1===this._managed[j]&&(this.removeChildAt(d),delete this._managed[j])}},c._setState=function(a,b){if(a)for(var c=a.length-1;c>=0;c--){var d=a[c],e=d.t,f=d.p;for(var g in f)e[g]=f[g];this._addManagedChild(e,b)}},c._addManagedChild=function(b,c){b._off||(this.addChildAt(b,0),b instanceof a&&(b._synchOffset=c,b.mode===a.INDEPENDENT&&b.autoReset&&!this._managed[b.id]&&b._reset()),this._managed[b.id]=2)},c._getBounds=function(a,b){var c=this.DisplayObject_getBounds();return c||this.frameBounds&&(c=this._rectangle.copy(this.frameBounds[this.currentFrame])),c?this._transformBounds(c,a,b):this.Container__getBounds(a,b)},createjs.MovieClip=createjs.promote(a,"Container"),b.priority=100,b.ID="MovieClip",b.install=function(){createjs.Tween._installPlugin(b)},b.init=function(c,d){"startPosition"===d&&c.target instanceof a&&c._addPlugin(b)},b.step=function(){},b.change=function(a,b,c,d,e){return"startPosition"===c?1===e?b.props[c]:b.prev.props[c]:void 0}}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"SpriteSheetUtils cannot be instantiated"}var b=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");b.getContext&&(a._workingCanvas=b,a._workingContext=b.getContext("2d"),b.width=b.height=1),a.extractFrame=function(b,c){isNaN(c)&&(c=b.getAnimation(c).frames[0]);var d=b.getFrame(c);if(!d)return null;var e=d.rect,f=a._workingCanvas;f.width=e.width,f.height=e.height,a._workingContext.drawImage(d.image,e.x,e.y,e.width,e.height,0,0,e.width,e.height);var g=document.createElement("img");return g.src=f.toDataURL("image/png"),g},a.addFlippedFrames=createjs.deprecate(null,"SpriteSheetUtils.addFlippedFrames"),a.mergeAlpha=createjs.deprecate(null,"SpriteSheetUtils.mergeAlpha"),a._flip=function(b,c,d,e){for(var f=b._images,g=a._workingCanvas,h=a._workingContext,i=f.length/c,j=0;i>j;j++){var k=f[j];k.__tmp=j,h.setTransform(1,0,0,1,0,0),h.clearRect(0,0,g.width+1,g.height+1),g.width=k.width,g.height=k.height,h.setTransform(d?-1:1,0,0,e?-1:1,d?k.width:0,e?k.height:0),h.drawImage(k,0,0);var l=document.createElement("img");l.src=g.toDataURL("image/png"),l.width=k.width||k.naturalWidth,l.height=k.height||k.naturalHeight,f.push(l)}var m=b._frames,n=m.length/c;for(j=0;n>j;j++){k=m[j];
var o=k.rect.clone();l=f[k.image.__tmp+i*c];var p={image:l,rect:o,regX:k.regX,regY:k.regY};d&&(o.x=(l.width||l.naturalWidth)-o.x-o.width,p.regX=o.width-k.regX),e&&(o.y=(l.height||l.naturalHeight)-o.y-o.height,p.regY=o.height-k.regY),m.push(p)}var q="_"+(d?"h":"")+(e?"v":""),r=b._animations,s=b._data,t=r.length/c;for(j=0;t>j;j++){var u=r[j];k=s[u];var v={name:u+q,speed:k.speed,next:k.next,frames:[]};k.next&&(v.next+=q),m=k.frames;for(var w=0,x=m.length;x>w;w++)v.frames.push(m[w]+n*c);s[v.name]=v,r.push(v.name)}},createjs.SpriteSheetUtils=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.EventDispatcher_constructor(),this.maxWidth=2048,this.maxHeight=2048,this.spriteSheet=null,this.scale=1,this.padding=1,this.timeSlice=.3,this.progress=-1,this.framerate=a||0,this._frames=[],this._animations={},this._data=null,this._nextFrameIndex=0,this._index=0,this._timerID=null,this._scale=1}var b=createjs.extend(a,createjs.EventDispatcher);a.ERR_DIMENSIONS="frame dimensions exceed max spritesheet dimensions",a.ERR_RUNNING="a build is already running",b.addFrame=function(b,c,d,e,f){if(this._data)throw a.ERR_RUNNING;var g=c||b.bounds||b.nominalBounds;return!g&&b.getBounds&&(g=b.getBounds()),g?(d=d||1,this._frames.push({source:b,sourceRect:g,scale:d,funct:e,data:f,index:this._frames.length,height:g.height*d})-1):null},b.addAnimation=function(b,c,d,e){if(this._data)throw a.ERR_RUNNING;this._animations[b]={frames:c,next:d,speed:e}},b.addMovieClip=function(b,c,d,e,f,g){if(this._data)throw a.ERR_RUNNING;var h=b.frameBounds,i=c||b.bounds||b.nominalBounds;if(!i&&b.getBounds&&(i=b.getBounds()),i||h){var j,k,l=this._frames.length,m=b.timeline.duration;for(j=0;m>j;j++){var n=h&&h[j]?h[j]:i;this.addFrame(b,n,d,this._setupMovieClipFrame,{i:j,f:e,d:f})}var o=b.timeline._labels,p=[];for(var q in o)p.push({index:o[q],label:q});if(p.length)for(p.sort(function(a,b){return a.index-b.index}),j=0,k=p.length;k>j;j++){for(var r=p[j].label,s=l+p[j].index,t=l+(j==k-1?m:p[j+1].index),u=[],v=s;t>v;v++)u.push(v);(!g||(r=g(r,b,s,t)))&&this.addAnimation(r,u,!0)}}},b.build=function(){if(this._data)throw a.ERR_RUNNING;for(this._startBuild();this._drawNext(););return this._endBuild(),this.spriteSheet},b.buildAsync=function(b){if(this._data)throw a.ERR_RUNNING;this.timeSlice=b,this._startBuild();var c=this;this._timerID=setTimeout(function(){c._run()},50-50*Math.max(.01,Math.min(.99,this.timeSlice||.3)))},b.stopAsync=function(){clearTimeout(this._timerID),this._data=null},b.clone=function(){throw"SpriteSheetBuilder cannot be cloned."},b.toString=function(){return"[SpriteSheetBuilder]"},b._startBuild=function(){var b=this.padding||0;this.progress=0,this.spriteSheet=null,this._index=0,this._scale=this.scale;var c=[];this._data={images:[],frames:c,framerate:this.framerate,animations:this._animations};var d=this._frames.slice();if(d.sort(function(a,b){return a.height<=b.height?-1:1}),d[d.length-1].height+2*b>this.maxHeight)throw a.ERR_DIMENSIONS;for(var e=0,f=0,g=0;d.length;){var h=this._fillRow(d,e,g,c,b);if(h.w>f&&(f=h.w),e+=h.h,!h.h||!d.length){var i=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");i.width=this._getSize(f,this.maxWidth),i.height=this._getSize(e,this.maxHeight),this._data.images[g]=i,h.h||(f=e=0,g++)}}},b._setupMovieClipFrame=function(a,b){var c=a.actionsEnabled;a.actionsEnabled=!1,a.gotoAndStop(b.i),a.actionsEnabled=c,b.f&&b.f(a,b.d,b.i)},b._getSize=function(a,b){for(var c=4;Math.pow(2,++c)<a;);return Math.min(b,Math.pow(2,c))},b._fillRow=function(b,c,d,e,f){var g=this.maxWidth,h=this.maxHeight;c+=f;for(var i=h-c,j=f,k=0,l=b.length-1;l>=0;l--){var m=b[l],n=this._scale*m.scale,o=m.sourceRect,p=m.source,q=Math.floor(n*o.x-f),r=Math.floor(n*o.y-f),s=Math.ceil(n*o.height+2*f),t=Math.ceil(n*o.width+2*f);if(t>g)throw a.ERR_DIMENSIONS;s>i||j+t>g||(m.img=d,m.rect=new createjs.Rectangle(j,c,t,s),k=k||s,b.splice(l,1),e[m.index]=[j,c,t,s,d,Math.round(-q+n*p.regX-f),Math.round(-r+n*p.regY-f)],j+=t)}return{w:j,h:k}},b._endBuild=function(){this.spriteSheet=new createjs.SpriteSheet(this._data),this._data=null,this.progress=1,this.dispatchEvent("complete")},b._run=function(){for(var a=50*Math.max(.01,Math.min(.99,this.timeSlice||.3)),b=(new Date).getTime()+a,c=!1;b>(new Date).getTime();)if(!this._drawNext()){c=!0;break}if(c)this._endBuild();else{var d=this;this._timerID=setTimeout(function(){d._run()},50-a)}var e=this.progress=this._index/this._frames.length;if(this.hasEventListener("progress")){var f=new createjs.Event("progress");f.progress=e,this.dispatchEvent(f)}},b._drawNext=function(){var a=this._frames[this._index],b=a.scale*this._scale,c=a.rect,d=a.sourceRect,e=this._data.images[a.img],f=e.getContext("2d");return a.funct&&a.funct(a.source,a.data),f.save(),f.beginPath(),f.rect(c.x,c.y,c.width,c.height),f.clip(),f.translate(Math.ceil(c.x-d.x*b),Math.ceil(c.y-d.y*b)),f.scale(b,b),a.source.draw(f),f.restore(),++this._index<this._frames.length},createjs.SpriteSheetBuilder=createjs.promote(a,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.DisplayObject_constructor(),"string"==typeof a&&(a=document.getElementById(a)),this.mouseEnabled=!1;var b=a.style;b.position="absolute",b.transformOrigin=b.WebkitTransformOrigin=b.msTransformOrigin=b.MozTransformOrigin=b.OTransformOrigin="0% 0%",this.htmlElement=a,this._oldProps=null,this._oldStage=null,this._drawAction=null}var b=createjs.extend(a,createjs.DisplayObject);b.isVisible=function(){return null!=this.htmlElement},b.draw=function(){return!0},b.cache=function(){},b.uncache=function(){},b.updateCache=function(){},b.hitTest=function(){},b.localToGlobal=function(){},b.globalToLocal=function(){},b.localToLocal=function(){},b.clone=function(){throw"DOMElement cannot be cloned."},b.toString=function(){return"[DOMElement (name="+this.name+")]"},b._tick=function(a){var b=this.stage;b&&b!==this._oldStage&&(this._drawAction&&b.off("drawend",this._drawAction),this._drawAction=b.on("drawend",this._handleDrawEnd,this),this._oldStage=b),this.DisplayObject__tick(a)},b._handleDrawEnd=function(){var a=this.htmlElement;if(a){var b=a.style,c=this.getConcatenatedDisplayProps(this._props),d=c.matrix,e=c.visible?"visible":"hidden";if(e!=b.visibility&&(b.visibility=e),c.visible){var f=this._oldProps,g=f&&f.matrix,h=1e4;if(!g||!g.equals(d)){var i="matrix("+(d.a*h|0)/h+","+(d.b*h|0)/h+","+(d.c*h|0)/h+","+(d.d*h|0)/h+","+(d.tx+.5|0);b.transform=b.WebkitTransform=b.OTransform=b.msTransform=i+","+(d.ty+.5|0)+")",b.MozTransform=i+"px,"+(d.ty+.5|0)+"px)",f||(f=this._oldProps=new createjs.DisplayProps(!0,null)),f.matrix.copy(d)}f.alpha!=c.alpha&&(b.opacity=""+(c.alpha*h|0)/h,f.alpha=c.alpha)}}},createjs.DOMElement=createjs.promote(a,"DisplayObject")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.usesContext=!1,this._multiPass=null,this.VTX_SHADER_BODY=null,this.FRAG_SHADER_BODY=null}var b=a.prototype;b.getBounds=function(a){return a},b.shaderParamSetup=function(){},b.applyFilter=function(a,b,c,d,e,f,g,h){f=f||a,null==g&&(g=b),null==h&&(h=c);try{var i=a.getImageData(b,c,d,e)}catch(j){return!1}return this._applyFilter(i)?(f.putImageData(i,g,h),!0):!1},b.toString=function(){return"[Filter]"},b.clone=function(){return new a},b._applyFilter=function(){return!0},createjs.Filter=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(){this.width=void 0,this.height=void 0,this.x=void 0,this.y=void 0,this.scale=1,this.offX=0,this.offY=0,this.cacheID=0,this._filterOffX=0,this._filterOffY=0,this._cacheDataURLID=0,this._cacheDataURL=null,this._drawWidth=0,this._drawHeight=0}var b=a.prototype;a.getFilterBounds=function(a,b){b||(b=new createjs.Rectangle);var c=a.filters,d=c&&c.length;if(0>=!!d)return b;for(var e=0;d>e;e++){var f=c[e];if(f&&f.getBounds){var g=f.getBounds();g&&(0==e?b.setValues(g.x,g.y,g.width,g.height):b.extend(g.x,g.y,g.width,g.height))}}return b},b.toString=function(){return"[BitmapCache]"},b.define=function(a,b,c,d,e,f,g){if(!a)throw"No symbol to cache";this._options=g,this.target=a,this.width=d>=1?d:1,this.height=e>=1?e:1,this.x=b||0,this.y=c||0,this.scale=f||1,this.update()},b.update=function(b){if(!this.target)throw"define() must be called before update()";var c=a.getFilterBounds(this.target),d=this.target.cacheCanvas;this._drawWidth=Math.ceil(this.width*this.scale)+c.width,this._drawHeight=Math.ceil(this.height*this.scale)+c.height,d&&this._drawWidth==d.width&&this._drawHeight==d.height||this._updateSurface(),this._filterOffX=c.x,this._filterOffY=c.y,this.offX=this.x*this.scale+this._filterOffX,this.offY=this.y*this.scale+this._filterOffY,this._drawToCache(b),this.cacheID=this.cacheID?this.cacheID+1:1},b.release=function(){if(this._webGLCache)this._webGLCache.isCacheControlled||(this.__lastRT&&(this.__lastRT=void 0),this.__rtA&&this._webGLCache._killTextureObject(this.__rtA),this.__rtB&&this._webGLCache._killTextureObject(this.__rtB),this.target&&this.target.cacheCanvas&&this._webGLCache._killTextureObject(this.target.cacheCanvas)),this._webGLCache=!1;else{var a=this.target.stage;a instanceof createjs.StageGL&&a.releaseTexture(this.target.cacheCanvas)}this.target=this.target.cacheCanvas=null,this.cacheID=this._cacheDataURLID=this._cacheDataURL=void 0,this.width=this.height=this.x=this.y=this.offX=this.offY=0,this.scale=1},b.getCacheDataURL=function(){var a=this.target&&this.target.cacheCanvas;return a?(this.cacheID!=this._cacheDataURLID&&(this._cacheDataURLID=this.cacheID,this._cacheDataURL=a.toDataURL?a.toDataURL():null),this._cacheDataURL):null},b.draw=function(a){return this.target?(a.drawImage(this.target.cacheCanvas,this.x+this._filterOffX/this.scale,this.y+this._filterOffY/this.scale,this._drawWidth/this.scale,this._drawHeight/this.scale),!0):!1},b._updateSurface=function(){if(!this._options||!this._options.useGL){var a=this.target.cacheCanvas;return a||(a=this.target.cacheCanvas=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas")),a.width=this._drawWidth,void(a.height=this._drawHeight)}if(!this._webGLCache)if("stage"===this._options.useGL){if(!this.target.stage||!this.target.stage.isWebGL){var b="Cannot use 'stage' for cache because the object's parent stage is ";throw b+=this.target.stage?"non WebGL.":"not set, please addChild to the correct stage."}this.target.cacheCanvas=!0,this._webGLCache=this.target.stage}else if("new"===this._options.useGL)this.target.cacheCanvas=document.createElement("canvas"),this._webGLCache=new createjs.StageGL(this.target.cacheCanvas,{antialias:!0,transparent:!0,autoPurge:-1}),this._webGLCache.isCacheControlled=!0;else{if(!(this._options.useGL instanceof createjs.StageGL))throw"Invalid option provided to useGL, expected ['stage', 'new', StageGL, undefined], got "+this._options.useGL;this.target.cacheCanvas=!0,this._webGLCache=this._options.useGL,this._webGLCache.isCacheControlled=!0}var a=this.target.cacheCanvas,c=this._webGLCache;c.isCacheControlled&&(a.width=this._drawWidth,a.height=this._drawHeight,c.updateViewport(this._drawWidth,this._drawHeight)),this.target.filters?(c.getTargetRenderTexture(this.target,this._drawWidth,this._drawHeight),c.getTargetRenderTexture(this.target,this._drawWidth,this._drawHeight)):c.isCacheControlled||c.getTargetRenderTexture(this.target,this._drawWidth,this._drawHeight)},b._drawToCache=function(a){var b=this.target.cacheCanvas,c=this.target,d=this._webGLCache;if(d)d.cacheDraw(c,c.filters,this),b=this.target.cacheCanvas,b.width=this._drawWidth,b.height=this._drawHeight;else{var e=b.getContext("2d");a||e.clearRect(0,0,this._drawWidth+1,this._drawHeight+1),e.save(),e.globalCompositeOperation=a,e.setTransform(this.scale,0,0,this.scale,-this._filterOffX,-this._filterOffY),e.translate(-this.x,-this.y),c.draw(e,!0),e.restore(),c.filters&&c.filters.length&&this._applyFilters(e)}b._invalid=!0},b._applyFilters=function(a){var b,c=this.target.filters,d=this._drawWidth,e=this._drawHeight,f=0,g=c[f];do g.usesContext?(b&&(a.putImageData(b,0,0),b=null),g.applyFilter(a,0,0,d,e)):(b||(b=a.getImageData(0,0,d,e)),g._applyFilter(b)),g=null!==g._multiPass?g._multiPass:c[++f];while(g);b&&a.putImageData(b,0,0)},createjs.BitmapCache=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){this.Filter_constructor(),this._blurX=a,this._blurXTable=[],this._lastBlurX=null,this._blurY=b,this._blurYTable=[],this._lastBlurY=null,this._quality,this._lastQuality=null,this.FRAG_SHADER_TEMPLATE="uniform float xWeight[{{blurX}}];uniform float yWeight[{{blurY}}];uniform vec2 textureOffset;void main(void) {vec4 color = vec4(0.0);float xAdj = ({{blurX}}.0-1.0)/2.0;float yAdj = ({{blurY}}.0-1.0)/2.0;vec2 sampleOffset;for(int i=0; i<{{blurX}}; i++) {for(int j=0; j<{{blurY}}; j++) {sampleOffset = vRenderCoord + (textureOffset * vec2(float(i)-xAdj, float(j)-yAdj));color += texture2D(uSampler, sampleOffset) * (xWeight[i] * yWeight[j]);}}gl_FragColor = color.rgba;}",(isNaN(c)||1>c)&&(c=1),this.setQuality(0|c)}var b=createjs.extend(a,createjs.Filter);b.getBlurX=function(){return this._blurX},b.getBlurY=function(){return this._blurY},b.setBlurX=function(a){(isNaN(a)||0>a)&&(a=0),this._blurX=a},b.setBlurY=function(a){(isNaN(a)||0>a)&&(a=0),this._blurY=a},b.getQuality=function(){return this._quality},b.setQuality=function(a){(isNaN(a)||0>a)&&(a=0),this._quality=0|a},b._getShader=function(){var a=this._lastBlurX!==this._blurX,b=this._lastBlurY!==this._blurY,c=this._lastQuality!==this._quality;return a||b||c?((a||c)&&(this._blurXTable=this._getTable(this._blurX*this._quality)),(b||c)&&(this._blurYTable=this._getTable(this._blurY*this._quality)),this._updateShader(),this._lastBlurX=this._blurX,this._lastBlurY=this._blurY,void(this._lastQuality=this._quality)):this._compiledShader},b._setShader=function(){this._compiledShader};try{Object.defineProperties(b,{blurX:{get:b.getBlurX,set:b.setBlurX},blurY:{get:b.getBlurY,set:b.setBlurY},quality:{get:b.getQuality,set:b.setQuality},_builtShader:{get:b._getShader,set:b._setShader}})}catch(c){console.log(c)}b._getTable=function(a){var b=4.2;if(1>=a)return[1];var c=[],d=Math.ceil(2*a);d+=d%2?0:1;for(var e=d/2|0,f=-e;e>=f;f++){var g=f/e*b;c.push(1/Math.sqrt(2*Math.PI)*Math.pow(Math.E,-(Math.pow(g,2)/4)))}var h=c.reduce(function(a,b){return a+b});return c.map(function(a){return a/h})},b._updateShader=function(){if(void 0!==this._blurX&&void 0!==this._blurY){var a=this.FRAG_SHADER_TEMPLATE;a=a.replace(/\{\{blurX\}\}/g,this._blurXTable.length.toFixed(0)),a=a.replace(/\{\{blurY\}\}/g,this._blurYTable.length.toFixed(0)),this.FRAG_SHADER_BODY=a}},b.shaderParamSetup=function(a,b,c){a.uniform1fv(a.getUniformLocation(c,"xWeight"),this._blurXTable),a.uniform1fv(a.getUniformLocation(c,"yWeight"),this._blurYTable),a.uniform2f(a.getUniformLocation(c,"textureOffset"),2/(b._viewportWidth*this._quality),2/(b._viewportHeight*this._quality))},a.MUL_TABLE=[1,171,205,293,57,373,79,137,241,27,391,357,41,19,283,265,497,469,443,421,25,191,365,349,335,161,155,149,9,278,269,261,505,245,475,231,449,437,213,415,405,395,193,377,369,361,353,345,169,331,325,319,313,307,301,37,145,285,281,69,271,267,263,259,509,501,493,243,479,118,465,459,113,446,55,435,429,423,209,413,51,403,199,393,97,3,379,375,371,367,363,359,355,351,347,43,85,337,333,165,327,323,5,317,157,311,77,305,303,75,297,294,73,289,287,71,141,279,277,275,68,135,67,133,33,262,260,129,511,507,503,499,495,491,61,121,481,477,237,235,467,232,115,457,227,451,7,445,221,439,218,433,215,427,425,211,419,417,207,411,409,203,202,401,399,396,197,49,389,387,385,383,95,189,47,187,93,185,23,183,91,181,45,179,89,177,11,175,87,173,345,343,341,339,337,21,167,83,331,329,327,163,81,323,321,319,159,79,315,313,39,155,309,307,153,305,303,151,75,299,149,37,295,147,73,291,145,289,287,143,285,71,141,281,35,279,139,69,275,137,273,17,271,135,269,267,133,265,33,263,131,261,130,259,129,257,1],a.SHG_TABLE=[0,9,10,11,9,12,10,11,12,9,13,13,10,9,13,13,14,14,14,14,10,13,14,14,14,13,13,13,9,14,14,14,15,14,15,14,15,15,14,15,15,15,14,15,15,15,15,15,14,15,15,15,15,15,15,12,14,15,15,13,15,15,15,15,16,16,16,15,16,14,16,16,14,16,13,16,16,16,15,16,13,16,15,16,14,9,16,16,16,16,16,16,16,16,16,13,14,16,16,15,16,16,10,16,15,16,14,16,16,14,16,16,14,16,16,14,15,16,16,16,14,15,14,15,13,16,16,15,17,17,17,17,17,17,14,15,17,17,16,16,17,16,15,17,16,17,11,17,16,17,16,17,16,17,17,16,17,17,16,17,17,16,16,17,17,17,16,14,17,17,17,17,15,16,14,16,15,16,13,16,15,16,14,16,15,16,12,16,15,16,17,17,17,17,17,13,16,15,17,17,17,16,15,17,17,17,16,15,17,17,14,16,17,17,16,17,17,16,15,17,16,14,17,16,15,17,16,17,17,16,17,15,16,17,14,17,16,15,17,16,17,13,17,16,17,17,16,17,14,17,16,17,16,17,16,17,9],b.getBounds=function(a){var b=0|this.blurX,c=0|this.blurY;if(0>=b&&0>=c)return a;var d=Math.pow(this.quality,.2);return(a||new createjs.Rectangle).pad(c*d+1,b*d+1,c*d+1,b*d+1)},b.clone=function(){return new a(this.blurX,this.blurY,this.quality)},b.toString=function(){return"[BlurFilter]"},b._applyFilter=function(b){var c=this._blurX>>1;if(isNaN(c)||0>c)return!1;var d=this._blurY>>1;if(isNaN(d)||0>d)return!1;if(0==c&&0==d)return!1;var e=this.quality;(isNaN(e)||1>e)&&(e=1),e|=0,e>3&&(e=3),1>e&&(e=1);var f=b.data,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=c+c+1|0,w=d+d+1|0,x=0|b.width,y=0|b.height,z=x-1|0,A=y-1|0,B=c+1|0,C=d+1|0,D={r:0,b:0,g:0,a:0},E=D;for(i=1;v>i;i++)E=E.n={r:0,b:0,g:0,a:0};E.n=D;var F={r:0,b:0,g:0,a:0},G=F;for(i=1;w>i;i++)G=G.n={r:0,b:0,g:0,a:0};G.n=F;for(var H=null,I=0|a.MUL_TABLE[c],J=0|a.SHG_TABLE[c],K=0|a.MUL_TABLE[d],L=0|a.SHG_TABLE[d];e-->0;){m=l=0;var M=I,N=J;for(h=y;--h>-1;){for(n=B*(r=f[0|l]),o=B*(s=f[l+1|0]),p=B*(t=f[l+2|0]),q=B*(u=f[l+3|0]),E=D,i=B;--i>-1;)E.r=r,E.g=s,E.b=t,E.a=u,E=E.n;for(i=1;B>i;i++)j=l+((i>z?z:i)<<2)|0,n+=E.r=f[j],o+=E.g=f[j+1],p+=E.b=f[j+2],q+=E.a=f[j+3],E=E.n;for(H=D,g=0;x>g;g++)f[l++]=n*M>>>N,f[l++]=o*M>>>N,f[l++]=p*M>>>N,f[l++]=q*M>>>N,j=m+((j=g+c+1)<z?j:z)<<2,n-=H.r-(H.r=f[j]),o-=H.g-(H.g=f[j+1]),p-=H.b-(H.b=f[j+2]),q-=H.a-(H.a=f[j+3]),H=H.n;m+=x}for(M=K,N=L,g=0;x>g;g++){for(l=g<<2|0,n=C*(r=f[l])|0,o=C*(s=f[l+1|0])|0,p=C*(t=f[l+2|0])|0,q=C*(u=f[l+3|0])|0,G=F,i=0;C>i;i++)G.r=r,G.g=s,G.b=t,G.a=u,G=G.n;for(k=x,i=1;d>=i;i++)l=k+g<<2,n+=G.r=f[l],o+=G.g=f[l+1],p+=G.b=f[l+2],q+=G.a=f[l+3],G=G.n,A>i&&(k+=x);if(l=g,H=F,e>0)for(h=0;y>h;h++)j=l<<2,f[j+3]=u=q*M>>>N,u>0?(f[j]=n*M>>>N,f[j+1]=o*M>>>N,f[j+2]=p*M>>>N):f[j]=f[j+1]=f[j+2]=0,j=g+((j=h+C)<A?j:A)*x<<2,n-=H.r-(H.r=f[j]),o-=H.g-(H.g=f[j+1]),p-=H.b-(H.b=f[j+2]),q-=H.a-(H.a=f[j+3]),H=H.n,l+=x;else for(h=0;y>h;h++)j=l<<2,f[j+3]=u=q*M>>>N,u>0?(u=255/u,f[j]=(n*M>>>N)*u,f[j+1]=(o*M>>>N)*u,f[j+2]=(p*M>>>N)*u):f[j]=f[j+1]=f[j+2]=0,j=g+((j=h+C)<A?j:A)*x<<2,n-=H.r-(H.r=f[j]),o-=H.g-(H.g=f[j+1]),p-=H.b-(H.b=f[j+2]),q-=H.a-(H.a=f[j+3]),H=H.n,l+=x}}return!0},createjs.BlurFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.Filter_constructor(),this.alphaMap=a,this._alphaMap=null,this._mapData=null,this._mapTexture=null,this.FRAG_SHADER_BODY="uniform sampler2D uAlphaSampler;void main(void) {vec4 color = texture2D(uSampler, vRenderCoord);vec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);gl_FragColor = vec4(color.rgb, color.a * (alphaMap.r * ceil(alphaMap.a)));}"}var b=createjs.extend(a,createjs.Filter);b.shaderParamSetup=function(a,b,c){this._mapTexture||(this._mapTexture=a.createTexture()),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this._mapTexture),b.setTextureParams(a),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,this.alphaMap),a.uniform1i(a.getUniformLocation(c,"uAlphaSampler"),1)},b.clone=function(){var b=new a(this.alphaMap);return b._alphaMap=this._alphaMap,b._mapData=this._mapData,b},b.toString=function(){return"[AlphaMapFilter]"},b._applyFilter=function(a){if(!this.alphaMap)return!0;if(!this._prepAlphaMap())return!1;for(var b=a.data,c=this._mapData,d=0,e=b.length;e>d;d+=4)b[d+3]=c[d]||0;return!0},b._prepAlphaMap=function(){if(!this.alphaMap)return!1;if(this.alphaMap==this._alphaMap&&this._mapData)return!0;this._mapData=null;var a,b=this._alphaMap=this.alphaMap,c=b;b instanceof HTMLCanvasElement?a=c.getContext("2d"):(c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"),c.width=b.width,c.height=b.height,a=c.getContext("2d"),a.drawImage(b,0,0));try{var d=a.getImageData(0,0,b.width,b.height)}catch(e){return!1}return this._mapData=d.data,!0},createjs.AlphaMapFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.Filter_constructor(),this.mask=a,this.usesContext=!0,this.FRAG_SHADER_BODY="uniform sampler2D uAlphaSampler;void main(void) {vec4 color = texture2D(uSampler, vRenderCoord);vec4 alphaMap = texture2D(uAlphaSampler, vTextureCoord);gl_FragColor = vec4(color.rgb, color.a * alphaMap.a);}"}var b=createjs.extend(a,createjs.Filter);b.shaderParamSetup=function(a,b,c){this._mapTexture||(this._mapTexture=a.createTexture()),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this._mapTexture),b.setTextureParams(a),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,this.mask),a.uniform1i(a.getUniformLocation(c,"uAlphaSampler"),1)},b.applyFilter=function(a,b,c,d,e,f,g,h){return this.mask?(f=f||a,null==g&&(g=b),null==h&&(h=c),f.save(),a!=f?!1:(f.globalCompositeOperation="destination-in",f.drawImage(this.mask,g,h),f.restore(),!0)):!0},b.clone=function(){return new a(this.mask)},b.toString=function(){return"[AlphaMaskFilter]"},createjs.AlphaMaskFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d,e,f,g,h){this.Filter_constructor(),this.redMultiplier=null!=a?a:1,this.greenMultiplier=null!=b?b:1,this.blueMultiplier=null!=c?c:1,this.alphaMultiplier=null!=d?d:1,this.redOffset=e||0,this.greenOffset=f||0,this.blueOffset=g||0,this.alphaOffset=h||0,this.FRAG_SHADER_BODY="uniform vec4 uColorMultiplier;uniform vec4 uColorOffset;void main(void) {vec4 color = texture2D(uSampler, vRenderCoord);gl_FragColor = (color * uColorMultiplier) + uColorOffset;}"}var b=createjs.extend(a,createjs.Filter);b.shaderParamSetup=function(a,b,c){a.uniform4f(a.getUniformLocation(c,"uColorMultiplier"),this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier),a.uniform4f(a.getUniformLocation(c,"uColorOffset"),this.redOffset/255,this.greenOffset/255,this.blueOffset/255,this.alphaOffset/255)},b.toString=function(){return"[ColorFilter]"},b.clone=function(){return new a(this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier,this.redOffset,this.greenOffset,this.blueOffset,this.alphaOffset)},b._applyFilter=function(a){for(var b=a.data,c=b.length,d=0;c>d;d+=4)b[d]=b[d]*this.redMultiplier+this.redOffset,b[d+1]=b[d+1]*this.greenMultiplier+this.greenOffset,b[d+2]=b[d+2]*this.blueMultiplier+this.blueOffset,b[d+3]=b[d+3]*this.alphaMultiplier+this.alphaOffset;return!0},createjs.ColorFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c,d){this.setColor(a,b,c,d)}var b=a.prototype;a.DELTA_INDEX=[0,.01,.02,.04,.05,.06,.07,.08,.1,.11,.12,.14,.15,.16,.17,.18,.2,.21,.22,.24,.25,.27,.28,.3,.32,.34,.36,.38,.4,.42,.44,.46,.48,.5,.53,.56,.59,.62,.65,.68,.71,.74,.77,.8,.83,.86,.89,.92,.95,.98,1,1.06,1.12,1.18,1.24,1.3,1.36,1.42,1.48,1.54,1.6,1.66,1.72,1.78,1.84,1.9,1.96,2,2.12,2.25,2.37,2.5,2.62,2.75,2.87,3,3.2,3.4,3.6,3.8,4,4.3,4.7,4.9,5,5.5,6,6.5,6.8,7,7.3,7.5,7.8,8,8.4,8.7,9,9.4,9.6,9.8,10],a.IDENTITY_MATRIX=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],a.LENGTH=a.IDENTITY_MATRIX.length,b.setColor=function(a,b,c,d){return this.reset().adjustColor(a,b,c,d)},b.reset=function(){return this.copy(a.IDENTITY_MATRIX)},b.adjustColor=function(a,b,c,d){return this.adjustHue(d),this.adjustContrast(b),this.adjustBrightness(a),this.adjustSaturation(c)},b.adjustBrightness=function(a){return 0==a||isNaN(a)?this:(a=this._cleanValue(a,255),this._multiplyMatrix([1,0,0,0,a,0,1,0,0,a,0,0,1,0,a,0,0,0,1,0,0,0,0,0,1]),this)},b.adjustContrast=function(b){if(0==b||isNaN(b))return this;b=this._cleanValue(b,100);var c;return 0>b?c=127+b/100*127:(c=b%1,c=0==c?a.DELTA_INDEX[b]:a.DELTA_INDEX[b<<0]*(1-c)+a.DELTA_INDEX[(b<<0)+1]*c,c=127*c+127),this._multiplyMatrix([c/127,0,0,0,.5*(127-c),0,c/127,0,0,.5*(127-c),0,0,c/127,0,.5*(127-c),0,0,0,1,0,0,0,0,0,1]),this},b.adjustSaturation=function(a){if(0==a||isNaN(a))return this;a=this._cleanValue(a,100);var b=1+(a>0?3*a/100:a/100),c=.3086,d=.6094,e=.082;return this._multiplyMatrix([c*(1-b)+b,d*(1-b),e*(1-b),0,0,c*(1-b),d*(1-b)+b,e*(1-b),0,0,c*(1-b),d*(1-b),e*(1-b)+b,0,0,0,0,0,1,0,0,0,0,0,1]),this},b.adjustHue=function(a){if(0==a||isNaN(a))return this;a=this._cleanValue(a,180)/180*Math.PI;var b=Math.cos(a),c=Math.sin(a),d=.213,e=.715,f=.072;return this._multiplyMatrix([d+b*(1-d)+c*-d,e+b*-e+c*-e,f+b*-f+c*(1-f),0,0,d+b*-d+.143*c,e+b*(1-e)+.14*c,f+b*-f+c*-.283,0,0,d+b*-d+c*-(1-d),e+b*-e+c*e,f+b*(1-f)+c*f,0,0,0,0,0,1,0,0,0,0,0,1]),this},b.concat=function(b){return b=this._fixMatrix(b),b.length!=a.LENGTH?this:(this._multiplyMatrix(b),this)},b.clone=function(){return(new a).copy(this)},b.toArray=function(){for(var b=[],c=0,d=a.LENGTH;d>c;c++)b[c]=this[c];return b},b.copy=function(b){for(var c=a.LENGTH,d=0;c>d;d++)this[d]=b[d];return this},b.toString=function(){return"[ColorMatrix]"},b._multiplyMatrix=function(a){var b,c,d,e=[];for(b=0;5>b;b++){for(c=0;5>c;c++)e[c]=this[c+5*b];for(c=0;5>c;c++){var f=0;for(d=0;5>d;d++)f+=a[c+5*d]*e[d];this[c+5*b]=f}}},b._cleanValue=function(a,b){return Math.min(b,Math.max(-b,a))},b._fixMatrix=function(b){return b instanceof a&&(b=b.toArray()),b.length<a.LENGTH?b=b.slice(0,b.length).concat(a.IDENTITY_MATRIX.slice(b.length,a.LENGTH)):b.length>a.LENGTH&&(b=b.slice(0,a.LENGTH)),b},createjs.ColorMatrix=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.Filter_constructor(),this.matrix=a,this.FRAG_SHADER_BODY="uniform mat4 uColorMatrix;uniform vec4 uColorMatrixOffset;void main(void) {vec4 color = texture2D(uSampler, vRenderCoord);mat4 m = uColorMatrix;vec4 newColor = vec4(0,0,0,0);newColor.r = color.r*m[0][0] + color.g*m[0][1] + color.b*m[0][2] + color.a*m[0][3];newColor.g = color.r*m[1][0] + color.g*m[1][1] + color.b*m[1][2] + color.a*m[1][3];newColor.b = color.r*m[2][0] + color.g*m[2][1] + color.b*m[2][2] + color.a*m[2][3];newColor.a = color.r*m[3][0] + color.g*m[3][1] + color.b*m[3][2] + color.a*m[3][3];gl_FragColor = newColor + uColorMatrixOffset;}"}var b=createjs.extend(a,createjs.Filter);b.shaderParamSetup=function(a,b,c){var d=this.matrix,e=new Float32Array([d[0],d[1],d[2],d[3],d[5],d[6],d[7],d[8],d[10],d[11],d[12],d[13],d[15],d[16],d[17],d[18]]);a.uniformMatrix4fv(a.getUniformLocation(c,"uColorMatrix"),!1,e),a.uniform4f(a.getUniformLocation(c,"uColorMatrixOffset"),d[4]/255,d[9]/255,d[14]/255,d[19]/255)},b.toString=function(){return"[ColorMatrixFilter]"},b.clone=function(){return new a(this.matrix)},b._applyFilter=function(a){for(var b,c,d,e,f=a.data,g=f.length,h=this.matrix,i=h[0],j=h[1],k=h[2],l=h[3],m=h[4],n=h[5],o=h[6],p=h[7],q=h[8],r=h[9],s=h[10],t=h[11],u=h[12],v=h[13],w=h[14],x=h[15],y=h[16],z=h[17],A=h[18],B=h[19],C=0;g>C;C+=4)b=f[C],c=f[C+1],d=f[C+2],e=f[C+3],f[C]=b*i+c*j+d*k+e*l+m,f[C+1]=b*n+c*o+d*p+e*q+r,f[C+2]=b*s+c*t+d*u+e*v+w,f[C+3]=b*x+c*y+d*z+e*A+B;return!0},createjs.ColorMatrixFilter=createjs.promote(a,"Filter")}(),this.createjs=this.createjs||{},function(){"use strict";function a(){throw"Touch cannot be instantiated"}a.isSupported=function(){return!!("ontouchstart"in window||window.navigator.msPointerEnabled&&window.navigator.msMaxTouchPoints>0||window.navigator.pointerEnabled&&window.navigator.maxTouchPoints>0)},a.enable=function(b,c,d){return b&&b.canvas&&a.isSupported()?b.__touch?!0:(b.__touch={pointers:{},multitouch:!c,preventDefault:!d,count:0},"ontouchstart"in window?a._IOS_enable(b):(window.navigator.msPointerEnabled||window.navigator.pointerEnabled)&&a._IE_enable(b),!0):!1},a.disable=function(b){b&&("ontouchstart"in window?a._IOS_disable(b):(window.navigator.msPointerEnabled||window.navigator.pointerEnabled)&&a._IE_disable(b),delete b.__touch)},a._IOS_enable=function(b){var c=b.canvas,d=b.__touch.f=function(c){a._IOS_handleEvent(b,c)};c.addEventListener("touchstart",d,!1),c.addEventListener("touchmove",d,!1),c.addEventListener("touchend",d,!1),c.addEventListener("touchcancel",d,!1)},a._IOS_disable=function(a){var b=a.canvas;if(b){var c=a.__touch.f;b.removeEventListener("touchstart",c,!1),b.removeEventListener("touchmove",c,!1),b.removeEventListener("touchend",c,!1),b.removeEventListener("touchcancel",c,!1)}},a._IOS_handleEvent=function(a,b){if(a){a.__touch.preventDefault&&b.preventDefault&&b.preventDefault();for(var c=b.changedTouches,d=b.type,e=0,f=c.length;f>e;e++){var g=c[e],h=g.identifier;g.target==a.canvas&&("touchstart"==d?this._handleStart(a,h,b,g.pageX,g.pageY):"touchmove"==d?this._handleMove(a,h,b,g.pageX,g.pageY):("touchend"==d||"touchcancel"==d)&&this._handleEnd(a,h,b))}}},a._IE_enable=function(b){var c=b.canvas,d=b.__touch.f=function(c){a._IE_handleEvent(b,c)};void 0===window.navigator.pointerEnabled?(c.addEventListener("MSPointerDown",d,!1),window.addEventListener("MSPointerMove",d,!1),window.addEventListener("MSPointerUp",d,!1),window.addEventListener("MSPointerCancel",d,!1),b.__touch.preventDefault&&(c.style.msTouchAction="none")):(c.addEventListener("pointerdown",d,!1),window.addEventListener("pointermove",d,!1),window.addEventListener("pointerup",d,!1),window.addEventListener("pointercancel",d,!1),b.__touch.preventDefault&&(c.style.touchAction="none")),b.__touch.activeIDs={}},a._IE_disable=function(a){var b=a.__touch.f;void 0===window.navigator.pointerEnabled?(window.removeEventListener("MSPointerMove",b,!1),window.removeEventListener("MSPointerUp",b,!1),window.removeEventListener("MSPointerCancel",b,!1),a.canvas&&a.canvas.removeEventListener("MSPointerDown",b,!1)):(window.removeEventListener("pointermove",b,!1),window.removeEventListener("pointerup",b,!1),window.removeEventListener("pointercancel",b,!1),a.canvas&&a.canvas.removeEventListener("pointerdown",b,!1))},a._IE_handleEvent=function(a,b){if(a){a.__touch.preventDefault&&b.preventDefault&&b.preventDefault();var c=b.type,d=b.pointerId,e=a.__touch.activeIDs;if("MSPointerDown"==c||"pointerdown"==c){if(b.srcElement!=a.canvas)return;e[d]=!0,this._handleStart(a,d,b,b.pageX,b.pageY)}else e[d]&&("MSPointerMove"==c||"pointermove"==c?this._handleMove(a,d,b,b.pageX,b.pageY):("MSPointerUp"==c||"MSPointerCancel"==c||"pointerup"==c||"pointercancel"==c)&&(delete e[d],this._handleEnd(a,d,b)))}},a._handleStart=function(a,b,c,d,e){var f=a.__touch;if(f.multitouch||!f.count){var g=f.pointers;g[b]||(g[b]=!0,f.count++,a._handlePointerDown(b,c,d,e))}},a._handleMove=function(a,b,c,d,e){a.__touch.pointers[b]&&a._handlePointerMove(b,c,d,e)},a._handleEnd=function(a,b,c){var d=a.__touch,e=d.pointers;e[b]&&(d.count--,a._handlePointerUp(b,c,!0),delete e[b])},createjs.Touch=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=createjs.EaselJS=createjs.EaselJS||{};a.version="1.0.0",a.buildDate="Thu, 14 Sep 2017 19:47:53 GMT"}();
/**
 * Created by Andrewz on 3/7/19.
 */

(function() {
  var p = createjs.DisplayObject.prototype;
  // extended method
  p._matrix = new createjs.Matrix2D();
  p.getWidth = function() {
    return 10;
  };

  p.getHeight = function() {
    return 10;
  };

  p.getCenterX = function() {
    return this.x + this.getWidth() / 2;
  };

  p.getCenterY = function() {
    return this.y + this.getHeight() / 2;
  };

  p.naturalHeight = function() {
    return 0;
  };

  p.naturalWidth = function() {
    return 0;
  };

  /**
 * 是否拥有mouse Handler
 * @param {*} mouseEvents
 * @returns
 */
  p._hasMouseHandler = function(mouseEvents) {
    var listeners = this._listeners;
    return !!(mouseEvents & 1 &&

      (this.onPress || this.onClick || this.onDoubleClick || listeners &&
        (this.hasEventListener("mousedown") || this.hasEventListener("click") ||
          this.hasEventListener("dblclick"))) ||
      mouseEvents & 2 &&
      (this.onMouseOver || this.onMouseOut || this.cursor || listeners &&
        (this.hasEventListener("mouseover") || this.hasEventListener("mouseout"))));
  };
}());

/**
 * Created by Andrewz on 3/7/19.
 */

(function() {
  var p = createjs.Container.prototype;
  var selectBoxSize = 2;
  createjs.DisplayObject._hitTestCanvas.width = createjs.DisplayObject._hitTestCanvas.height = selectBoxSize;
  // 覆盖原函数
  p.setChildIndex = function(child, index) {
    var kids = this.children; var l = kids.length;
    if (child.parent !== this || index < 0 || index >= l) {
      return;
    }
    for (var i = 0; i < l; i++) {
      if (kids[i] === child) {
        break;
      }
    }
    if (i === l || i === index) {
      return;
    }
    kids.splice(i, 1);
    // if (index>i) { index--; }, 不需要, 因为正好要插入到index指定的位置, 绝对位置. 与kids中的内容没有关系
    kids.splice(index, 0, child);
  };

  /**
   * @method _testHitExt
   * @protected
   * @param {CanvasRenderingContext2D} ctx
   * @return {Boolean}
   **/
  p._testHitExt = function(ctx) {
    var hit = false;
    try {
      var pixels = ctx.getImageData(0, 0, selectBoxSize, selectBoxSize).data;
      for (var i = 3; i < pixels.length; i += 4) {
        if (pixels[i] > 1) {
          hit = true;
          break;
        }
      }
    } catch (e) {
      if (!DisplayObject.suppressCrossDomainErrors) {
        TQ.AssertExt.invalidLogic(0, "An error has occurred. This is most likely" +
          "due to security restrictions on reading canvas pixel data with local or cross-domain images.");
      }
    }
    return hit;
  };

  /**
   * @method _getObjectsUnderPoint
   * @param {Number} x
   * @param {Number} y
   * @param {Array} arr
   * @param {Number} mouseEvents A bitmask indicating which event types to look for.
   * Bit 1 specifies press & click & double click,
   * bit 2 specifies it should look for mouse over and mouse out.
   * This implementation may change.
   * @return {Array}
   * @protected
   **/
  p._getObjectsUnderPoint = function(x, y, arr, mouseEvents) {
    var ctx = createjs.DisplayObject._hitTestContext;
    var mtx = this._matrix;
    var hasHandler = this._hasMouseHandler(mouseEvents);
    // 移动到_hitTestContext之canvas的正中间
    x = x - selectBoxSize / 2;
    y = y - selectBoxSize / 2;

    // if we have a cache handy & this has a handler, we can use it to do a quick check.
    // we can't use the cache for screening children, because they might have hitArea set.
    if (!this.hitArea && this.cacheCanvas && hasHandler) {
      this.getConcatenatedMatrix(mtx);
      ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);
      ctx.globalAlpha = mtx.alpha;
      this.draw(ctx);
      if (this._testHitExt(ctx)) {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, selectBoxSize + 1, selectBoxSize + 1);
        return this;
      }
    }

    // draw children one at a time, and check if we get a hit:
    var l = this.children.length;
    for (var i = l - 1; i >= 0; i--) {
      var child = this.children[i];
      var hitArea = child.hitArea;
      if (!child.visible || (!hitArea && !child.isVisible()) || (mouseEvents && !child.mouseEnabled)) {
        continue;
      }
      var childHasHandler = mouseEvents && child._hasMouseHandler(mouseEvents);

      // if a child container has a handler and a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:
      if (child instanceof createjs.Container && !(hitArea && childHasHandler)) {
        var result;
        if (hasHandler) {
          // only concerned about the first hit, because this container is going to claim it anyway:
          result = child._getObjectsUnderPoint(x, y);
          if (result) {
            return this;
          }
        } else {
          result = child._getObjectsUnderPoint(x, y, arr, mouseEvents);
          if (!arr && result) {
            return result;
          }
        }
      } else if (!mouseEvents || hasHandler || childHasHandler) {
        child.getConcatenatedMatrix(mtx);

        if (hitArea) {
          mtx.appendTransform(hitArea.x, hitArea.y, hitArea.scaleX, hitArea.scaleY, hitArea.rotation, hitArea.skewX, hitArea.skewY, hitArea.regX, hitArea.regY);
          mtx.alpha = hitArea.alpha;
        }

        ctx.globalAlpha = mtx.alpha;
        ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);
        (hitArea || child).draw(ctx);
        if (!this._testHitExt(ctx)) {
          continue;
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, selectBoxSize + 1, selectBoxSize + 1);
        if (hasHandler) {
          return this;
        } else if (arr) {
          arr.push(child);
        } else {
          return child;
        }
      }
    }
    return null;
  };
}());

/**
 * Created by Andrewz on 3/7/19.
 */

(function() {
  var p = createjs.Stage.prototype;
  var Stage = createjs.Stage;

  Stage.__debugOn = false;
  // extended method
  p.enableDOMEvents = function(enable) {
    if (enable == null) {
      enable = true;
    }
    var n; var o; var ls = this._eventListeners;
    if (!enable && ls) {
      for (n in ls) {
        o = ls[n];
        o.t.removeEventListener(n, o.f);
      }
      this._eventListeners = null;
    } else if (enable && !ls && this.canvas) {
      var t = window.addEventListener ? window : document;
      var _this = this;
      ls = this._eventListeners = {};
      ls["mouseup"] = {
        t: t, f: function(e) {
          _this._handleMouseUp(e);
        }
      };
      // ls["touchend"] = {t:t, f:function(e) { _this._handleTouchEnd(e)} };
      // ls["touchcancel"] = {t:this.canvas, f:function(e) { _this._handleTouchCancel(e)} };
      ls["mousemove"] = {
        t: t, f: function(e) {
          _this._handleMouseMove(e);
        }
      };
      // ls["touchmove"] = {t:t, f:function(e) { _this._handleTouchMove(e)} };
      ls["dblclick"] = {
        t: t, f: function(e) {
          _this._handleDoubleClick(e);
        }
      };
      ls["mousedown"] = {
        t: this.canvas, f: function(e) {
          _this._handleMouseDown(e);
        }
      };
      ls["touchstart"] = {
        t: this.canvas, f: function(e) {
          _this._handleTouchStart(e);
        }
      };

      for (n in ls) {
        o = ls[n];
        o.t.addEventListener(n, o.f);
      }
    }
  };

  var _isProcessing = false;
  p._handleTouchMove = function(e) {
    if (Stage.__debugOn) {
      console.log("Touch Move");
    }

    if (_isProcessing) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    _isProcessing = true;
    setTimeout(function() {
      _isProcessing = false;
    }, 100); // 最多200ms处理一个event

    if (!e) {
      e = window.event;
    }

    assertNotNull(TQ.Dictionary.INVALID_PARAMETER, e.touches);
    assertNotNull(TQ.Dictionary.INVALID_PARAMETER, e.changedTouches);
    if (e.touches && (e.touches.length >= 1)) {
      var xx = e.touches[0].clientX; // ToDo: 暂时只处理第一个触摸物体
      var yy = e.touches[0].clientY;
      this._handlePointerMove(-1, e, xx, yy);
    }
  };

  /**
   * @method _handlePointerMove
   * @protected
   * @param {Number} id
   * @param {Event} e
   * @param {Number} pageX
   * @param {Number} pageY
   **/
  p._handlePointerMove = function(id, e, pageX, pageY) {
    if (!this.canvas) {
      return;
    } // this.mouseX = this.mouseY = null;
    if (TQ.DitherRemover.isOn()) {
      var smoothXY = TQ.DitherRemover.smooth(pageX, pageY);
      pageX = smoothXY.x;
      pageY = smoothXY.y;
    }
    var evt;
    var o = this._getPointerData(id);

    var inBounds = o.inBounds;
    this._updatePointerPosition(id, pageX, pageY);
    if (!inBounds && !o.inBounds && !this.mouseMoveOutside) {
      return;
    }

    if (this.onMouseMove || this.hasEventListener("stagemousemove")) {
      evt = new createjs.MouseEvent("stagemousemove", o.x, o.y, this, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
      this.onMouseMove && this.onMouseMove(evt);
      this.dispatchEvent(evt);
    }

    var oEvt = o.event;
    if (oEvt && (oEvt.onMouseMove || oEvt.hasEventListener("mousemove"))) {
      evt = new createjs.MouseEvent("mousemove", o.x, o.y, oEvt.target, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
      oEvt.onMouseMove && oEvt.onMouseMove(evt);
      oEvt.dispatchEvent(evt, oEvt.target);
    }

    if (!evt) {
    } else {
      e.preventDefault();
      e.stopPropagation();
    }
  };

  p._handleMouseUp = function(e) {
    if (Stage.__debugOn) {
      console.log("Mouse Up");
    }
    this._handlePointerUp(-1, e, false);
  };

  p._handleTouchEnd = function(e) {
    if (Stage.__debugOn) {
      console.log("Touch End");
    }

    this._handlePointerUp(-1, e, false);
  };

  p._handleTouchCancel = function(e) {
    if (Stage.__debugOn) {
      console.log("Touch Cancel");
    }
    this._handlePointerUp(-1, e, false);
  };

  p._handlePointerUp = function(id, e, clear) {
    var o = this._getPointerData(id);
    var evt;
    TQ.DitherRemover.close();
    if (this.onMouseMove || this.hasEventListener("stagemouseup")) {
      evt = new createjs.MouseEvent("stagemouseup", o.x, o.y, this, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
      this.onMouseUp && this.onMouseUp(evt);
      this.dispatchEvent(evt);
    }

    var oEvt = o.event;
    if (oEvt && (oEvt.onMouseUp || oEvt.hasEventListener("mouseup"))) {
      evt = new createjs.MouseEvent("mouseup", o.x, o.y, oEvt.target, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
      oEvt.onMouseUp && oEvt.onMouseUp(evt);
      oEvt.dispatchEvent(evt, oEvt.target);
    }

    var oTarget = o.target;
    if (oTarget && (oTarget.onClick || oTarget.hasEventListener("click")) && this._getObjectsUnderPoint(o.x, o.y, null, true, (this._mouseOverIntervalID ? 3 : 1)) === oTarget) {
      evt = new createjs.MouseEvent("click", o.x, o.y, oTarget, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
      oTarget.onClick && oTarget.onClick(evt);
      oTarget.dispatchEvent(evt);
    }

    if (clear) {
      if (id === this._primaryPointerID) {
        this._primaryPointerID = null;
      }
      delete (this._pointerData[id]);
    } else {
      o.event = o.target = null;
    }

    if ((!evt) && (!oEvt) && (!oTarget)) {
    } else {
      e.stopPropagation();
      e.preventDefault();
    }
  };

  p._handleTouchStart = function(e) {
    if (Stage.__debugOn) {
      console.log("Touch Start");
    }

    if (_isProcessing) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    _isProcessing = true;
    setTimeout(function() {
      _isProcessing = false;
    }, 1); // 最多200ms处理一个event
    this._handlePointerDown(-1, e, false);
  };

  p._handlePointerDown = function(id, e, x, y) {
    var o = this._getPointerData(id);

    if (e.touches && (e.touches.length >= 1)) {
      x = e.touches[0].pageX;
      y = e.touches[0].pageY;
    }

    if (y != null) {
      TQ.DitherRemover.start(x, y);
      this._updatePointerPosition(id, x, y);
    }

    if (this.onMouseDown || this.hasEventListener("stagemousedown")) {
      var evt = new createjs.MouseEvent("stagemousedown", o.x, o.y, this, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
      this.onMouseDown && this.onMouseDown(evt);
      this.dispatchEvent(evt);
    }

    var target = this._getObjectsUnderPoint(o.x, o.y, null, (this._mouseOverIntervalID ? 3 : 1));
    this._setSelectedItem(target);
    if (target) {
      o.target = target;
      if (target.onPress || target.hasEventListener("mousedown")) {
        evt = new createjs.MouseEvent("mousedown", o.x, o.y, target, e, id, id === this._primaryPointerID, o.rawX, o.rawY);
        target.onPress && target.onPress(evt);
        target.dispatchEvent(evt);

        if (evt.onMouseMove || evt.onMouseUp || evt.hasEventListener("mousemove") || evt.hasEventListener("mouseup")) {
          o.event = evt;
        }
      }
    }

    if ((!evt)) {
    } else {
      e.stopPropagation();
      e.preventDefault();
    }
  };

  p._handleDoubleClick = function(e) {
    var o = this._getPointerData(-1);
    var target = this._getObjectsUnderPoint(o.x, o.y, null, (this._mouseOverIntervalID ? 3 : 1));
    this._setSelectedItem(target);
    if (target && (target.onDoubleClick || target.hasEventListener("dblclick"))) {
      const evt = new createjs.MouseEvent("dblclick", o.x, o.y, target, e, -1, true, o.rawX, o.rawY);
      target.onDoubleClick && target.onDoubleClick(evt);
      target.dispatchEvent(evt);
    }
  };

  p.getObjectsUnderPointer2 = function(e) {
    var o = this._getPointerData(-1);
    var target = this._getObjectsUnderPoint(o.x, o.y, null, (this._mouseOverIntervalID ? 3 : 1));
    this._setSelectedItem(target);
    return target;
  };

  p._setSelectedItem = function(item) {
    if (item == null) {
      this.selectedItem = item;
      this.selectedClipPoint = false;
      return;
    }

    if (item.isClipPoint) {
      this.selectedClipPoint = true;
      return;
    }

    this.selectedItem = item;
  };

  p.selectedItem = null;
  p.selectedClipPoint = false;
}());

/**
 * Created by Andrewz on 3/7/19.
 */

(function() {
  var p = createjs.Bitmap.prototype;
  // extended method
  p.getWidth = function(ignoreScale) {
    //  ���û�и�����, ��JS���� null, ���Զ�תΪfalse
    const scale = (ignoreScale) ? 1 : this.scaleY;
    if (this.sourceRect) {
      return scale * this.sourceRect.width;
    }

    return scale * this.image.naturalWidth;
  };

  p.getHeight = function(ignoreScale) {
    const scale = (ignoreScale) ? 1 : this.scaleY;
    if (this.sourceRect) {
      return scale * this.sourceRect.height;
    }

    return scale * this.image.naturalHeight;
  };

  p.naturalHeight = function() {
    return this.image.naturalHeight;
  };

  p.naturalWidth = function() {
    return this.image.naturalWidth;
  };
}());

/**
 * Created by Andrewz on 3/7/19.
 */

(function() {
  var p = createjs.Text.prototype;
  p.getWidth = function() {
    return this.getMeasuredWidth();
  };

  p.getHeight = function() {
    return this.getMeasuredHeight();
  };

  p.naturalHeight = function() {
    return this.getMeasuredHeight();
  };

  p.naturalWidth = function() {
    return this.getMeasuredWidth();
  };
}());

/**
 * Created by Andrewz on 8/24/2016.
 * Aux, 都是辅助的， 与核心功能无关，无耦合， 可以直接拿去用到第三个产品中
 * 在预览状态下，
 * ** 如果长时间没有用户输入，则 隐去 预览菜单，并开始watch
 * ** 如果有用户输入， 则停止watch，暂停预览，并弹出预览菜单，
 */
var TQ = TQ || {};
TQ.IdleCounter = (function() {
  // 内部成员变量， 必须在return之前定义， 否则无效
  var IDLE_DURATION = 1000; // ms
  var callbacks = [];
  var events = ["click", "keydown", "touchstart", "mousedown"]; var //  'mousemove',  'keyup', 'touchend', 'touchmove', 'mouseup'
    watchDog = null;

  // 接口函数
  return {
    remove: remove,
    start: start,
    stop: stop
  };

  // 所有成员函数， ABC 顺序
  function onWorking(evt) {
    if (watchDog) {
      clearTimeout(watchDog);
    }
    var msg = "evt to end idle: ";
    if (evt) {
      msg += evt.type;
    }
    TQ.Log.debugInfo(msg);
    watchDog = setTimeout(stop, IDLE_DURATION);
  }

  function remove(callback) {
    var id = callbacks.indexOf(callback);
    callbacks.splice(0);
    // callbacks.shift(id);
    stop();
  }

  function start(callback) {
    if (callbacks.indexOf(callback) < 0) {
      callbacks.push(callback);
    }

    if (watchDog) {
      return onWorking();
    }

    events.forEach(function(item) {
      document.addEventListener(item, onWorking, true);
    });

    watchDog = setTimeout(stop, IDLE_DURATION);
  }

  function stop() {
    clearTimeout(watchDog);
    watchDog = null;
    events.forEach(function(item) {
      document.removeEventListener(item, onWorking, true);
    });

    callbacks.forEach(doIt);

    function doIt(item) {
      item.call();
    }
  }
})();

/**
 * Created by Andrewz on 8/12/18.
 * 三种用法：
 * ** 不允许任何操作，
 * ** 只允许操作某个元素：turnOn(元素id)/Off
 * ** 点击任何地方都关闭： startClickOtherPlaceToClose
 */
var TQ = TQ || {};
TQ.OverlayMask = (function() {
  var operations = ["touch", "touchstart", "click"];
  var _isOn = false;
  var _operateElementId;
  var _promptOnClick = null;
  var _onClickToClose = null;

  return {
    isOn: function() { return _isOn; },
    startClickOtherPlaceToClose: startClickOtherPlaceToClose,
    startClickAnywhereToClose: startClickAnywhereToClose,
    turnOn: turnOn,
    turnOff: turnOff
  };

  function turnOn(operateElementId, promptOnClick) {
    _operateElementId = operateElementId;
    _isOn = true;
    _promptOnClick = promptOnClick;
    startClickOtherPlaceToClose(operateElementId);
  }

  function turnOff() {
    _operateElementId = null;
    _isOn = false;
    operations.forEach(function(op) {
      document.removeEventListener(op, onTouch);
    });
  }

  function startClickAnywhereToClose(onClickToClose) {
    return startClickOtherPlaceToClose("no-object-defined", onClickToClose);
  }

  function startClickOtherPlaceToClose(operateElementId, onClickToClose) {
    _operateElementId = operateElementId;
    _onClickToClose = onClickToClose;
    operations.forEach(function(op) {
      document.addEventListener(op, onTouch);
    });
  }

  function onTouch(event) {
    if (event) {
      if (isChildElement(_operateElementId, event.target)) {
        return;
      }

      event.preventDefault();
      if (event.stopPropagation) { // ng broadcast 的event，没有此函数
        event.stopPropagation();
      }
      if (_onClickToClose) {
        turnOff();
        _onClickToClose();
      } else if (_promptOnClick) {
        TQ.MessageBubble.toast(_promptOnClick);
      }
    }
  }

  function isChildElement(elementId, target) {
    for (; target && (target.nodeName !== "BODY"); target = target.parentElement) {
      if (target.id === elementId) {
        return true;
      }
    }

    return false;
  }
})();

/**
 * Created by Andrewz on 4/22/2017.
 */
var TQ = TQ || {};
TQ.Protocol = {
  ERROR: {
    NO: 0,
    DISPLAY_NAME_INVALID_OR_TAKEN: 1,
    NAME_IS_TAKEN: 2,
    NAME_IS_INVALID: 3,
    NAME_IS_INVALID_OR_TAKEN: 4,
    PASSWORD_IS_INVALID_OR_INCORRECT: 5,
    DISPLAY_NAME_INVALID: 6,
    PASSWORD_IS_INVALID: 7
  }
};

/**
 * Created by Andrewz on 1/1/2017.
 */
var TQ = TQ || {};
TQ.Const = {
  SUCCESS: 1,
  FAILED: 0,
  STATUS200: 200,
  STATUS409: 409,

  NO_RECORDING_TRUE: true,
  NO_RECORDING_FALSE: false,
  TOGGLE_RESET: 9999 // toggle模式，
};

/**
 * Created by Andrewz on 11/11/18.
 * const shared between server and client,
 * synced from server to client by deployment tool
 */

var TQ = TQ || {};
TQ.OPUS_STATE = {
  PRIVATE: 10,
  APPLY_TO_PUBLISH: 20, // 必须经过批准才能公开， 防止 出乱子，
  PUBLISHED: 30, //
  FINE: 40, // 优秀作品
  BAN: 70
};

if (typeof exports === "object") {
  exports.OPUS_STATE = TQ.OPUS_STATE;
}

/**
 * Created by Andrewz on 7/9/2016.
 */
var TQ = TQ || {};
TQ.MatType = (function() {
  return {
    // 素材
    BKG: 10, // 'bkgimage',
    PROP: 20, // 'propimage',
    PEOPLE: 30, // 'peopleimage',
    SOUND: 40, //, 'audio';

    // 作品
    OPUS: 90, //  "mywork",
    TOPIC: 91, // 主题
    PUBLISHED_OPUS: 92,
    FINE_OPUS: 93,

    // depreciated
    LOCAL: -1,
    ALBUM: -2,
    CAMERA: -3,
    toEType: function(matType) {
      var eType;
      switch (matType) {
        case TQ.ElementType.GROUP_FILE:
          eType = TQ.ElementType.GROUP_FILE;
          break;
        case TQ.MatType.BKG:
          eType = TQ.Element.ETYPE_BACKGROUND;
          break;
        case TQ.MatType.PROP:
          eType = TQ.Element.ETYPE_PROP;
          break;
        case TQ.MatType.PEOPLE:
          eType = TQ.Element.ETYPE_CHARACTER;
          break;
        case TQ.MatType.SOUND:
          eType = TQ.Element.ETYPE_AUDIO;
          break;
        default:
          TQ.Log.error("未处理的matType！");
          eType = TQ.Element.ETYPE_PROP;
      }
      return eType;
    },
    toElementType: function(matType) {
      var type;
      switch (matType) {
        case TQ.MatType.BKG:
          type = TQ.ElementType.BITMAP;
          break;
        case TQ.MatType.PROP:
          type = TQ.ElementType.BITMAP;
          break;
        case TQ.MatType.PEOPLE:
          type = TQ.ElementType.BITMAP;
          break;
        case TQ.MatType.SOUND:
          type = TQ.ElementType.SOUND;
          break;
        default:
          TQ.Log.error("未处理的matType！");
          type = TQ.ElementType.BITMAP;
      }
      return type;
    }
  };
})();

/**
 * Created by admin on 9/20/2015.
 */
var TQ = TQ || {};

TQ.EVENT = (function() {
  return {
    SYSTEM_ERROR: "system error",
    REFRESH_UI: "refresh_ui", // 通用event， 不属于某个class
    FILE_SYSTEM_READY: "file system ready",
    DIR_READY: "directory ready",
    MAT_CHANGED: "material or opus uploaded (created, updated, or deteled",
    SCENE_TIME_RANGE_CHANGED: "scene animation time range change"
  };
}());

/**
 * Created by admin on 11/3/2015.
 */
var TQ = TQ || {};

(function() {
  function DirtyFlag() {
  }

  DirtyFlag.setEdited = setEdited; // 元素的添加、删除、成组、加关节、TRS等。
  DirtyFlag.setElement = setElement; // 播放的时候， 也可能有位置变化（但是由于时间变化导致的， 非用户操作）
  DirtyFlag.setElementOnly = setElementOnly;
  DirtyFlag.setLevel = setLevel;
  DirtyFlag.setCurrentLevel = setCurrentLevel;
  DirtyFlag.setScene = setAll;
  DirtyFlag.requestToUpdateAll = requestToUpdateAll;

  function setElementOnly(ele) {
    if (ele) {
      ele.dirty = true;
    }
  }

  function setEdited(ele) {
    currScene.hasStaleThumbnail = true;
    setElement(ele, true);
  }

  function setElement(ele, requestDirtyZ) {
    setElementOnly(ele);
    if (currScene) {
      currScene.isDirty = true;
      if (currScene.currentLevel) {
        currScene.currentLevel.isDirty = true;
        if (requestDirtyZ) {
          currScene.currentLevel.isDirtyZ = true;
        }
      }
    }
  }

  function setLevel(level, requestDirtyZ) {
    if (level) {
      level.isDirty = true;
      if (requestDirtyZ) {
        level.isDirtyZ = true;
      }
    }
    currScene.isDirty = true;
  }

  function setCurrentLevel(requestDirtyZ) {
    setLevel(currScene.currentLevel, requestDirtyZ);
  }

  function setAll() {
    return setElement();
  }

  function requestToUpdateAll() {
    if (currScene) {
      currScene.isDirty = true;
      if (currScene.currentLevel) {
        currScene.currentLevel.requestToUpdateAll();
      }
    }
  }

  TQ.DirtyFlag = DirtyFlag;
}());

/**
 * Created by Andrewz on 4/25/2017.
 */
var TQ = TQ || {};
TQ.Locale = (function() {
  "use strict";
  var defaultLang = "en";
  var currentLang = null;
  var fondNewTag = false;
  var dataReady = false;
  var onReadyCallback;
  var dict = {};
  var self = {
    isReady: function() { return dataReady; },
    onReady: onReady,
    getStr: getStr,
    initialize: initialize,
    output: output,
    setLang: setLang
  };

  function onReady(callback) {
    if (dataReady) {
      callback();
    } else {
      onReadyCallback = callback;
    }
  }

  function setLang(lang) {
    if (currentLang && (currentLang === lang)) {
      return;
    }
    var injector = angular.element(document.body).injector();
    if (!injector) {
      return;
    }

    // Convert browser language to internal lauguage:
    switch (lang) {
      case "zh-CN":
      case "zh-TW":
        lang = "zh";
        break;
      case "en":
      default:
        lang = "en";
        break;
    }

    currentLang = lang;
    var $http = injector.get("$http");
    $http({
      method: "GET",
      url: "/dictionary/" + lang + ".json"
    }).then(function onSuccess(response) {
      var data = (response.status === 200) ? response.data : [];
      if (typeof data === "object") {
        dict = data;
        dataReady = true;
        if (onReadyCallback) {
          onReadyCallback();
          onReadyCallback = null;
        }
      } else {
        TQ.AssertExt.invalidLogic(false, "dictionary 文件内容错误");
      }
    });
  }

  function getStr(tag) {
    if (!tag || !dataReady) { // null字串， 或者locale尚未初始化
      return tag;
    }

    TQ.AssertExt.isNotNull(dict);
    const word = tag2Word(tag);
    if (!dict[word]) {
      dict[word] = tag2String(tag);
      console.error("need translation: " + tag);
      fondNewTag = true;
    }

    return dict[word];
  }

  function tag2String(tag) {
    return tag.replace(/-/g, " ");
  }

  function tag2Word(tag) {
    // 字典中的tag，必须是单一word，
    return tag.replace(/ /g, "-");
  }

  function initialize(lang) {
    if (!lang) {
      lang = defaultLang;
    }
    setLang(lang); // 不能立即用， 因为angular的模块尚未inject
  }

  function output() {
    if (!fondNewTag) {
      console.log("new new tag found!");
    } else {
      var sortedKeys = Object.keys(dict).sort();
      var sortedDict = {};
      sortedKeys.forEach(function(key) {
        const word = tag2Word(key);
        sortedDict[word] = dict[key];
        console.log("\"" + word + "\":" + "\"" + sortedDict[word] + "\",");
      });
    }
  }

  return self;
}());

/*
 * 对 谷歌 assert的扩充， 适合于 jsTestDriver
 * 可以比较任意的对象，数组对象， 等等
 * */
// extending ChaiAssert
var TQ = TQ || {};
(function() {
  function AssertExt() {
  }

  AssertExt.depreciated = depreciated;
  AssertExt.invalidLogic = invalidLogic;
  AssertExt.isNotNull = isNotNull;
  AssertExt.isTrue = isTrue;
  AssertExt.expectObject = expectObject;

  function depreciated(name) {
    if (TQ.Config.depreciateCheckOn) {
      TQ.Assert.isTrue(false, "depreciated: " + name);
    }
  }

  function invalidLogic(exp, str) {
    TQ.Assert.isTrue(exp, str + ": " + TQ.Dictionary.INVALID_LOGIC);
  }

  function isNotNull(exp) {
    TQ.Assert.isNotNull(exp, TQ.Dictionary.INVALID_LOGIC);
  }

  function isTrue(exp, msg) {
    TQ.Assert.isTrue(exp, msg);
  }

  function expectObject(exp) {
    TQ.Assert.isNotNull(exp, TQ.Dictionary.FoundNull);
  }

  TQ.AssertExt = AssertExt;
}());

function assertNotHere(msg) {
  return assertTrue(TQ.Dictionary.INVALID_LOGIC + ", " + msg, false);
}

function assertValid(msg, obj) {
  assertNotUndefined(TQ.Dictionary.FoundNull + ": " + msg, obj);
  assertNotNull(msg + "null", obj);
}

function assertDepreciated(name) {
  TQ.AssertExt.depreciated(name);
}

function assertTrue(msg, actual) {
  TQ.Assert.isTrue(actual, msg);
}

function assertFalse(msg, actual) {
  TQ.Assert.isFalse(actual, msg);
}

function assertEquals(msg, expected, actual) {
  TQ.Assert.equal(actual, expected, msg);
}

function assertNotEquals(msg, expected, actual) {
  TQ.Assert.notEqual(actual, expected, msg);
}

function assertNotNull(msg, actual) {
  TQ.Assert.isNotNull(actual, msg);
}

function assertNotUndefined(msg, actual) {
  TQ.Assert.isDefined(actual, msg);
}

function assertEqualsDelta(msg, expected, actual, epsilon) {
  TQ.Assert.closeTo(actual, expected, epsilon, msg);
}

function assertArray(msg, actual) {
  TQ.Assert.isArray(actual, msg);
}

var assert = assertTrue;

(function(f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f(); } else if (typeof define === "function" && define.amd) { define([], f); } else { var g; if (typeof window !== "undefined") { g = window; } else if (typeof global !== "undefined") { g = global; } else if (typeof self !== "undefined") { g = self; } else { g = this; }g.chai = f(); } })(function() {
  var define, module, exports; return (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require === "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f; } var l = n[o] = { exports: {}}; t[o][0].call(l.exports, function(e) { var n = t[o][1][e]; return s(n || e); }, l, l.exports, e, t, n, r); } return n[o].exports; } var i = typeof require === "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s; })({ 1: [function(require, module, exports) {
    module.exports = require("./lib/chai");
  }, { "./lib/chai": 2 }], 2: [function(require, module, exports) {
    /*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var used = [];
    var exports = module.exports = {};

    /*!
 * Chai version
 */

    exports.version = "3.3.0";

    /*!
 * Assertion Error
 */

    exports.AssertionError = require("assertion-error");

    /*!
 * Utils for plugins (not exported)
 */

    var util = require("./chai/utils");

    /**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

    exports.use = function(fn) {
      if (!~used.indexOf(fn)) {
        fn(this, util);
        used.push(fn);
      }

      return this;
    };

    /*!
 * Utility Functions
 */

    exports.util = util;

    /*!
 * Configuration
 */

    var config = require("./chai/config");
    exports.config = config;

    /*!
 * Primary `Assertion` prototype
 */

    var assertion = require("./chai/assertion");
    exports.use(assertion);

    /*!
 * Core Assertions
 */

    var core = require("./chai/core/assertions");
    exports.use(core);

    /*!
 * Expect interface
 */

    var expect = require("./chai/interface/expect");
    exports.use(expect);

    /*!
 * Should interface
 */

    var should = require("./chai/interface/should");
    exports.use(should);

    /*!
 * Assert interface
 */

    var assert = require("./chai/interface/assert");
    exports.use(assert);
  }, { "./chai/assertion": 3, "./chai/config": 4, "./chai/core/assertions": 5, "./chai/interface/assert": 6, "./chai/interface/expect": 7, "./chai/interface/should": 8, "./chai/utils": 21, "assertion-error": 29 }], 3: [function(require, module, exports) {
    /*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var config = require("./config");

    module.exports = function(_chai, util) {
      /*!
   * Module dependencies.
   */

      var AssertionError = _chai.AssertionError;
      var flag = util.flag;

      /*!
   * Module export.
   */

      _chai.Assertion = Assertion;

      /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

      function Assertion(obj, msg, stack) {
        flag(this, "ssfi", stack || arguments.callee);
        flag(this, "object", obj);
        flag(this, "message", msg);
      }

      Object.defineProperty(Assertion, "includeStack", {
        get: function() {
          console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
          return config.includeStack;
        },
        set: function(value) {
          console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
          config.includeStack = value;
        }
      });

      Object.defineProperty(Assertion, "showDiff", {
        get: function() {
          console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
          return config.showDiff;
        },
        set: function(value) {
          console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
          config.showDiff = value;
        }
      });

      Assertion.addProperty = function(name, fn) {
        util.addProperty(this.prototype, name, fn);
      };

      Assertion.addMethod = function(name, fn) {
        util.addMethod(this.prototype, name, fn);
      };

      Assertion.addChainableMethod = function(name, fn, chainingBehavior) {
        util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
      };

      Assertion.overwriteProperty = function(name, fn) {
        util.overwriteProperty(this.prototype, name, fn);
      };

      Assertion.overwriteMethod = function(name, fn) {
        util.overwriteMethod(this.prototype, name, fn);
      };

      Assertion.overwriteChainableMethod = function(name, fn, chainingBehavior) {
        util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
      };

      /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String or Function} message or function that returns message to display if expression fails
   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

      Assertion.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
        var ok = util.test(this, arguments);
        if (showDiff !== true) showDiff = false;
        if (config.showDiff !== true) showDiff = false;

        if (!ok) {
          var msg = util.getMessage(this, arguments);
          var actual = util.getActual(this, arguments);
          // DEBUG_ONLY_BEGIN
          throw new AssertionError(msg, {
            actual: actual,
            expected: expected,
            showDiff: showDiff
          }, (config.includeStack) ? this.assert : flag(this, "ssfi"));
          // DEBUG_ONLY_END
          console.error(msg);
        }
      };

      /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

      Object.defineProperty(Assertion.prototype, "_obj",
        { get: function() {
          return flag(this, "object");
        },
        set: function(val) {
          flag(this, "object", val);
        }
        });
    };
  }, { "./config": 4 }], 4: [function(require, module, exports) {
    module.exports = {

      /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

      includeStack: false,

      /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

      showDiff: true,

      /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

      truncateThreshold: 40

    };
  }, {}], 5: [function(require, module, exports) {
    /*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function(chai, _) {
      var Assertion = chai.Assertion;
      var toString = Object.prototype.toString;
      var flag = _.flag;

      /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

      ["to", "be", "been",
        "is", "and", "has", "have",
        "with", "that", "which", "at",
        "of", "same"].forEach(function(chain) {
        Assertion.addProperty(chain, function() {
          return this;
        });
      });

      /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

      Assertion.addProperty("not", function() {
        flag(this, "negate", true);
      });

      /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @api public
   */

      Assertion.addProperty("deep", function() {
        flag(this, "deep", true);
      });

      /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @api public
   */

      Assertion.addProperty("any", function() {
        flag(this, "any", true);
        flag(this, "all", false);
      });

      /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @api public
   */

      Assertion.addProperty("all", function() {
        flag(this, "all", true);
        flag(this, "any", false);
      });

      /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

      function an(type, msg) {
        if (msg) flag(this, "message", msg);
        type = type.toLowerCase();
        var obj = flag(this, "object");
        var article = ~["a", "e", "i", "o", "u"].indexOf(type.charAt(0)) ? "an " : "a ";

        this.assert(
          type === _.type(obj)
          , "expected #{this} to be " + article + type
          , "expected #{this} not to be " + article + type
        );
      }

      Assertion.addChainableMethod("an", an);
      Assertion.addChainableMethod("a", an);

      /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

      function includeChainingBehavior() {
        flag(this, "contains", true);
      }

      function include(val, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var expected = false;
        if (_.type(obj) === "array" && _.type(val) === "object") {
          for (var i in obj) {
            if (_.eql(obj[i], val)) {
              expected = true;
              break;
            }
          }
        } else if (_.type(val) === "object") {
          if (!flag(this, "negate")) {
            for (var k in val) new Assertion(obj).property(k, val[k]);
            return;
          }
          var subset = {};
          for (var k in val) subset[k] = obj[k];
          expected = _.eql(subset, val);
        } else {
          expected = (obj != undefined) && ~obj.indexOf(val);
        }
        this.assert(
          expected
          , "expected #{this} to include " + _.inspect(val)
          , "expected #{this} to not include " + _.inspect(val));
      }

      Assertion.addChainableMethod("include", include, includeChainingBehavior);
      Assertion.addChainableMethod("contain", include, includeChainingBehavior);
      Assertion.addChainableMethod("contains", include, includeChainingBehavior);
      Assertion.addChainableMethod("includes", include, includeChainingBehavior);

      /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

      Assertion.addProperty("ok", function() {
        this.assert(
          flag(this, "object")
          , "expected #{this} to be truthy"
          , "expected #{this} to be falsy");
      });

      /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

      Assertion.addProperty("true", function() {
        this.assert(
          flag(this, "object") === true
          , "expected #{this} to be true"
          , "expected #{this} to be false"
          , !this.negate
        );
      });

      /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

      Assertion.addProperty("false", function() {
        this.assert(
          flag(this, "object") === false
          , "expected #{this} to be false"
          , "expected #{this} to be true"
          , !!this.negate
        );
      });

      /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @api public
   */

      Assertion.addProperty("null", function() {
        this.assert(
          flag(this, "object") === null
          , "expected #{this} to be null"
          , "expected #{this} not to be null"
        );
      });

      /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

      Assertion.addProperty("undefined", function() {
        this.assert(
          undefined === flag(this, "object")
          , "expected #{this} to be undefined"
          , "expected #{this} not to be undefined"
        );
      });

      /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @api public
   */

      Assertion.addProperty("NaN", function() {
        this.assert(
          isNaN(flag(this, "object"))
          , "expected #{this} to be NaN"
          , "expected #{this} not to be NaN"
        );
      });

      /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

      Assertion.addProperty("exist", function() {
        this.assert(
          flag(this, "object") != null
          , "expected #{this} to exist"
          , "expected #{this} to not exist"
        );
      });

      /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

      Assertion.addProperty("empty", function() {
        this.assert(
          Object.keys(Object(flag(this, "object"))).length === 0
          , "expected #{this} to be empty"
          , "expected #{this} not to be empty"
        );
      });

      /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

      function checkArguments() {
        var obj = flag(this, "object");
        var type = Object.prototype.toString.call(obj);
        this.assert(
          type === "[object Arguments]"
          , "expected #{this} to be arguments but got " + type
          , "expected #{this} to not be arguments"
        );
      }

      Assertion.addProperty("arguments", checkArguments);
      Assertion.addProperty("Arguments", checkArguments);

      /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

      function assertEqual(val, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        if (flag(this, "deep")) {
          return this.eql(val);
        } else {
          this.assert(
            val === obj
            , "expected #{this} to equal #{exp}"
            , "expected #{this} to not equal #{exp}"
            , val
            , this._obj
            , true
          );
        }
      }

      Assertion.addMethod("equal", assertEqual);
      Assertion.addMethod("equals", assertEqual);
      Assertion.addMethod("eq", assertEqual);

      /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

      function assertEql(obj, msg) {
        if (msg) flag(this, "message", msg);
        this.assert(
          _.eql(obj, flag(this, "object"))
          , "expected #{this} to deeply equal #{exp}"
          , "expected #{this} to not deeply equal #{exp}"
          , obj
          , this._obj
          , true
        );
      }

      Assertion.addMethod("eql", assertEql);
      Assertion.addMethod("eqls", assertEql);

      /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

      function assertAbove(n, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        if (flag(this, "doLength")) {
          new Assertion(obj, msg).to.have.property("length");
          var len = obj.length;
          this.assert(
            len > n
            , "expected #{this} to have a length above #{exp} but got #{act}"
            , "expected #{this} to not have a length above #{exp}"
            , n
            , len
          );
        } else {
          this.assert(
            obj > n
            , "expected #{this} to be above " + n
            , "expected #{this} to be at most " + n
          );
        }
      }

      Assertion.addMethod("above", assertAbove);
      Assertion.addMethod("gt", assertAbove);
      Assertion.addMethod("greaterThan", assertAbove);

      /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

      function assertLeast(n, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        if (flag(this, "doLength")) {
          new Assertion(obj, msg).to.have.property("length");
          var len = obj.length;
          this.assert(
            len >= n
            , "expected #{this} to have a length at least #{exp} but got #{act}"
            , "expected #{this} to have a length below #{exp}"
            , n
            , len
          );
        } else {
          this.assert(
            obj >= n
            , "expected #{this} to be at least " + n
            , "expected #{this} to be below " + n
          );
        }
      }

      Assertion.addMethod("least", assertLeast);
      Assertion.addMethod("gte", assertLeast);

      /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

      function assertBelow(n, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        if (flag(this, "doLength")) {
          new Assertion(obj, msg).to.have.property("length");
          var len = obj.length;
          this.assert(
            len < n
            , "expected #{this} to have a length below #{exp} but got #{act}"
            , "expected #{this} to not have a length below #{exp}"
            , n
            , len
          );
        } else {
          this.assert(
            obj < n
            , "expected #{this} to be below " + n
            , "expected #{this} to be at least " + n
          );
        }
      }

      Assertion.addMethod("below", assertBelow);
      Assertion.addMethod("lt", assertBelow);
      Assertion.addMethod("lessThan", assertBelow);

      /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

      function assertMost(n, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        if (flag(this, "doLength")) {
          new Assertion(obj, msg).to.have.property("length");
          var len = obj.length;
          this.assert(
            len <= n
            , "expected #{this} to have a length at most #{exp} but got #{act}"
            , "expected #{this} to have a length above #{exp}"
            , n
            , len
          );
        } else {
          this.assert(
            obj <= n
            , "expected #{this} to be at most " + n
            , "expected #{this} to be above " + n
          );
        }
      }

      Assertion.addMethod("most", assertMost);
      Assertion.addMethod("lte", assertMost);

      /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

      Assertion.addMethod("within", function(start, finish, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var range = start + ".." + finish;
        if (flag(this, "doLength")) {
          new Assertion(obj, msg).to.have.property("length");
          var len = obj.length;
          this.assert(
            len >= start && len <= finish
            , "expected #{this} to have a length within " + range
            , "expected #{this} to not have a length within " + range
          );
        } else {
          this.assert(
            obj >= start && obj <= finish
            , "expected #{this} to be within " + range
            , "expected #{this} to not be within " + range
          );
        }
      });

      /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

      function assertInstanceOf(constructor, msg) {
        if (msg) flag(this, "message", msg);
        var name = _.getName(constructor);
        this.assert(
          flag(this, "object") instanceof constructor
          , "expected #{this} to be an instance of " + name
          , "expected #{this} to not be an instance of " + name
        );
      }

      Assertion.addMethod("instanceof", assertInstanceOf);
      Assertion.addMethod("instanceOf", assertInstanceOf);

      /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

      Assertion.addMethod("property", function(name, val, msg) {
        if (msg) flag(this, "message", msg);

        var isDeep = !!flag(this, "deep");
        var descriptor = isDeep ? "deep property " : "property "
        ; var negate = flag(this, "negate");
        var obj = flag(this, "object");
        var pathInfo = isDeep ? _.getPathInfo(name, obj) : null;
        var hasProperty = isDeep
          ? pathInfo.exists
          : _.hasProperty(name, obj);
        var value = isDeep
          ? pathInfo.value
          : obj[name];

        if (negate && arguments.length > 1) {
          if (undefined === value) {
            msg = (msg != null) ? msg + ": " : "";
            throw new Error(msg + _.inspect(obj) + " has no " + descriptor + _.inspect(name));
          }
        } else {
          this.assert(
            hasProperty
            , "expected #{this} to have a " + descriptor + _.inspect(name)
            , "expected #{this} to not have " + descriptor + _.inspect(name));
        }

        if (arguments.length > 1) {
          this.assert(
            val === value
            , "expected #{this} to have a " + descriptor + _.inspect(name) + " of #{exp}, but got #{act}"
            , "expected #{this} to not have a " + descriptor + _.inspect(name) + " of #{act}"
            , val
            , value
          );
        }

        flag(this, "object", value);
      });

      /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

      function assertOwnProperty(name, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        this.assert(
          obj.hasOwnProperty(name)
          , "expected #{this} to have own property " + _.inspect(name)
          , "expected #{this} to not have own property " + _.inspect(name)
        );
      }

      Assertion.addMethod("ownProperty", assertOwnProperty);
      Assertion.addMethod("haveOwnProperty", assertOwnProperty);

      /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @api public
   */

      function assertOwnPropertyDescriptor(name, descriptor, msg) {
        if (typeof descriptor === "string") {
          msg = descriptor;
          descriptor = null;
        }
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
        if (actualDescriptor && descriptor) {
          this.assert(
            _.eql(descriptor, actualDescriptor)
            , "expected the own property descriptor for " + _.inspect(name) + " on #{this} to match " + _.inspect(descriptor) + ", got " + _.inspect(actualDescriptor)
            , "expected the own property descriptor for " + _.inspect(name) + " on #{this} to not match " + _.inspect(descriptor)
            , descriptor
            , actualDescriptor
            , true
          );
        } else {
          this.assert(
            actualDescriptor
            , "expected #{this} to have an own property descriptor for " + _.inspect(name)
            , "expected #{this} to not have an own property descriptor for " + _.inspect(name)
          );
        }
        flag(this, "object", actualDescriptor);
      }

      Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
      Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);

      /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @api public
   */

      /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

      function assertLengthChain() {
        flag(this, "doLength", true);
      }

      function assertLength(n, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        new Assertion(obj, msg).to.have.property("length");
        var len = obj.length;

        this.assert(
          len == n
          , "expected #{this} to have a length of #{exp} but got #{act}"
          , "expected #{this} to not have a length of #{act}"
          , n
          , len
        );
      }

      Assertion.addChainableMethod("length", assertLength, assertLengthChain);
      Assertion.addMethod("lengthOf", assertLength);

      /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */
      function assertMatch(re, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        this.assert(
          re.exec(obj)
          , "expected #{this} to match " + re
          , "expected #{this} not to match " + re
        );
      }

      Assertion.addMethod("match", assertMatch);
      Assertion.addMethod("matches", assertMatch);

      /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

      Assertion.addMethod("string", function(str, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        new Assertion(obj, msg).is.a("string");

        this.assert(
          ~obj.indexOf(str)
          , "expected #{this} to contain " + _.inspect(str)
          , "expected #{this} to not contain " + _.inspect(str)
        );
      });

      /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {String...|Array|Object} keys
   * @api public
   */

      function assertKeys(keys) {
        var obj = flag(this, "object");
        var str;
        var ok = true;
        var mixedArgsMsg = "keys must be given single argument of Array|Object|String, or multiple String arguments";

        switch (_.type(keys)) {
          case "array":
            if (arguments.length > 1) throw (new Error(mixedArgsMsg));
            break;
          case "object":
            if (arguments.length > 1) throw (new Error(mixedArgsMsg));
            keys = Object.keys(keys);
            break;
          default:
            keys = Array.prototype.slice.call(arguments);
        }

        if (!keys.length) throw new Error("keys required");

        var actual = Object.keys(obj);
        var expected = keys;
        var len = keys.length;
        var any = flag(this, "any");
        var all = flag(this, "all");

        if (!any && !all) {
          all = true;
        }

        // Has any
        if (any) {
          var intersection = expected.filter(function(key) {
            return ~actual.indexOf(key);
          });
          ok = intersection.length > 0;
        }

        // Has all
        if (all) {
          ok = keys.every(function(key) {
            return ~actual.indexOf(key);
          });
          if (!flag(this, "negate") && !flag(this, "contains")) {
            ok = ok && keys.length == actual.length;
          }
        }

        // Key string
        if (len > 1) {
          keys = keys.map(function(key) {
            return _.inspect(key);
          });
          var last = keys.pop();
          if (all) {
            str = keys.join(", ") + ", and " + last;
          }
          if (any) {
            str = keys.join(", ") + ", or " + last;
          }
        } else {
          str = _.inspect(keys[0]);
        }

        // Form
        str = (len > 1 ? "keys " : "key ") + str;

        // Have / include
        str = (flag(this, "contains") ? "contain " : "have ") + str;

        // Assertion
        this.assert(
          ok
          , "expected #{this} to " + str
          , "expected #{this} to not " + str
          , expected.slice(0).sort()
          , actual.sort()
          , true
        );
      }

      Assertion.addMethod("keys", assertKeys);
      Assertion.addMethod("key", assertKeys);

      /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

      function assertThrows(constructor, errMsg, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        new Assertion(obj, msg).is.a("function");

        var thrown = false;
        var desiredError = null;
        var name = null;
        var thrownError = null;

        if (arguments.length === 0) {
          errMsg = null;
          constructor = null;
        } else if (constructor && (constructor instanceof RegExp || typeof constructor === "string")) {
          errMsg = constructor;
          constructor = null;
        } else if (constructor && constructor instanceof Error) {
          desiredError = constructor;
          constructor = null;
          errMsg = null;
        } else if (typeof constructor === "function") {
          name = constructor.prototype.name || constructor.name;
          if (name === "Error" && constructor !== Error) {
            name = (new constructor()).name;
          }
        } else {
          constructor = null;
        }

        try {
          obj();
        } catch (err) {
          // first, check desired error
          if (desiredError) {
            this.assert(
              err === desiredError
              , "expected #{this} to throw #{exp} but #{act} was thrown"
              , "expected #{this} to not throw #{exp}"
              , (desiredError instanceof Error ? desiredError.toString() : desiredError)
              , (err instanceof Error ? err.toString() : err)
            );

            flag(this, "object", err);
            return this;
          }

          // next, check constructor
          if (constructor) {
            this.assert(
              err instanceof constructor
              , "expected #{this} to throw #{exp} but #{act} was thrown"
              , "expected #{this} to not throw #{exp} but #{act} was thrown"
              , name
              , (err instanceof Error ? err.toString() : err)
            );

            if (!errMsg) {
              flag(this, "object", err);
              return this;
            }
          }

          // next, check message
          var message = _.type(err) === "error" && "message" in err
            ? err.message
            : "" + err;

          if ((message != null) && errMsg && errMsg instanceof RegExp) {
            this.assert(
              errMsg.exec(message)
              , "expected #{this} to throw error matching #{exp} but got #{act}"
              , "expected #{this} to throw error not matching #{exp}"
              , errMsg
              , message
            );

            flag(this, "object", err);
            return this;
          } else if ((message != null) && errMsg && typeof errMsg === "string") {
            this.assert(
              ~message.indexOf(errMsg)
              , "expected #{this} to throw error including #{exp} but got #{act}"
              , "expected #{this} to throw error not including #{act}"
              , errMsg
              , message
            );

            flag(this, "object", err);
            return this;
          } else {
            thrown = true;
            thrownError = err;
          }
        }

        var actuallyGot = ""
        ; var expectedThrown = name !== null
          ? name
          : desiredError
            ? "#{exp}" // _.inspect(desiredError)
            : "an error";

        if (thrown) {
          actuallyGot = " but #{act} was thrown";
        }

        this.assert(
          thrown === true
          , "expected #{this} to throw " + expectedThrown + actuallyGot
          , "expected #{this} to not throw " + expectedThrown + actuallyGot
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (thrownError instanceof Error ? thrownError.toString() : thrownError)
        );

        flag(this, "object", thrownError);
      }

      Assertion.addMethod("throw", assertThrows);
      Assertion.addMethod("throws", assertThrows);
      Assertion.addMethod("Throw", assertThrows);

      /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

      function respondTo(method, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var itself = flag(this, "itself");
        var context = (_.type(obj) === "function" && !itself)
          ? obj.prototype[method]
          : obj[method];

        this.assert(
          typeof context === "function"
          , "expected #{this} to respond to " + _.inspect(method)
          , "expected #{this} to not respond to " + _.inspect(method)
        );
      }

      Assertion.addMethod("respondTo", respondTo);
      Assertion.addMethod("respondsTo", respondTo);

      /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

      Assertion.addProperty("itself", function() {
        flag(this, "itself", true);
      });

      /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

      function satisfy(matcher, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");
        var result = matcher(obj);
        this.assert(
          result
          , "expected #{this} to satisfy " + _.objDisplay(matcher)
          , "expected #{this} to not satisfy" + _.objDisplay(matcher)
          , !this.negate
          , result
        );
      }

      Assertion.addMethod("satisfy", satisfy);
      Assertion.addMethod("satisfies", satisfy);

      /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

      Assertion.addMethod("closeTo", function(expected, delta, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");

        new Assertion(obj, msg).is.a("number");
        if (_.type(expected) !== "number" || _.type(delta) !== "number") {
          throw new Error("the arguments to closeTo must be numbers");
        }

        this.assert(
          Math.abs(obj - expected) <= delta
          , "expected #{this} to be close to " + expected + " +/- " + delta
          , "expected #{this} not to be close to " + expected + " +/- " + delta
        );
      });

      function isSubsetOf(subset, superset, cmp) {
        return subset.every(function(elem) {
          if (!cmp) return superset.indexOf(elem) !== -1;

          return superset.some(function(elem2) {
            return cmp(elem, elem2);
          });
        });
      }

      /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

      Assertion.addMethod("members", function(subset, msg) {
        if (msg) flag(this, "message", msg);
        var obj = flag(this, "object");

        new Assertion(obj).to.be.an("array");
        new Assertion(subset).to.be.an("array");

        var cmp = flag(this, "deep") ? _.eql : undefined;

        if (flag(this, "contains")) {
          return this.assert(
            isSubsetOf(subset, obj, cmp)
            , "expected #{this} to be a superset of #{act}"
            , "expected #{this} to not be a superset of #{act}"
            , obj
            , subset
          );
        }

        this.assert(
          isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
          , "expected #{this} to have the same members as #{act}"
          , "expected #{this} to not have the same members as #{act}"
          , obj
          , subset
        );
      });

      /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      function assertChanges(object, prop, msg) {
        if (msg) flag(this, "message", msg);
        var fn = flag(this, "object");
        new Assertion(object, msg).to.have.property(prop);
        new Assertion(fn).is.a("function");

        var initial = object[prop];
        fn();

        this.assert(
          initial !== object[prop]
          , "expected ." + prop + " to change"
          , "expected ." + prop + " to not change"
        );
      }

      Assertion.addChainableMethod("change", assertChanges);
      Assertion.addChainableMethod("changes", assertChanges);

      /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      function assertIncreases(object, prop, msg) {
        if (msg) flag(this, "message", msg);
        var fn = flag(this, "object");
        new Assertion(object, msg).to.have.property(prop);
        new Assertion(fn).is.a("function");

        var initial = object[prop];
        fn();

        this.assert(
          object[prop] - initial > 0
          , "expected ." + prop + " to increase"
          , "expected ." + prop + " to not increase"
        );
      }

      Assertion.addChainableMethod("increase", assertIncreases);
      Assertion.addChainableMethod("increases", assertIncreases);

      /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      function assertDecreases(object, prop, msg) {
        if (msg) flag(this, "message", msg);
        var fn = flag(this, "object");
        new Assertion(object, msg).to.have.property(prop);
        new Assertion(fn).is.a("function");

        var initial = object[prop];
        fn();

        this.assert(
          object[prop] - initial < 0
          , "expected ." + prop + " to decrease"
          , "expected ." + prop + " to not decrease"
        );
      }

      Assertion.addChainableMethod("decrease", assertDecreases);
      Assertion.addChainableMethod("decreases", assertDecreases);

      /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @api public
   */

      Assertion.addProperty("extensible", function() {
        var obj = flag(this, "object");

        // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
        // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
        // The following provides ES6 behavior when a TypeError is thrown under ES5.

        var isExtensible;

        try {
          isExtensible = Object.isExtensible(obj);
        } catch (err) {
          if (err instanceof TypeError) isExtensible = false;
          else throw err;
        }

        this.assert(
          isExtensible
          , "expected #{this} to be extensible"
          , "expected #{this} to not be extensible"
        );
      });

      /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @api public
   */

      Assertion.addProperty("sealed", function() {
        var obj = flag(this, "object");

        // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
        // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
        // The following provides ES6 behavior when a TypeError is thrown under ES5.

        var isSealed;

        try {
          isSealed = Object.isSealed(obj);
        } catch (err) {
          if (err instanceof TypeError) isSealed = true;
          else throw err;
        }

        this.assert(
          isSealed
          , "expected #{this} to be sealed"
          , "expected #{this} to not be sealed"
        );
      });

      /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @api public
   */

      Assertion.addProperty("frozen", function() {
        var obj = flag(this, "object");

        // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
        // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
        // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
        // The following provides ES6 behavior when a TypeError is thrown under ES5.

        var isFrozen;

        try {
          isFrozen = Object.isFrozen(obj);
        } catch (err) {
          if (err instanceof TypeError) isFrozen = true;
          else throw err;
        }

        this.assert(
          isFrozen
          , "expected #{this} to be frozen"
          , "expected #{this} to not be frozen"
        );
      });
    };
  }, {}], 6: [function(require, module, exports) {
    /*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function(chai, util) {
    /*!
   * Chai dependencies.
   */

      var Assertion = chai.Assertion;
      var flag = util.flag;

      /*!
   * Module export.
   */

      /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

      var assert = chai.assert = function(express, errmsg) {
        var test = new Assertion(null, null, chai.assert);
        test.assert(
          express
          , errmsg
          , "[ negation message unavailable ]"
        );
      };

      /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

      assert.fail = function(actual, expected, message, operator) {
        message = message || "assert.fail()";
        // DEBUG_ONLY_BEGIN
        throw new chai.AssertionError(message, {
          actual: actual,
          expected: expected,
          operator: operator
        }, assert.fail);
        // DEBUG_ONLY_END
        console.error(message);
      };

      /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

      assert.isOk = function(val, msg) {
        new Assertion(val, msg).is.ok;
      };

      /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

      assert.isNotOk = function(val, msg) {
        new Assertion(val, msg).is.not.ok;
      };

      /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

      assert.equal = function(act, exp, msg) {
        var test = new Assertion(act, msg, assert.equal);

        test.assert(
          exp == flag(test, "object")
          , "expected #{this} to equal #{exp}"
          , "expected #{this} to not equal #{act}"
          , exp
          , act
        );
      };

      /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

      assert.notEqual = function(act, exp, msg) {
        var test = new Assertion(act, msg, assert.notEqual);

        test.assert(
          exp != flag(test, "object")
          , "expected #{this} to not equal #{exp}"
          , "expected #{this} to equal #{act}"
          , exp
          , act
        );
      };

      /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

      assert.strictEqual = function(act, exp, msg) {
        new Assertion(act, msg).to.equal(exp);
      };

      /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

      assert.notStrictEqual = function(act, exp, msg) {
        new Assertion(act, msg).to.not.equal(exp);
      };

      /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

      assert.deepEqual = function(act, exp, msg) {
        new Assertion(act, msg).to.eql(exp);
      };

      /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

      assert.notDeepEqual = function(act, exp, msg) {
        new Assertion(act, msg).to.not.eql(exp);
      };

      /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @api public
   */

      assert.isAbove = function(val, abv, msg) {
        new Assertion(val, msg).to.be.above(abv);
      };

      /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @api public
   */

      assert.isAtLeast = function(val, atlst, msg) {
        new Assertion(val, msg).to.be.least(atlst);
      };

      /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @api public
   */

      assert.isBelow = function(val, blw, msg) {
        new Assertion(val, msg).to.be.below(blw);
      };

      /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @api public
   */

      assert.isAtMost = function(val, atmst, msg) {
        new Assertion(val, msg).to.be.most(atmst);
      };

      /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isTrue = function(val, msg) {
        new Assertion(val, msg).is["true"];
      };

      /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotTrue = function(val, msg) {
        new Assertion(val, msg).to.not.equal(true);
      };

      /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isFalse = function(val, msg) {
        new Assertion(val, msg).is["false"];
      };

      /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotFalse = function(val, msg) {
        new Assertion(val, msg).to.not.equal(false);
      };

      /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNull = function(val, msg) {
        new Assertion(val, msg).to.equal(null);
      };

      /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotNull = function(val, msg) {
        new Assertion(val, msg).to.not.equal(null);
      };

      /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNaN = function(val, msg) {
        new Assertion(val, msg).to.be.NaN;
      };

      /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */
      assert.isNotNaN = function(val, msg) {
        new Assertion(val, msg).not.to.be.NaN;
      };

      /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isUndefined = function(val, msg) {
        new Assertion(val, msg).to.equal(undefined);
      };

      /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isDefined = function(val, msg) {
        new Assertion(val, msg).to.not.equal(undefined);
      };

      /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isFunction = function(val, msg) {
        new Assertion(val, msg).to.be.a("function");
      };

      /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotFunction = function(val, msg) {
        new Assertion(val, msg).to.not.be.a("function");
      };

      /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isObject = function(val, msg) {
        new Assertion(val, msg).to.be.a("object");
      };

      /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotObject = function(val, msg) {
        new Assertion(val, msg).to.not.be.a("object");
      };

      /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isArray = function(val, msg) {
        new Assertion(val, msg).to.be.an("array");
      };

      /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotArray = function(val, msg) {
        new Assertion(val, msg).to.not.be.an("array");
      };

      /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isString = function(val, msg) {
        new Assertion(val, msg).to.be.a("string");
      };

      /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotString = function(val, msg) {
        new Assertion(val, msg).to.not.be.a("string");
      };

      /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

      assert.isNumber = function(val, msg) {
        new Assertion(val, msg).to.be.a("number");
      };

      /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotNumber = function(val, msg) {
        new Assertion(val, msg).to.not.be.a("number");
      };

      /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isBoolean = function(val, msg) {
        new Assertion(val, msg).to.be.a("boolean");
      };

      /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.isNotBoolean = function(val, msg) {
        new Assertion(val, msg).to.not.be.a("boolean");
      };

      /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

      assert.typeOf = function(val, type, msg) {
        new Assertion(val, msg).to.be.a(type);
      };

      /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

      assert.notTypeOf = function(val, type, msg) {
        new Assertion(val, msg).to.not.be.a(type);
      };

      /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

      assert.instanceOf = function(val, type, msg) {
        new Assertion(val, msg).to.be.instanceOf(type);
      };

      /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

      assert.notInstanceOf = function(val, type, msg) {
        new Assertion(val, msg).to.not.be.instanceOf(type);
      };

      /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

      assert.include = function(exp, inc, msg) {
        new Assertion(exp, msg, assert.include).include(inc);
      };

      /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

      assert.notInclude = function(exp, inc, msg) {
        new Assertion(exp, msg, assert.notInclude).not.include(inc);
      };

      /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

      assert.match = function(exp, re, msg) {
        new Assertion(exp, msg).to.match(re);
      };

      /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

      assert.notMatch = function(exp, re, msg) {
        new Assertion(exp, msg).to.not.match(re);
      };

      /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

      assert.property = function(obj, prop, msg) {
        new Assertion(obj, msg).to.have.property(prop);
      };

      /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

      assert.notProperty = function(obj, prop, msg) {
        new Assertion(obj, msg).to.not.have.property(prop);
      };

      /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

      assert.deepProperty = function(obj, prop, msg) {
        new Assertion(obj, msg).to.have.deep.property(prop);
      };

      /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

      assert.notDeepProperty = function(obj, prop, msg) {
        new Assertion(obj, msg).to.not.have.deep.property(prop);
      };

      /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.propertyVal = function(obj, prop, val, msg) {
        new Assertion(obj, msg).to.have.property(prop, val);
      };

      /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.propertyNotVal = function(obj, prop, val, msg) {
        new Assertion(obj, msg).to.not.have.property(prop, val);
      };

      /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.deepPropertyVal = function(obj, prop, val, msg) {
        new Assertion(obj, msg).to.have.deep.property(prop, val);
      };

      /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

      assert.deepPropertyNotVal = function(obj, prop, val, msg) {
        new Assertion(obj, msg).to.not.have.deep.property(prop, val);
      };

      /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

      assert.lengthOf = function(exp, len, msg) {
        new Assertion(exp, msg).to.have.length(len);
      };

      /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

      assert.throws = function(fn, errt, errs, msg) {
        if (typeof errt === "string" || errt instanceof RegExp) {
          errs = errt;
          errt = null;
        }

        var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
        return flag(assertErr, "object");
      };

      /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

      assert.doesNotThrow = function(fn, type, msg) {
        if (typeof type === "string") {
          msg = type;
          type = null;
        }

        new Assertion(fn, msg).to.not.Throw(type);
      };

      /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

      assert.operator = function(val, operator, val2, msg) {
        var ok;
        switch (operator) {
          case "==":
            ok = val == val2;
            break;
          case "===":
            ok = val === val2;
            break;
          case ">":
            ok = val > val2;
            break;
          case ">=":
            ok = val >= val2;
            break;
          case "<":
            ok = val < val2;
            break;
          case "<=":
            ok = val <= val2;
            break;
          case "!=":
            ok = val != val2;
            break;
          case "!==":
            ok = val !== val2;
            break;
          default:
            throw new Error("Invalid operator \"" + operator + "\"");
        }
        var test = new Assertion(ok, msg);
        test.assert(
          flag(test, "object") === true
          , "expected " + util.inspect(val) + " to be " + operator + " " + util.inspect(val2)
          , "expected " + util.inspect(val) + " to not be " + operator + " " + util.inspect(val2));
      };

      /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

      assert.closeTo = function(act, exp, delta, msg) {
        new Assertion(act, msg).to.be.closeTo(exp, delta);
      };

      /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

      assert.sameMembers = function(set1, set2, msg) {
        new Assertion(set1, msg).to.have.same.members(set2);
      };

      /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

      assert.sameDeepMembers = function(set1, set2, msg) {
        new Assertion(set1, msg).to.have.same.deep.members(set2);
      };

      /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

      assert.includeMembers = function(superset, subset, msg) {
        new Assertion(superset, msg).to.include.members(subset);
      };

      /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      assert.changes = function(fn, obj, prop) {
        new Assertion(fn).to.change(obj, prop);
      };

      /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { TQ.Log.debugInfo('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      assert.doesNotChange = function(fn, obj, prop) {
        new Assertion(fn).to.not.change(obj, prop);
      };

      /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      assert.increases = function(fn, obj, prop) {
        new Assertion(fn).to.increase(obj, prop);
      };

      /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      assert.doesNotIncrease = function(fn, obj, prop) {
        new Assertion(fn).to.not.increase(obj, prop);
      };

      /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      assert.decreases = function(fn, obj, prop) {
        new Assertion(fn).to.decrease(obj, prop);
      };

      /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

      assert.doesNotDecrease = function(fn, obj, prop) {
        new Assertion(fn).to.not.decrease(obj, prop);
      };

      /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @api public
   */

      assert.ifError = function(val) {
        if (val) {
          throw (val);
        }
      };

      /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

      assert.isExtensible = function(obj, msg) {
        new Assertion(obj, msg).to.be.extensible;
      };

      /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

      assert.isNotExtensible = function(obj, msg) {
        new Assertion(obj, msg).to.not.be.extensible;
      };

      /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

      assert.isSealed = function(obj, msg) {
        new Assertion(obj, msg).to.be.sealed;
      };

      /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

      assert.isNotSealed = function(obj, msg) {
        new Assertion(obj, msg).to.not.be.sealed;
      };

      /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

      assert.isFrozen = function(obj, msg) {
        new Assertion(obj, msg).to.be.frozen;
      };

      /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

      assert.isNotFrozen = function(obj, msg) {
        new Assertion(obj, msg).to.not.be.frozen;
      };

      /*!
   * Aliases.
   */

      (function alias(name, as) {
        assert[as] = assert[name];
        return alias;
      })("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen");
    };
  }, {}], 7: [function(require, module, exports) {
    /*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function(chai, util) {
      chai.expect = function(val, message) {
        return new chai.Assertion(val, message);
      };

      /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

      chai.expect.fail = function(actual, expected, message, operator) {
        message = message || "expect.fail()";
        // DEBUG_ONLY_BEGIN
        throw new chai.AssertionError(message, {
          actual: actual,
          expected: expected,
          operator: operator
        }, chai.expect.fail);
        // DEBUG_ONLY_END
        console.error(message);
      };
    };
  }, {}], 8: [function(require, module, exports) {
    /*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    module.exports = function(chai, util) {
      var Assertion = chai.Assertion;

      function loadShould() {
        // explicitly define this method as function as to have it's name to include as `ssfi`
        function shouldGetter() {
          if (this instanceof String || this instanceof Number || this instanceof Boolean) {
            return new Assertion(this.valueOf(), null, shouldGetter);
          }
          return new Assertion(this, null, shouldGetter);
        }
        function shouldSetter(value) {
          // See https://github.com/chaijs/chai/issues/86: this makes
          // `whatever.should = someValue` actually set `someValue`, which is
          // especially useful for `global.should = require('chai').should()`.
          //
          // Note that we have to use [[DefineProperty]] instead of [[Put]]
          // since otherwise we would trigger this very setter!
          Object.defineProperty(this, "should", {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        }
        // modify Object.prototype to have `should`
        Object.defineProperty(Object.prototype, "should", {
          set: shouldSetter,
          get: shouldGetter,
          configurable: true
        });

        var should = {};

        /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @api public
     */

        should.fail = function(actual, expected, message, operator) {
          message = message || "should.fail()";
          // DEBUG_ONLY_BEGIN
          throw new chai.AssertionError(message, {
            actual: actual,
            expected: expected,
            operator: operator
          }, should.fail);
          // DEBUG_ONLY_END
          console.error(message);
        };

        should.equal = function(val1, val2, msg) {
          new Assertion(val1, msg).to.equal(val2);
        };

        should.Throw = function(fn, errt, errs, msg) {
          new Assertion(fn, msg).to.Throw(errt, errs);
        };

        should.exist = function(val, msg) {
          new Assertion(val, msg).to.exist;
        };

        // negation
        should.not = {};

        should.not.equal = function(val1, val2, msg) {
          new Assertion(val1, msg).to.not.equal(val2);
        };

        should.not.Throw = function(fn, errt, errs, msg) {
          new Assertion(fn, msg).to.not.Throw(errt, errs);
        };

        should.not.exist = function(val, msg) {
          new Assertion(val, msg).to.not.exist;
        };

        should["throw"] = should["Throw"];
        should.not["throw"] = should.not["Throw"];

        return should;
      }

      chai.should = loadShould;
      chai.Should = loadShould;
    };
  }, {}], 9: [function(require, module, exports) {
    /*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Module dependencies
 */

    var transferFlags = require("./transferFlags");
    var flag = require("./flag");
    var config = require("../config");

    /*!
 * Module variables
 */

    // Check whether `__proto__` is supported
    var hasProtoSupport = "__proto__" in Object;

    // Without `__proto__` support, this module will need to add properties to a function.
    // However, some Function.prototype methods cannot be overwritten,
    // and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
    var excludeNames = /^(?:length|name|arguments|caller)$/;

    // Cache `Function` properties
    var call = Function.prototype.call;
    var apply = Function.prototype.apply;

    /**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

    module.exports = function(ctx, name, method, chainingBehavior) {
      if (typeof chainingBehavior !== "function") {
        chainingBehavior = function() { };
      }

      var chainableBehavior = {
        method: method,
        chainingBehavior: chainingBehavior
      };

      // save the methods so we can overwrite them later, if we need to.
      if (!ctx.__methods) {
        ctx.__methods = {};
      }
      ctx.__methods[name] = chainableBehavior;

      Object.defineProperty(ctx, name,
        { get: function() {
          chainableBehavior.chainingBehavior.call(this);

          var assert = function assert() {
            var old_ssfi = flag(this, "ssfi");
            if (old_ssfi && config.includeStack === false) { flag(this, "ssfi", assert); }
            var result = chainableBehavior.method.apply(this, arguments);
            return result === undefined ? this : result;
          };

          // Use `__proto__` if available
          if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
            var prototype = assert.__proto__ = Object.create(this);
            // Restore the `call` and `apply` methods from `Function`
            prototype.call = call;
            prototype.apply = apply;
          }
          // Otherwise, redefine all properties (slow!)
          else {
            var asserterNames = Object.getOwnPropertyNames(ctx);
            asserterNames.forEach(function(asserterName) {
              if (!excludeNames.test(asserterName)) {
                var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
                Object.defineProperty(assert, asserterName, pd);
              }
            });
          }

          transferFlags(this, assert);
          return assert;
        },
        configurable: true
        });
    };
  }, { "../config": 4, "./flag": 12, "./transferFlags": 28 }], 10: [function(require, module, exports) {
    /*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var config = require("../config");

    /**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
    var flag = require("./flag");

    module.exports = function(ctx, name, method) {
      ctx[name] = function() {
        var old_ssfi = flag(this, "ssfi");
        if (old_ssfi && config.includeStack === false) { flag(this, "ssfi", ctx[name]); }
        var result = method.apply(this, arguments);
        return result === undefined ? this : result;
      };
    };
  }, { "../config": 4, "./flag": 12 }], 11: [function(require, module, exports) {
    /*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var config = require("../config");
    var flag = require("./flag");

    /**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

    module.exports = function(ctx, name, getter) {
      Object.defineProperty(ctx, name,
        { get: function addProperty() {
          var old_ssfi = flag(this, "ssfi");
          if (old_ssfi && config.includeStack === false) { flag(this, "ssfi", addProperty); }

          var result = getter.call(this);
          return result === undefined ? this : result;
        },
        configurable: true
        });
    };
  }, { "../config": 4, "./flag": 12 }], 12: [function(require, module, exports) {
    /*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

    module.exports = function(obj, key, value) {
      var flags = obj.__flags || (obj.__flags = Object.create(null));
      if (arguments.length === 3) {
        flags[key] = value;
      } else {
        return flags[key];
      }
    };
  }, {}], 13: [function(require, module, exports) {
    /*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

    module.exports = function(obj, args) {
      return args.length > 4 ? args[4] : obj._obj;
    };
  }, {}], 14: [function(require, module, exports) {
    /*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

    module.exports = function getEnumerableProperties(object) {
      var result = [];
      for (var name in object) {
        result.push(name);
      }
      return result;
    };
  }, {}], 15: [function(require, module, exports) {
    /*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Module dependancies
 */

    var flag = require("./flag");
    var getActual = require("./getActual");
    var inspect = require("./inspect");
    var objDisplay = require("./objDisplay");

    /**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

    module.exports = function(obj, args) {
      var negate = flag(obj, "negate");
      var val = flag(obj, "object");
      var expected = args[3];
      var actual = getActual(obj, args);
      var msg = negate ? args[2] : args[1];
      var flagMsg = flag(obj, "message");

      if (typeof msg === "function") msg = msg();
      msg = msg || "";
      msg = msg
        .replace(/#{this}/g, objDisplay(val))
        .replace(/#{act}/g, objDisplay(actual))
        .replace(/#{exp}/g, objDisplay(expected));

      return flagMsg ? flagMsg + ": " + msg : msg;
    };
  }, { "./flag": 12, "./getActual": 13, "./inspect": 22, "./objDisplay": 23 }], 16: [function(require, module, exports) {
    /*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

    module.exports = function(func) {
      if (func.name) return func.name;

      var match = /^\s?function ([^(]*)\(/.exec(func);
      return match && match[1] ? match[1] : "";
    };
  }, {}], 17: [function(require, module, exports) {
    /*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var hasProperty = require("./hasProperty");

    /**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @name getPathInfo
 * @api public
 */

    module.exports = function getPathInfo(path, obj) {
      var parsed = parsePath(path);
      var last = parsed[parsed.length - 1];

      var info = {
        parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
        name: last.p || last.i,
        value: _getPathValue(parsed, obj)
      };
      info.exists = hasProperty(info.name, info.parent);

      return info;
    };

    /*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

    function parsePath(path) {
      var str = path.replace(/([^\\])\[/g, "$1.[");
      var parts = str.match(/(\\\.|[^.]+?)+/g);
      return parts.map(function(value) {
        var re = /^\[(\d+)\]$/;
        var mArr = re.exec(value);
        if (mArr) return { i: parseFloat(mArr[1]) };
        else return { p: value.replace(/\\([.\[\]])/g, "$1") };
      });
    }

    /*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

    function _getPathValue(parsed, obj, index) {
      var tmp = obj;
      var res;

      index = (index === undefined ? parsed.length : index);

      for (var i = 0, l = index; i < l; i++) {
        var part = parsed[i];
        if (tmp) {
          if (typeof part.p !== "undefined") { tmp = tmp[part.p]; } else if (typeof part.i !== "undefined") { tmp = tmp[part.i]; }
          if (i == (l - 1)) res = tmp;
        } else {
          res = undefined;
        }
      }
      return res;
    }
  }, { "./hasProperty": 20 }], 18: [function(require, module, exports) {
    /*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

    var getPathInfo = require("./getPathInfo");

    /**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */
    module.exports = function(path, obj) {
      var info = getPathInfo(path, obj);
      return info.value;
    };
  }, { "./getPathInfo": 17 }], 19: [function(require, module, exports) {
    /*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

    module.exports = function getProperties(object) {
      var result = Object.getOwnPropertyNames(object);

      function addProperty(property) {
        if (result.indexOf(property) === -1) {
          result.push(property);
        }
      }

      var proto = Object.getPrototypeOf(object);
      while (proto !== null) {
        Object.getOwnPropertyNames(proto).forEach(addProperty);
        proto = Object.getPrototypeOf(proto);
      }

      return result;
    };
  }, {}], 20: [function(require, module, exports) {
    /*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    var type = require("type-detect");

    /**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @name getPathInfo
 * @api public
 */

    var literals = {
      "number": Number,
      "string": String
    };

    module.exports = function hasProperty(name, obj) {
      var ot = type(obj);

      // Bad Object, obviously no props at all
      if (ot === "null" || ot === "undefined") { return false; }

      // The `in` operator does not work with certain literals
      // box these before the check
      if (literals[ot] && typeof obj !== "object") { obj = new literals[ot](obj); }

      return name in obj;
    };
  }, { "type-detect": 34 }], 21: [function(require, module, exports) {
    /*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Main exports
 */

    var exports = module.exports = {};

    /*!
 * test utility
 */

    exports.test = require("./test");

    /*!
 * type utility
 */

    exports.type = require("type-detect");

    /*!
 * message utility
 */

    exports.getMessage = require("./getMessage");

    /*!
 * actual utility
 */

    exports.getActual = require("./getActual");

    /*!
 * Inspect util
 */

    exports.inspect = require("./inspect");

    /*!
 * Object Display util
 */

    exports.objDisplay = require("./objDisplay");

    /*!
 * Flag utility
 */

    exports.flag = require("./flag");

    /*!
 * Flag transferring utility
 */

    exports.transferFlags = require("./transferFlags");

    /*!
 * Deep equal utility
 */

    exports.eql = require("deep-eql");

    /*!
 * Deep path value
 */

    exports.getPathValue = require("./getPathValue");

    /*!
 * Deep path info
 */

    exports.getPathInfo = require("./getPathInfo");

    /*!
 * Check if a property exists
 */

    exports.hasProperty = require("./hasProperty");

    /*!
 * Function name
 */

    exports.getName = require("./getName");

    /*!
 * add Property
 */

    exports.addProperty = require("./addProperty");

    /*!
 * add Method
 */

    exports.addMethod = require("./addMethod");

    /*!
 * overwrite Property
 */

    exports.overwriteProperty = require("./overwriteProperty");

    /*!
 * overwrite Method
 */

    exports.overwriteMethod = require("./overwriteMethod");

    /*!
 * Add a chainable method
 */

    exports.addChainableMethod = require("./addChainableMethod");

    /*!
 * Overwrite chainable method
 */

    exports.overwriteChainableMethod = require("./overwriteChainableMethod");
  }, { "./addChainableMethod": 9, "./addMethod": 10, "./addProperty": 11, "./flag": 12, "./getActual": 13, "./getMessage": 15, "./getName": 16, "./getPathInfo": 17, "./getPathValue": 18, "./hasProperty": 20, "./inspect": 22, "./objDisplay": 23, "./overwriteChainableMethod": 24, "./overwriteMethod": 25, "./overwriteProperty": 26, "./test": 27, "./transferFlags": 28, "deep-eql": 30, "type-detect": 34 }], 22: [function(require, module, exports) {
    // This is (almost) directly from Node.js utils
    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

    var getName = require("./getName");
    var getProperties = require("./getProperties");
    var getEnumerableProperties = require("./getEnumerableProperties");

    module.exports = inspect;

    /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
    function inspect(obj, showHidden, depth, colors) {
      var ctx = {
        showHidden: showHidden,
        seen: [],
        stylize: function(str) { return str; }
      };
      return formatValue(ctx, obj, (typeof depth === "undefined" ? 2 : depth));
    }

    // Returns true if object is a DOM element.
    var isDOMElement = function(object) {
      if (typeof HTMLElement === "object") {
        return object instanceof HTMLElement;
      } else {
        return object &&
      typeof object === "object" &&
      object.nodeType === 1 &&
      typeof object.nodeName === "string";
      }
    };

    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (value && typeof value.inspect === "function" &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes);
        if (typeof ret !== "string") {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // If this is a DOM element, try to get the outer HTML.
      if (isDOMElement(value)) {
        if ("outerHTML" in value) {
          return value.outerHTML;
          // This value does not have an outerHTML attribute,
          //   it could still be an XML element
        } else {
          // Attempt to serialize it
          try {
            if (document.xmlVersion) {
              var xmlSerializer = new XMLSerializer();
              return xmlSerializer.serializeToString(value);
            } else {
              // Firefox 11- do not support outerHTML
              //   It does, however, support innerHTML
              //   Use the following to render the element
              var ns = "http://www.w3.org/1999/xhtml";
              var container = document.createElementNS(ns, "_");

              container.appendChild(value.cloneNode(false));
              html = container.innerHTML
                .replace("><", ">" + value.innerHTML + "<");
              container.innerHTML = "";
              return html;
            }
          } catch (err) {
            // This could be a non-native DOM implementation,
            //   continue with the normal flow:
            //   printing the element as if it is an object.
          }
        }
      }

      // Look up the keys of the object.
      var visibleKeys = getEnumerableProperties(value);
      var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

      // Some type of object without properties can be shortcutted.
      // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
      // a `stack` plus `description` property; ignore those for consistency.
      if (keys.length === 0 || (isError(value) && (
        (keys.length === 1 && keys[0] === "stack") ||
      (keys.length === 2 && keys[0] === "description" && keys[1] === "stack")
      ))) {
        if (typeof value === "function") {
          var name = getName(value);
          var nameSuffix = name ? ": " + name : "";
          return ctx.stylize("[Function" + nameSuffix + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toUTCString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = ""; var array = false; var braces = ["{", "}"];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }

      // Make functions say that they are functions
      if (typeof value === "function") {
        var name = getName(value);
        var nameSuffix = name ? ": " + name : "";
        base = " [Function" + nameSuffix + "]";
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        return formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      switch (typeof value) {
        case "undefined":
          return ctx.stylize("undefined", "undefined");

        case "string":
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "")
            .replace(/'/g, "\\'")
            .replace(/\\"/g, "\"") + "'";
          return ctx.stylize(simple, "string");

        case "number":
          if (value === 0 && (1 / value) === -Infinity) {
            return ctx.stylize("-0", "number");
          }
          return ctx.stylize("" + value, "number");

        case "boolean":
          return ctx.stylize("" + value, "boolean");
      }
      // For some reason typeof null is "object", so special case here.
      if (value === null) {
        return ctx.stylize("null", "null");
      }
    }

    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (Object.prototype.hasOwnProperty.call(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
      }
      if (visibleKeys.indexOf(key) < 0) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, value[key], null);
          } else {
            str = formatValue(ctx, value[key], recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (typeof name === "undefined") {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'")
            .replace(/\\"/g, "\"")
            .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }

      return name + ": " + str;
    }

    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
           (base === "" ? "" : base + "\n ") +
           " " +
           output.join(",\n  ") +
           " " +
           braces[1];
      }

      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar) ||
         (typeof ar === "object" && objectToString(ar) === "[object Array]");
    }

    function isRegExp(re) {
      return typeof re === "object" && objectToString(re) === "[object RegExp]";
    }

    function isDate(d) {
      return typeof d === "object" && objectToString(d) === "[object Date]";
    }

    function isError(e) {
      return typeof e === "object" && objectToString(e) === "[object Error]";
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }, { "./getEnumerableProperties": 14, "./getName": 16, "./getProperties": 19 }], 23: [function(require, module, exports) {
    /*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Module dependancies
 */

    var inspect = require("./inspect");
    var config = require("../config");

    /**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

    module.exports = function(obj) {
      var str = inspect(obj);
      var type = Object.prototype.toString.call(obj);

      if (config.truncateThreshold && str.length >= config.truncateThreshold) {
        if (type === "[object Function]") {
          return !obj.name || obj.name === ""
            ? "[Function]"
            : "[Function: " + obj.name + "]";
        } else if (type === "[object Array]") {
          return "[ Array(" + obj.length + ") ]";
        } else if (type === "[object Object]") {
          var keys = Object.keys(obj);
          var kstr = keys.length > 2
            ? keys.splice(0, 2).join(", ") + ", ..."
            : keys.join(", ");
          return "{ Object (" + kstr + ") }";
        } else {
          return str;
        }
      } else {
        return str;
      }
    };
  }, { "../config": 4, "./inspect": 22 }], 24: [function(require, module, exports) {
    /*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

    module.exports = function(ctx, name, method, chainingBehavior) {
      var chainableBehavior = ctx.__methods[name];

      var _chainingBehavior = chainableBehavior.chainingBehavior;
      chainableBehavior.chainingBehavior = function() {
        var result = chainingBehavior(_chainingBehavior).call(this);
        return result === undefined ? this : result;
      };

      var _method = chainableBehavior.method;
      chainableBehavior.method = function() {
        var result = method(_method).apply(this, arguments);
        return result === undefined ? this : result;
      };
    };
  }, {}], 25: [function(require, module, exports) {
    /*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

    module.exports = function(ctx, name, method) {
      var _method = ctx[name];
      var _super = function() { return this; };

      if (_method && typeof _method === "function") { _super = _method; }

      ctx[name] = function() {
        var result = method(_super).apply(this, arguments);
        return result === undefined ? this : result;
      };
    };
  }, {}], 26: [function(require, module, exports) {
    /*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

    module.exports = function(ctx, name, getter) {
      var _get = Object.getOwnPropertyDescriptor(ctx, name);
      var _super = function() {};

      if (_get && typeof _get.get === "function") { _super = _get.get; }

      Object.defineProperty(ctx, name,
        { get: function() {
          var result = getter(_super).call(this);
          return result === undefined ? this : result;
        },
        configurable: true
        });
    };
  }, {}], 27: [function(require, module, exports) {
    /*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Module dependancies
 */

    var flag = require("./flag");

    /**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

    module.exports = function(obj, args) {
      var negate = flag(obj, "negate");
      var expr = args[0];
      return negate ? !expr : expr;
    };
  }, { "./flag": 12 }], 28: [function(require, module, exports) {
    /*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @name transferFlags
 * @api private
 */

    module.exports = function(assertion, object, includeAll) {
      var flags = assertion.__flags || (assertion.__flags = Object.create(null));

      if (!object.__flags) {
        object.__flags = Object.create(null);
      }

      includeAll = arguments.length === 3 ? includeAll : true;

      for (var flag in flags) {
        if (includeAll ||
        (flag !== "object" && flag !== "ssfi" && flag != "message")) {
          object.__flags[flag] = flags[flag];
        }
      }
    };
  }, {}], 29: [function(require, module, exports) {
    /*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

    /*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

    function exclude() {
      var excludes = [].slice.call(arguments);

      function excludeProps(res, obj) {
        Object.keys(obj).forEach(function(key) {
          if (!~excludes.indexOf(key)) res[key] = obj[key];
        });
      }

      return function extendExclude() {
        var args = [].slice.call(arguments);
        var i = 0;
        var res = {};

        for (; i < args.length; i++) {
          excludeProps(res, args[i]);
        }

        return res;
      };
    }

    /*!
 * Primary Exports
 */

    module.exports = AssertionError;

    /**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

    function AssertionError(message, _props, ssf) {
      var extend = exclude("name", "message", "stack", "constructor", "toJSON");
      var props = extend(_props || {});

      // default values
      this.message = message || "Unspecified AssertionError";
      this.showDiff = false;

      // copy from properties
      for (var key in props) {
        this[key] = props[key];
      }

      // capture stack trace
      ssf = ssf || arguments.callee;
      if (ssf && Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
      } else {
        this.stack = new Error().stack;
      }
    }

    /*!
 * Inherit from Error.prototype
 */

    AssertionError.prototype = Object.create(Error.prototype);

    /*!
 * Statically set name
 */

    AssertionError.prototype.name = "AssertionError";

    /*!
 * Ensure correct constructor
 */

    AssertionError.prototype.constructor = AssertionError;

    /**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

    AssertionError.prototype.toJSON = function(stack) {
      var extend = exclude("constructor", "toJSON", "stack");
      var props = extend({ name: this.name }, this);

      // include stack if exists and not turned off
      if (stack !== false && this.stack) {
        props.stack = this.stack;
      }

      return props;
    };
  }, {}], 30: [function(require, module, exports) {
    module.exports = require("./lib/eql");
  }, { "./lib/eql": 31 }], 31: [function(require, module, exports) {
    /*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Module dependencies
 */

    var type = require("type-detect");

    /*!
 * Buffer.isBuffer browser shim
 */

    var Buffer;
    try { Buffer = require("buffer").Buffer; } catch (ex) {
      Buffer = {};
      Buffer.isBuffer = function() { return false; };
    }

    /*!
 * Primary Export
 */

    module.exports = deepEqual;

    /**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

    function deepEqual(a, b, m) {
      if (sameValue(a, b)) {
        return true;
      } else if (type(a) === "date") {
        return dateEqual(a, b);
      } else if (type(a) === "regexp") {
        return regexpEqual(a, b);
      } else if (Buffer.isBuffer(a)) {
        return bufferEqual(a, b);
      } else if (type(a) === "arguments") {
        return argumentsEqual(a, b, m);
      } else if (!typeEqual(a, b)) {
        return false;
      } else if ((type(a) !== "object" && type(b) !== "object") &&
  (type(a) !== "array" && type(b) !== "array")) {
        return sameValue(a, b);
      } else {
        return objectEqual(a, b, m);
      }
    }

    /*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

    function sameValue(a, b) {
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      return a !== a && b !== b;
    }

    /*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

    function typeEqual(a, b) {
      return type(a) === type(b);
    }

    /*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

    function dateEqual(a, b) {
      if (type(b) !== "date") return false;
      return sameValue(a.getTime(), b.getTime());
    }

    /*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

    function regexpEqual(a, b) {
      if (type(b) !== "regexp") return false;
      return sameValue(a.toString(), b.toString());
    }

    /*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

    function argumentsEqual(a, b, m) {
      if (type(b) !== "arguments") return false;
      a = [].slice.call(a);
      b = [].slice.call(b);
      return deepEqual(a, b, m);
    }

    /*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

    function enumerable(a) {
      var res = [];
      for (var key in a) res.push(key);
      return res;
    }

    /*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

    function iterableEqual(a, b) {
      if (a.length !== b.length) return false;

      var i = 0;
      var match = true;

      for (; i < a.length; i++) {
        if (a[i] !== b[i]) {
          match = false;
          break;
        }
      }

      return match;
    }

    /*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

    function bufferEqual(a, b) {
      if (!Buffer.isBuffer(b)) return false;
      return iterableEqual(a, b);
    }

    /*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

    function isValue(a) {
      return a !== null && a !== undefined;
    }

    /*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

    function objectEqual(a, b, m) {
      if (!isValue(a) || !isValue(b)) {
        return false;
      }

      if (a.prototype !== b.prototype) {
        return false;
      }

      var i;
      if (m) {
        for (i = 0; i < m.length; i++) {
          if ((m[i][0] === a && m[i][1] === b) ||
      (m[i][0] === b && m[i][1] === a)) {
            return true;
          }
        }
      } else {
        m = [];
      }

      try {
        var ka = enumerable(a);
        var kb = enumerable(b);
      } catch (ex) {
        return false;
      }

      ka.sort();
      kb.sort();

      if (!iterableEqual(ka, kb)) {
        return false;
      }

      m.push([a, b]);

      var key;
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], m)) {
          return false;
        }
      }

      return true;
    }
  }, { "buffer": undefined, "type-detect": 32 }], 32: [function(require, module, exports) {
    module.exports = require("./lib/type");
  }, { "./lib/type": 33 }], 33: [function(require, module, exports) {
    /*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Primary Exports
 */

    var exports = module.exports = getType;

    /*!
 * Detectable javascript natives
 */

    var natives = {
      "[object Array]": "array",
      "[object RegExp]": "regexp",
      "[object Function]": "function",
      "[object Arguments]": "arguments",
      "[object Date]": "date"
    };

    /**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

    function getType(obj) {
      var str = Object.prototype.toString.call(obj);
      if (natives[str]) return natives[str];
      if (obj === null) return "null";
      if (obj === undefined) return "undefined";
      if (obj === Object(obj)) return "object";
      return typeof obj;
    }

    exports.Library = Library;

    /**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

    function Library() {
      this.tests = {};
    }

    /**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

    Library.prototype.of = getType;

    /**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

    Library.prototype.define = function(type, test) {
      if (arguments.length === 1) return this.tests[type];
      this.tests[type] = test;
      return this;
    };

    /**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

    Library.prototype.test = function(obj, type) {
      if (type === getType(obj)) return true;
      var test = this.tests[type];

      if (test && getType(test) === "regexp") {
        return test.test(obj);
      } else if (test && getType(test) === "function") {
        return test(obj);
      } else {
        throw new ReferenceError("Type test \"" + type + "\" not defined or invalid.");
      }
    };
  }, {}], 34: [function(require, module, exports) {
    arguments[4][32][0].apply(exports, arguments);
  }, { "./lib/type": 35, "dup": 32 }], 35: [function(require, module, exports) {
    /*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

    /*!
 * Primary Exports
 */

    var exports = module.exports = getType;

    /**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
    var objectTypeRegexp = /^\[object (.*)\]$/;

    function getType(obj) {
      var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
      // Let "new String('')" return 'object'
      if (typeof Promise === "function" && obj instanceof Promise) return "promise";
      // PhantomJS has type "DOMWindow" for null
      if (obj === null) return "null";
      // PhantomJS has type "DOMWindow" for undefined
      if (obj === undefined) return "undefined";
      return type;
    }

    exports.Library = Library;

    /**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

    function Library() {
      if (!(this instanceof Library)) return new Library();
      this.tests = {};
    }

    /**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

    Library.prototype.of = getType;

    /**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

    Library.prototype.define = function(type, test) {
      if (arguments.length === 1) return this.tests[type];
      this.tests[type] = test;
      return this;
    };

    /**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

    Library.prototype.test = function(obj, type) {
      if (type === getType(obj)) return true;
      var test = this.tests[type];

      if (test && getType(test) === "regexp") {
        return test.test(obj);
      } else if (test && getType(test) === "function") {
        return test(obj);
      } else {
        throw new ReferenceError("Type test \"" + type + "\" not defined or invalid.");
      }
    };
  }, {}] }, {}, [1])(1);
});

var TQ = TQ || {};
TQ.Assert = chai.assert;

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * Math库的扩充
 */

window.TQ = window.TQ || {};

(function MathExt() {
  function MathExt() {

  }

  MathExt.clamp = function(v, vmin, vmax) {
    if (v <= vmin) return vmin;
    if (v >= vmax) return vmax;
    return v;
  };
  MathExt.range = MathExt.clamp;

  // 把1-10的规范数字映射到[vmin,vmax]区间，
  MathExt.unifyValue10 = function(v, vmin, vmax) {
    var result = (vmin + v * (vmax - vmin) / 10);
    result = MathExt.clamp(result, vmin, vmax);
    return result;
  };

  MathExt.minZIndex = function(upperEle, ele, z) {
    if ((!ele) || (!ele.hasFlag(TQ.Element.IN_STAGE))) return upperEle;
    if (ele.getZ() >= z) {
      if (!upperEle) {
        upperEle = ele;
      } else if (upperEle.getZ() >= ele.getZ()) {
        upperEle = ele;
      }
    }

    return upperEle;
  };

  MathExt.findUpperBoundary = function(elements, z) {
    var upperEle = null;
    var ele = null;
    for (var i = 0; i < elements.length; i++) {
      ele = elements[i];
      upperEle = MathExt.minZIndex(upperEle, ele, z);
      if (ele.children && (ele.children.length > 0)) {
        var temp = MathExt.findUpperBoundary(ele.children, z);
        upperEle = MathExt.minZIndex(upperEle, temp, z);
      }
    }
    return upperEle;
  };

  /*
    去小数点后面3位有效数字
     */
  MathExt.round2 = function(f) {
    return Math.round(f * 100) / 100;
  };

  MathExt.DEG_TO_RAD = Math.PI / 180;
  MathExt.RAD_TO_DEG = 180 / Math.PI;
  TQ.MathExt = MathExt;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

(function() {
  // 这个构造函数， 应该很少被外面直接调用， 因为是其中的值是没有初始化的。
  //  替代地， 应该用create函数, 直接构造有变换的矩阵
  function Vector2D() {
  }

  var p = Vector2D.prototype = $V([1, 0]);

  Vector2D.create = function(elements) {
    var M = new Vector2D();
    return M.setElements(elements);
  };

  Vector2D.calDirection = function(startP, endP) {
    var direction = Vector2D.create([endP.x - startP.x, endP.y - startP.y]);
    var unitVector = direction.toUnitVector();
    return Vector2D.create(unitVector.elements);
  };

  p.angle360 = function() {
    assertFalse("vector  not 0", ((this.elements[0] === 0) && (this.elements[1] === 0)));
    TQ.AssertExt.invalidLogic(this.elements.length === 2, "必须是2D向量， 不能用齐次坐标");
    var angle = this.angleFrom($V([1, 0])) * TQ.MathExt.RAD_TO_DEG;
    var x = this.elements[0];
    var y = this.elements[1];

    if (y > 0) {
      return angle;
    } else if (y < 0) {
      return (360 - angle);
    } else {
      if (x > 0) {
        return angle;
      } else if (x < 0) {
        return 180;
      }
      assertTrue("vector is 0, has no angle", false);
      return 0; // 即使有错, 也应该返回一个值, 不能悬空; 要纠错,尽可能让程序可以执行.
    }
  };

  p.signFrom = function(vFrom) {
    var A = $V([vFrom.elements[0], vFrom.elements[1], 0]);
    var B = $V([this.elements[0], this.elements[1], 0]);
    var normal = A.cross(B);
    var z = normal.elements[2];
    // sign
    return (z > 0) ? 1 : -1;
  };

  p.angle360From = function(vFrom) {
    // 扩充： 原库是用acos计算角度， 所以， 在[0,180)范围取值。没有负值。i.e. 只管角度的大小，不管方向。
    // 这里用 方向来扩充到 （-180， 180）
    return this.signFrom(vFrom) * TQ.MathExt.RAD_TO_DEG * this.angleFrom(vFrom);
  };

  TQ.Vector2D = Vector2D;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

(function() {
  // 这个构造函数， 应该很少被外面直接调用， 因为是其中的值是没有初始化的。
  //  替代地， 应该用create函数, 直接构造有变换的矩阵
  function Matrix2D() {
  }

  var p = Matrix2D.prototype = $M(
    [1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]);
  Matrix2D.DEG_TO_RAD = Math.PI / 180;
  Matrix2D.create = function(elements) {
    var M = new Matrix2D();
    return M.setElements(elements);
  };

  // 主要函数及其用法：
  //   矩阵相乘， M3 = M1.multiply(M2);
  //   坐标变换： v3  = M1.multiply(v1);
  //   设置参数： 转动thita角的矩阵：  M =Sylvester.Matrix.rotateZ(thita);
  Matrix2D.I = function() {
    return Matrix2D.create([
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ]);
  };

  Matrix2D.translation = function(tx, ty) {
    return Matrix2D.create([
      [1, 0, tx],
      [0, 1, ty],
      [0, 0, 1]
    ]);
  };

  Matrix2D.scale = function(sx, sy) {
    return Matrix2D.create([
      [sx, 0, 0],
      [0, sy, 0],
      [0, 0, 1]
    ]);
  };

  Matrix2D.mirrorX = function() {
    return Matrix2D.scale(1, -1);
  };

  Matrix2D.mirrorY = function() {
    return Matrix2D.scale(-1, 1);
  };
  Matrix2D.mirrorXY = function() {
    return Matrix2D.scale(-1, -1);
  };

  Matrix2D.rotation = function(thita) {
    var radian = (thita == null) ? 0 : (thita * Matrix2D.DEG_TO_RAD);
    var c = Math.cos(radian); var s = Math.sin(radian);
    return Matrix2D.create([
      [c, -s, 0],
      [s, c, 0],
      [0, 0, 1]
    ]);
  };

  Matrix2D.transformation = function(tx, ty, thita, sx, sy) {
    // 这个复合矩阵是按照先比例，再旋转， 最后再平移的顺序推导出来的。 顺序不能变
    // M = Mt * Mr * Ms
    // 理论： 在显示物体的时候， 先把物体在物体坐标系里面缩放，再旋转，最后再平移到世界坐标系里面。
    tx = (tx == null) ? 0 : tx;
    ty = (ty == null) ? 0 : ty;
    sx = (sx == null) ? 1 : sx;
    sy = (sy == null) ? 1 : sy;
    var radian = (thita == null) ? 0 : (thita * Matrix2D.DEG_TO_RAD);
    var c = Math.cos(radian); var s = Math.sin(radian);
    return Matrix2D.create([
      [c * sx, -s * sy, tx],
      [s * sx, c * sy, ty],
      [0, 0, 1]
    ]);
  };

  Matrix2D.angle360 = function(matrix2D) {
    var vec3 = TQ.Vector2D.create([1, 0, 0]); // X轴，忽略其次坐标
    var rotatedVec3 = matrix2D.multiply(vec3);
    var rotatedVec2 = TQ.Vector2D.create([rotatedVec3.elements[0], rotatedVec3.elements[1]]);
    return rotatedVec2.angle360();
  };

  TQ.Matrix2D = Matrix2D;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};
(function() {
  /*
     geoBox是纯几何的边界盒. 不包含图形显示信息
     用于计算元件的缩放
  */
  function GeoBox(host) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, !!host && !host.isVirtualObject());
    // 把Image元素最初的边界盒随物体一起旋转，再计算新的边界盒，
    // 结果是 一个比较大的边界盒
    const pivotX = host.jsonObj.pivotX;
    const pivotY = host.jsonObj.pivotY;
    const w = host.getWidth();
    const h = host.getHeight();
    const x1 = -pivotX * w;
    const y1 = -pivotY * h;
    const x2 = x1 + w;
    const y2 = y1 + h;
    const objPts = [
      { x: x1, y: y1 },
      { x: x2, y: y1 },
      { x: x2, y: y2 },
      { x: x1, y: y2 }];

    for (const i in objPts) {
      objPts[i] = host.object2World(objPts[i]);
    }

    this.xmin = Math.min(Math.min(objPts[0].x, objPts[1].x),
      Math.min(objPts[2].x, objPts[3].x));
    this.xmax = Math.max(Math.max(objPts[0].x, objPts[1].x),
      Math.max(objPts[2].x, objPts[3].x));
    this.ymin = Math.min(Math.min(objPts[0].y, objPts[1].y),
      Math.min(objPts[2].y, objPts[3].y));
    this.ymax = Math.max(Math.max(objPts[0].y, objPts[1].y),
      Math.max(objPts[2].y, objPts[3].y));

    this.w = this.xmax - this.xmin;
    this.h = this.ymax - this.ymin;
    this.xc = (this.xmin + this.xmax) / 2;
    this.yc = (this.ymin + this.ymax) / 2;
  }

  var p = GeoBox.prototype;

  p.combine = function(box) {
    this.xmin = Math.min(this.xmin, box.xmin);
    this.xmax = Math.max(this.xmax, box.xmax);
    this.ymin = Math.min(this.ymin, box.ymin);
    this.ymax = Math.max(this.ymax, box.ymax);
    this.w = this.xmax - this.xmin;
    this.h = this.ymax - this.ymin;
    this.xc = (this.xmin + this.xmax) / 2;
    this.yc = (this.ymin + this.ymax) / 2;
    return this;
  };

  p.getWidth = function() {
    return (this.w);
  };

  p.getHeight = function() {
    return (this.h);
  };

  TQ.GeoBox = GeoBox;
}());

/**
 * Created by Andrewz on 5/28/2016.
 */
TQ.DomUtil = (function() {
  "use strict";
  return {
    createElement: createElement,
    showElements: showElements,
    showElementAsTable: showElementAsTable,
    showElement: showElement,
    closeElements: closeElements,
    closeElement: closeElement,
    hideElements: hideElements,
    hideElement: hideElement,
    createButtonInTableRow: createButtonInTableRow,
    createButtonInTable: createButtonInTable,
    createButton: createButton,

    //
    getElementById: getElementById,
    show: show,
    close: close,
    closeById: closeById,
    showById: showById
  };

  function createElement(parent, tag, id, eleClass) {
    var ele = document.createElement(tag);
    ele.setAttribute("id", id);
    ele.style.visibility = "hidden";

    if (eleClass) {
      ele.className = eleClass;
    }

    if (parent) {
      parent.appendChild(ele);
    }

    return ele;
  }

  function createButton(parent, id, eleClass, text, onClick, onTouchStart) {
    var BUTTON_TAG = "button";
    var ele = createElement(parent, BUTTON_TAG, id, eleClass);
    ele.innerText = text;
    if (onTouchStart) {
      ele.addEventListener("touchstart", onTouchStart, true); // act as soon as captured
    } else if (onClick) {
      ele.addEventListener("click", onClick, true);
    }
    ele.style.display = "inline";
    return ele;
  }

  function createButtonInTable(parent, id, eleClass, text, callback) {
    var cell = createElement(parent, "tr", id + "-cell", null);
    return createButton(cell, id, eleClass, text, callback);
  }

  function createButtonInTableRow(parent, id, eleClass, text, onClick, onTouchStart) {
    var cell = createElement(parent, "td", id + "-cell", null);
    return createButton(cell, id, eleClass, text, onClick, onTouchStart);
  }

  function hideElement(ele) {
    ele.style.visibility = "hidden";
    ele.style.display = "none";
  }

  function hideElements(eles) {
    for (var i = eles.length - 1; i >= 0; i--) {
      hideElement(eles[i]);
    }
  }

  function closeElement(ele) {
    close(ele);
  }

  function close(ele) {
    if (!ele) {
      return;
    }
    ele.style.display = "none";
    ele.style.visibility = "hidden";
    // ele.setAttribute('style', '');
    // ele.style.cssText = '';
  }

  function closeElements(eles) {
    for (var i = eles.length - 1; i >= 0; i--) {
      closeElement(eles[i]);
    }
  }

  function show(ele) {
    if (!ele) {
      return;
    }
    ele.style.display = "block";
    ele.style.visibility = "visible";
  }

  function showElement(ele) {
    show(ele);
  }

  function showElementAsTable(ele) {
    ele.style.visibility = "visible";
    ele.style.display = "table";
  }

  function showElements(eles) {
    for (var i = eles.length - 1; i >= 0; i--) {
      showElement(eles[i]);
    }
  }

  // / TBD
  function getElementById(id) {
    return document.getElementById(id);
  }

  function showById(id) {
    return show(getElementById(id));
  }

  function closeById(id) {
    return close(getElementById(id));
  }
})();

/**
 * Created by Andrewz on 3/13/2017.
 */
/**
 * Tuqiang Game Engine
 * Copyright Tuqiang Tech
 * Created at : 12-11-14 下午12:42
 */
var TQ = TQ || {};

(function() {
  // 状态参数，及其getter、setter都定义在此
  // State中的参数都是实时生成的， 可以覆盖，下次再调入的时候， 可以恢复。
  // 区别: Config中的参数都是预先定义的， 不可以覆盖的
  function State() {
  }

  Object.defineProperty(State, "isPlayOnly", {
    get: function() {
      return TQ.WCY.isPlayOnly;
    },
    set: function(x) {
      TQ.WCY.isPlayOnly = x;
    }
  });

  State.innerWidth = 0;
  State.innerHeight = 0;
  State.bottomBarHeight = 0;
  State.bottomFloatToolHeight = 0;
  State.topBarHeight = 0;
  State.buttonHeight = 0;

  var _levelThumbAtBottom;
  Object.defineProperty(State, "levelThumbAtBottom", {
    get: function() {
      if (typeof _levelThumbAtBottom !== "undefined") {
        return _levelThumbAtBottom;
      } else if (typeof TQUtility !== "undefined" && typeof TQUtility.isPC === "function") {
        _levelThumbAtBottom = !TQUtility.isPC();
        return _levelThumbAtBottom;
      }
      return true;
    }
  });

  State.determineWorkingRegion = determineWorkingRegion;
  State.updateDeviceInfo = updateDeviceInfo;
  State.allowPageTransition = true;
  State.fiexdRootJoint = true; // 关节的根，总是固定的， 不可动的（动态可修改，所以用State，不用Config）
  State.requestToRecordAudio = false;
  Object.defineProperty(State, "isAddMode", {
    get: function() {
      return (State.editorMode === TQ.SceneEditor.MODE.EDIT);
    }
  });

  Object.defineProperty(State, "isRecordingAudioMode", {
    get: function() {
      return (State.requestToRecordAudio &&
          (State.editorMode === TQ.SceneEditor.MODE.EDIT));
    }
  });

  var deviceInfoInitialized = false;
  function determineWorkingRegion() {
    if (!deviceInfoInitialized) {
      updateDeviceInfo();
    }

    // top bar的min-height是 11vmin
    var topBarEle = document.getElementById("id_top_bar");
    var bottomBarEle = document.getElementsByClassName("footer")[0];
    var accompanyToolBarEle = document.getElementsByClassName("cao_icon")[0];
    var buttonEle;
    if (!topBarEle && !bottomBarEle) {
      buttonEle = document.getElementById("id-delete");
      if (!buttonEle) {
        buttonEle = document.getElementsByClassName("button")[0];
      }
      if (buttonEle) {
        State.buttonHeight = TQ.Utility.getCssSize(window.getComputedStyle(buttonEle).height);
      }
      if (isNaN(State.buttonHeight) || !buttonEle) {
        State.buttonHeight = Math.ceil(0.11 * Math.min(State.innerHeight, State.innerWidth));
      }
    } else {
      if (State.isPlayOnly || State.isPlaying || State.isPreviewMode) {

      } else {
        State.buttonHeight = TQ.Utility.getCssSize(window.getComputedStyle(topBarEle).height);
        if (State.levelThumbAtBottom && window.getComputedStyle(bottomBarEle).display !== "none") {
          State.bottomBarHeight = TQ.Utility.getCssSize(window.getComputedStyle(bottomBarEle).height);
        } else {
          State.bottomBarHeight = 0;
        }

        if (accompanyToolBarEle) {
          State.bottomFloatToolHeight = TQ.Utility.getCssSize(window.getComputedStyle(accompanyToolBarEle).height);
        }
      }
    }

    var topBarHeight = (State.isPlayOnly || State.isPlaying || State.isPreviewMode) ? 0 : State.buttonHeight;
    var bottomBarHeight = (State.isPlayOnly || State.isPlaying || State.isPreviewMode || State.isRecordingAudioMode) ? 0 : State.bottomBarHeight;
    var h = State.innerHeight;
    var w = State.innerWidth;
    var designated;

    if (!State.topBarUseZeroHeight) { // ToDo：topBar可以挪到左右两侧，不占用高度，
      // 默认：topbar在顶上，占用height，
      h = h - (topBarHeight + bottomBarHeight);
    }

    designated = !currScene ? TQ.Scene.getDesignatedRegionDefault() : currScene.getDesignatedRegion();
    const scaleMin = Math.min(w / designated.w, h / designated.h);
    TQ.Config.workingRegionWidth = scaleMin * designated.w;
    TQ.Config.workingRegionHeight = scaleMin * designated.h;
    if (TQ.Config.workingRegionHeight > TQ.Config.workingRegionWidth) {
      TQ.Config.orientation = TQ.Config.ORIENTATION_PORTRAIT;
    } else {
      TQ.Config.orientation = TQ.Config.ORIENTATION_LANDSCAPE;
    }

    if (!State.canvasAtTopLeft) {
      TQ.Config.workingRegionX0 = Math.round((State.innerWidth - TQ.Config.workingRegionWidth) / 2);
      TQ.Config.workingRegionY0 = Math.round((State.innerHeight - TQ.Config.workingRegionHeight) / 2);
      TQ.Config.workingRegionY0 += (topBarHeight - (topBarHeight + bottomBarHeight) / 2);
    } else {
      TQ.Config.workingRegionX0 = 0;
      TQ.Config.workingRegionY0 = 0;
    }

    State.bottomBarHeight = bottomBarHeight;
    State.topBarHeight = topBarHeight;
  }

  function updateDeviceInfo() {
    deviceInfoInitialized = true;
    var desktopEle = $(".desktop-ok")[0];
    if (desktopEle) {
      var bodyCss = window.getComputedStyle(desktopEle);
      State.innerWidth = TQ.Utility.getCssSize(bodyCss.width);
      State.innerHeight = TQ.Utility.getCssSize(bodyCss.height);
      if (!State.innerWidth) {
        State.innerWidth = window.innerWidth;
        TQ.AssertExt.invalidLogic(false, "需要设定body的 width");
      }
      if (!State.innerHeight) {
        State.innerHeight = window.innerHeight;
        TQ.AssertExt.invalidLogic(false, "需要设定body的 height");
      }
    } else {
      TQ.AssertExt.invalidLogic(TQ.State.isPlayOnly, "应该先让desktopEle ready");
      State.innerWidth = window.innerWidth;
      State.innerHeight = window.innerHeight;
    }
    return true;
  }
  TQ.QueryParams = {};
  TQ.State = State;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 移动操作器
 */

var TQ = TQ || {};

TQ.Log = (function() {
  var self = {
    CLOSE: 0,
    CRITICAL_LEVEL: 1,
    ERROR_LEVEL: 2, // 代替 assert 的throw
    WARN_LEVEL: 5,
    INFO_LEVEL: 7, // 用于 跟踪调试, 查看软件的执行过程

    upgrade: upgrade,
    alertInfo: alertInfo,
    alertError: alertError,
    checkPoint: checkPoint,
    matrixDebugInfo: matrixDebugInfo,
    tsrDebugInfo: tsrDebugInfo,
    debugInfo: debugInfo,
    depreciated: depreciated,
    warn: warn,
    debugWarn: debugWarn,
    error: error,
    criticalError: criticalError,
    trace: trace,
    setLevel: setLevel,

    open: open,
    close: close
  };

  var logLevel = TQ.Config.LOG_LEVEL;

  function open() { logLevel = self.INFO_LEVEL; }
  function close() { logLevel = self.CLOSE; }
  function setLevel(level) { logLevel = level; }
  function trace(str) { //  只用于跟踪调试, (改info为trace), 不能直接出现在 release版中,
    for (var i = 1; i < arguments.length; i++) {
      str += "," + arguments[i];
    }
    debugInfo(str);
  }

  function criticalError(str) {
    if (logLevel >= self.CRITICAL_LEVEL) {
      for (var i = 1; i < arguments.length; i++) {
        str += "," + arguments[i];
      }
      console.error(str);
    }
  }

  function error(str) {
    if (logLevel >= self.ERROR_LEVEL) {
      for (var i = 1; i < arguments.length; i++) {
        str += "," + arguments[i];
      }
      console.error(str);
    }
  }

  function warn(str) {
    if (logLevel >= self.WARN_LEVEL) {
      for (var i = 1; i < arguments.length; i++) {
        str += "," + arguments[i];
      }
      console.warn(str);
    }
  }

  function debugWarn(str) {
    warn("debug warn: special use case:" + str);
  }

  function depreciated(str) {
    if (TQ.Config.depreciateCheckOn) {
      if (!str) {
        str = "";
      }
      for (var i = 1; i < arguments.length; i++) {
        str += "," + arguments[i];
      }
      error("this is depreciated. " + str);
    }
  }

  function debugInfo(str) {
    if (logLevel >= self.INFO_LEVEL) {
      for (var i = 1; i < arguments.length; i++) {
        str += "," + arguments[i];
      }
      console.info(str);
    }
  }

  function tsrDebugInfo(msg, obj) {
    if (logLevel >= self.INFO_LEVEL) {
      var newMsg = "(" + obj.x.toFixed(2) + "," + obj.y.toFixed(2) + ")";
      if (obj.sx !== undefined && obj.sx != null && !isNaN(obj.sx)) {
        newMsg += " Scale(" + obj.sx.toFixed(2) + "," + obj.sy.toFixed(2) + ")";
      }

      if (obj.rotation !== undefined && obj.rotation != null && !isNaN(obj.rotation)) {
        newMsg += " A:" + obj.rotation.toFixed(2);
      }

      debugInfo(msg + newMsg);
    }
  }

  function matrixDebugInfo(msg, m) {
    if (logLevel >= self.INFO_LEVEL) {
      debugInfo(msg + "matrix translation: " + m.elements[0][2].toFixed(3) + ", " +
                m.elements[1][2].toFixed(3) + " " + m.elements[2][2].toFixed(3));
    }
  }

  function checkPoint(msg) {
    if (logLevel >= self.INFO_LEVEL) {
      debugInfo("checkpoint: " + msg);
    }
  }

  function alertError(str) {
    // 主要是 debug 微信的程序使用
    if (typeof str !== "string") {
      str = JSON.stringify(str);
    }

    for (var i = 1; i < arguments.length; i++) {
      str += "," + arguments[i];
    }

    if (TQ.Config.hasWx && TQ.Config.WX_DEBUG_ENABLED) {
      alert("wx调试__" + str);
    } else {
      error(str);
    }
  }
  function alertInfo(str) {
    // 主要是 debug 微信的程序使用
    if (typeof str !== "string") {
      str = JSON.stringify(str);
    }
    for (var i = 1; i < arguments.length; i++) {
      str += "," + arguments[i];
    }

    if (TQ.Config.hasWx && TQ.Config.WX_DEBUG_ENABLED) {
      alert("wx调试__" + str);
    } else {
      self.info(str);
    }
  }

  function upgrade(str) {
    if (logLevel >= self.ERROR_LEVEL) {
      if (!str) {
        str = "";
      }
      for (var i = 1; i < arguments.length; i++) {
        str += "," + arguments[i];
      }

      console.error("必须升级到：" + str);
    }
  }

  // init
  if (logLevel >= self.INFO_LEVEL) {
    self.info = self.out = function(str) {
      if (logLevel >= self.INFO_LEVEL) {
        for (var i = 1; i < arguments.length; i++) {
          str += "," + arguments[i];
        }
        console.log(str);
      }
    };
  } else {
    self.debugInfo = self.info = self.out = function() {
    };
  }

  return self;
})();

/**
 * Created by Andrewz on 2/26/19.
 */
var TQDebugger = TQDebugger || {};
TQDebugger.Panel = (function() {
  var panel,
    eleLog;
  return {
    init: init,
    open: open,
    close: close,
    logInfo: logInfo
    // addButton: addButton
  };

  function init() {
    if (panel) {
      return;
    }

    var htmlStr = "<button onclick=\"debugger_clear();\">清空</button>" +
      "<button onclick=\"debugger_close();\">关闭</button>" +
      "<div id=\"id-debug-info\"></div>";

    window.debugger_clear = function(method) {
      if (eleLog) {
        eleLog.innerHTML = "";
      }
    };
    window.debugger_close = function() {
      TQDebugger.Panel.close();
    };

    panel = TQ.DomUtility.createElement(document.body, "div", "id-debug-panel", "debug-panel-layer");
    panel.innerHTML = htmlStr;
    TQ.DomUtility.showElement(panel);
    panel.addEventListener("touchstart", onTouchStart, false);
    panel.addEventListener("touchmove", onTouchMove, false);
    var startX; var startY;
    var startTop = TQ.Utility.readLocalStorage("startTop", 200);
    var startLeft = TQ.Utility.readLocalStorage("startLeft", 0);

    panel.style.left = startLeft + "px";
    panel.style.top = startTop + "px";

    function onTouchStart(evt) {
      var touch = evt.touches[0];
      if (touch) {
        startX = touch.clientX;
        startY = touch.clientY;
        startTop = TQ.Utility.getCssSize(panel.style.top);
        startLeft = TQ.Utility.getCssSize(panel.style.left);
      }
    }

    function onTouchMove(evt) {
      var touch = evt.touches[0];
      if (touch) {
        var newLeft = startLeft + (touch.clientX - startX);
        var newTop = startTop + (touch.clientY - startY);
        panel.style.left = newLeft + "px";
        panel.style.top = newTop + "px";
        TQ.Utility.writeLocalStorage("startTop", newTop);
        TQ.Utility.writeLocalStorage("startLeft", newLeft);
      }
    }

    if (!eleLog) {
      eleLog = document.getElementById("id-debug-info");
    }

    // 要显示它？un comment下面的句子：
    close();
  }

  function open() {
    TQ.DomUtility.showElement(panel);
  }

  function close() {
    TQ.DomUtility.hideElement(panel);
  }

  function logInfo(msg) {
    var src = eleLog.innerHTML;
    while (src.length > 400) {
      var pos = src.indexOf("</p>", 20);
      src = src.substr(pos);
    }
    if (eleLog) {
      eleLog.innerHTML = src + "<p>" + msg + "</p>";
    }
  }
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */

/**
 * JS编程的基本工具
 */

window.TQ = window.TQ || {};
TQ = TQ || {};

/**
 * 通用函数：用于定义namespace命名空间
 * @param ns：命名空间字符串， 用句点分割，例如： TQ.Element
 * @return {*}
 */
TQ.namespace = function(ns) {
  var parts = ns.split(".");
  var parent = TQ;
  if (parts[0] === "TQ") {
    parts = parts.slice(1);
  }

  for (let i = 0; i < parts.length; i++) {
    if (typeof parent[parts[i]] === "undefined") {
      parent[parts[i]] = {};
    }
    parent = parent[parts[i]];
  }

  return parent;
};

/**
 * 类定义的实用函数， 用例见： CompositeCommand的定义
 * @type {*}
 */
var inherit = (function() {
  var F = function() {};
  return function(C, P) {
    F.prototype = P.prototype;
    C.prototype = new F();
    C.uber = P.prototype;
    C.prototype.constructor = C;
  };
}());

// 保留6位小数
Math.truncate6 = function(f) {
  return Math.floor(f * 1000000) / 1000000;
};

// 定义常用的宏，     避免使用数字常量
TQ.ERROR = -1;
TQ.inherit = inherit;

/**
 * Tuqiang Game Engine
 * Copyright Tuqiang Tech
 * Created at : 12-11-13 下午7:16
 */
window.TQ = window.TQ || {};

(function() {
  function Utility() {

  }

  var localIdCounter = 0;
  var localIdTimeBase = Date.now();

  Utility.getFilesFromEvent = function(evt) {
    let files = null;
    if (evt) {
      if (evt.currentTarget && evt.currentTarget.files) {
        files = evt.currentTarget.files;
      } else if (evt.target && evt.target.files) {
        files = evt.target.files;
      } else if (evt.srcElement && evt.srcElement.files) {
        files = evt.srcElement.files;
      }
    }
    return files;
  };

  Utility.toCssFont = function(option) {
    // !!! 只接受 合法的 CSS font attribute, ex. "bold 36px Arial"
    // 不能带color
    var result = "";
    if (option.bold) {
      result += "bold ";
    }
    if (option.italic) {
      result += "italic ";
    }
    result += option.fontSize + "px " + option.fontFace;
    return result;
  };

  Utility.fontSize2Level = function(size) {
    return "" + (parseFloat(size) / TQ.Config.FONT_LEVEL_UNIT);
  };

  Utility.getCssSize = function(cssValue) {
    if ((cssValue === "auto") || (!cssValue)) {
      return 0;
    }
    return parseFloat(cssValue.replace("px", ""));
  };

  // 从text的HTML字串中获取tag标签中 attr属性的值
  Utility.extractAttr = function(tag, attr, str, defaultValue) {
    var reg1 = new RegExp("<" + tag + "[^<>]*?\\s" + attr + "=['\"]?(.*?)['\"]?\\s.*?>(.*?)</" + tag + ">");
    var reg2 = new RegExp("<" + tag + "[^<>]*?\\s" + attr + "=['\"]?(.*?)['\"]>(.*?)</" + tag + ">");
    try {
      var values = reg1.exec(str);
      if (values != null) {
        var result = null;
        if (values.length >= 2) result = values[1];
      }

      if ((result == null) || (result === "")) {
        values = reg2.exec(str);
        if (values != null) {
          result = ((values.length >= 2) ? values[1] : defaultValue);
        } else {
          result = defaultValue;
        }
      }
    } catch (e) {
    }
    return result;
  };

  // 从text的HTML字串中获取tag标签的值
  Utility.extractTag = function(tag, str, defaultValue) {
    var reg = new RegExp("<" + tag + "[^<>]*?>(.*?)</" + tag + ">");
    try {
      var values = reg.exec(str);
      if (values != null) {
        return ((values.length >= 2) ? values[1] : defaultValue);
      }
    } catch (e) {
    }
    return defaultValue;
  };

  Utility.forceExt = function(str, newExtension) {
    if (!newExtension) {
      newExtension = TQ.Config.EXTENSION;
    }
    if (str.indexOf(".") > 0) {
      str = (str.substr(0, str.indexOf(".")) + newExtension);
    } else {
      str = (str + newExtension);
    }
    return str;
  };

  Utility.getAudioByThumbnail = function(soundSrc) {
    // ToDo：去除src开头的"."
    soundSrc = soundSrc.replace("./", "/");
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, soundSrc.lastIndexOf("\\") <= 0); // 没有DOS路径符号\\
    var shortName = soundSrc.replace("http://" + TQ.Config.DOMAIN_NAME + "/", "");
    return "http://" + TQ.Config.DOMAIN_NAME + "/" + shortName;
  };

  Utility.getImageByThumbnail = function(thumbnail) {
    var pathToOriginalImg = "mcImages/";
    var pathToThumbnail = "mcThumbs/";
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, thumbnail.lastIndexOf("\\") <= 0); // 没有DOS路径符号\\
    thumbnail = thumbnail.replace("http://" + TQ.Config.DOMAIN_NAME, "");
    return thumbnail.replace(pathToThumbnail, pathToOriginalImg);
  };

  Utility.getComponentByThumbnail = function(thumbnail) {
    var pathToThumbnail = "mcThumbs/";
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, thumbnail.lastIndexOf("\\") <= 0); // 没有DOS路径符号\\
    thumbnail = thumbnail.replace("http://" + TQ.Config.DOMAIN_NAME, "");
    var pos = thumbnail.indexOf(pathToThumbnail) + pathToThumbnail.length;
    var newName = thumbnail.substr(pos);
    var end = newName.lastIndexOf(".");
    if (end <= 0) { // 防止它本身没有带后缀
      end = newName.length;
    }
    return newName.substring(0, end) + TQ.Config.EXTENSION;
  };

  Utility.getSceneByThumbnail = function(thumbnail) {
    return Utility.getComponentByThumbnail(thumbnail);
  };

  // @@ToDo: 显示表达式的字串， 和 文件的行号，
  Utility.assertValid = function(obj) {
    assertNotUndefined(TQ.Dictionary.FoundNull, obj);
    assertNotNull(TQ.Dictionary.FoundNull, obj);
  };

  Utility.getExtension = function(path) {
    var start = path.lastIndexOf(".");
    if (start > 0) {
      return path.substr(start);
    }

    return path;
  };

  // adm: animation for dong man 超市
  Utility.isAnimationDesc = function(url) {
    var formats = [".adm"];
    var str = Utility.getExtension(url).toLowerCase();
    for (var i = 0; i < formats.length; i++) {
      if ((str === formats[i])) {
        return true;
      }
    }
  };

  Utility.isWCY = function(url) {
    var formats = [".wcy"];
    var str = Utility.getExtension(url).toLowerCase();
    for (var i = 0; i < formats.length; i++) {
      if ((str === formats[i])) {
        return true;
      }
    }
  };

  Utility.isVideo = function(url) {
    var formats = [".mp4"];
    var str = Utility.getExtension(url).toLowerCase();
    for (var i = 0; i < formats.length; i++) {
      if ((str === formats[i])) {
        return true;
      }
    }
  };

  Utility.isSoundResource = function(url) {
    var formats = [".wav", ".mp3", ".ogg", ".3gp"]; // 3gp是手机录音结果
    var str = Utility.getExtension(url).toLowerCase();
    for (var i = 0; i < formats.length; i++) {
      if ((str === formats[i])) {
        return true;
      }
    }
    return false;
  };

  Utility.isImage = function(url) {
    var str = Utility.getExtension(url).toLowerCase();
    var formats = [".png", ".jpg", ".bmp", ".gif"];
    for (var i = 0; i < formats.length; i++) {
      if ((str === formats[i])) {
        return true;
      }
    }
    return false;
  };

  Utility.isImageFile = function(file) {
    return ((file instanceof File) && (file.type) && (file.type.indexOf("image") >= 0));
  };

  Utility.isImage64 = function(data) {
    // "data:image/png;base64"
    var headers;
    return ((typeof data === "string") &&
            (headers = data.slice(0, 40)) &&
            (headers.indexOf("data:image/") >= 0) &&
            (headers.indexOf("base64") >= 0));
  };

  Utility.isJSON = function(desc) {
    if (!((desc === undefined) || (desc == null))) {
      if (!((desc.type === undefined) || (desc.type == null))) {
        return true;
      } else if (!((desc.src === undefined) || (desc.src == null))) {
        return true;
      }
    }
    return false;
  };

  Utility.deltaYinWorld = function(target, offset, event) {
    TQ.Log.upgrade("offsetInWorld");
    var deltaYinDevice = (event.stageY + offset.y) - target.y;
    return -deltaYinDevice; // 转到世界坐标系空间。
  };

  Utility.deviceToWorld = function(xDevice, yDevice) {
    return { x: xDevice, y: Utility.toWorldCoord(yDevice) };
  };

  Utility.worldToDevioce = function(xWorld, yWorld) {
    return { x: xWorld, y: Utility.toDeviceCoord(yWorld) };
  };

  Utility.toDeviceCoord = function(worldY) {
    return TQ.Config.workingRegionHeight - worldY;
  };

  Utility.toDeviceRotation = function(worldRotation) {
    return -worldRotation;
  };

  Utility.toWorldCoord = function(canvasY) {
  // 这是Canvas设备的坐标， 不是浏览器整个client区的坐标，在Canvas只占用部分client区域的时候， 有用
  // 而 canvas的height， 就是workingRegionHeight
    return TQ.Config.workingRegionHeight - canvasY;
  };

  Utility.eventToDevice = function(evt) {
    // 因为UDOIDO没有的工作区画布只占用一部分，所有需要从浏览器的stageX,Y坐标转为工作区的device坐标
    return { x: evt.stageX - TQ.Config.workingRegionX0, y: evt.stageY - TQ.Config.workingRegionY0 };
  };

  Utility.canvas2WindowX = function(x) {
    return window.canvas.offsetLeft + x;
  };

  Utility.canvas2WindowY = function(y) {
    return window.canvas.offsetTop + y;
  };

  Utility.toDevicePivot = function(pivotY) {
  // 用户坐标系下（左下角为0,0）的Pivot定义，转为Device坐标系（top, left) 下的pivot 定义

    return 1 - pivotY;
  };

  Utility.readLocalStorage = function(varName, defaultValue) {
    return TQ.Base.Utility.readCache(varName, defaultValue);
  };

  Utility.writeLocalStorage = function(varName, value) {
    TQ.Base.Utility.writeCache(varName, value);
  };

  Utility.getUrlParam = function(param) {
    var request = {
      QueryString: function(val) {
        var uri = window.location.search;
        var re = new RegExp("" + val + "=([^&?]*)", "ig");
        try {
          var value = ((uri.match(re)) ? (decodeURIComponent(uri.match(re)[0]
            .substr(val.length + 1))) : "");
        } catch (e) {
          TQ.Log.criticalError("Error in URL Parameter:" + uri + ":" + e.toString());
          value = "";
        }
        return value;
      }
    };
    return request.QueryString(param);
  };

  Utility.getShareCodeFromUrl = function(url) {
    TQ.Log.depreciated("被parseUrl替代，2019.3以后删除");
    return Utility.parseUrl(url).shareCode;
  };

  function getHashFromUrl(url) {
    var pos = url.indexOf("/#/");
    var hash;
    if (pos < 0) {
      if (url.indexOf("#/") === 0) {
        hash = url;
      } else {
        hash = "";
      }
    } else {
      hash = url.substr(pos + 1);
    }
    return hash;
  }

  function parseUrl(url) {
    var params = {};
    var shareCode = "";
    var hash = (!url) ? window.location.hash : getHashFromUrl(url);
    if (hash) {
      hash = decodeURIComponent(decodeURIComponent(hash));
      var questionMarkPos = hash.indexOf("?");
      var commandStr;
      var queryString;

      if (questionMarkPos >= 0) {
        commandStr = hash.substr(0, questionMarkPos);
        queryString = hash.substr(questionMarkPos + 1);
      } else {
        commandStr = hash;
        queryString = "";
      }

      var words = commandStr.split(/\/|\?/);// 其中[3]是？之后的全部query参数
      if (words[1].toLowerCase() !== "do") { // 新的url
        if (words[2]) {
          shareCode = words[2];
        } // "/#/welcome"
      }

      if (queryString != null && queryString !== "") {
        params = transformToAssocArray(queryString);
        if (!shareCode && params.sc) {
          shareCode = params.sc;
        }
      }
    }

    return { shareCode: shareCode, params: params };
  }

  Utility.getShareCodeCore = function(shareCodeLong) {
    var shareCodeDecoded = decodeURIComponent(decodeURIComponent(shareCodeLong));
    return shareCodeDecoded.split("?")[0];
  };

  function transformToAssocArray(parameters) {
    var params = {};
    var prmarr = parameters.split("&");
    for (var i = 0; i < prmarr.length; i++) {
      var tmparr = prmarr[i].split("=");
      params[tmparr[0]] = tmparr[1];
    }
    return params;
  }

  Utility.isValidWcyId = function(wcyId) {
    return ((typeof wcyId === "number") && wcyId >= 0);
  };

  Utility.getWcyIdFromUrl = function(url) {
    return Utility.shareCode2Id(parseUrl(url).shareCode);
  };

  Utility.wcyId2Url = function(opusId) {
    return TQ.Config.OPUS_HOST + "/#/do?sc=" + Utility.wcyId2ShareCode(opusId);
  };

  Utility.shareCode2Id = function(shareCode) {
    var items = shareCode.split("_");
    if (items.length > 1) {
      return items[1];
    }

    return -1;
  };

  Utility.wcyId2ShareCode = function(id) {
    return ("0_" + id + "_0_0");
  };

  Utility.isFbAvailable = function() {
    var host = window.location.host.toLowerCase();
    return (host.indexOf("udoido.cn") < 0);
  };

  Utility.getUserId = function() {
    var userId = TQ.Init.uid;
    if (userId === "") {
      var userId2 = Utility.readLocalStorage("userId", "");
      if (userId2 !== "") {
        userId = userId2;
      } else {
        userId = TQ.Config.DefaultUserId; // 系统用户
      }
    } else {
      localStorage.setItem("userId", userId);
    }
    return userId;
  };
  Utility.DEV_PC = 0x0001;
  Utility.DEV_PAD = 0x0002;
  Utility.DEV_MOBILE = 0x0004;

  Utility.OS_ANDROID = 0x0010;
  Utility.OS_IPHONE = 0x0020;
  Utility.OS_WINDOWS = 0x0040;
  Utility.OS_MAC = 0x0080;
  Utility.BR_FIREFOX = 0x00100;
  Utility.BR_CHROME = 0x00200;
  Utility.BR_SAFARI = 0x00400;
  Utility.env = 0;
  Utility.setEnv = function(flag) { Utility.env |= flag; };
  Utility.clearEnv = function(flag) { Utility.env &= ~flag; };
  Utility.hasEnv = function(flag) { return Utility.env & flag; };

  Utility.isSupportedEnvironment = function() {
    var supported = false;
    if (ionic.Platform.isAndroid()) {
      Utility.setEnv(Utility.DEV_MOBILE);
      Utility.setEnv(Utility.OS_ANDROID);
      supported = true;
    } else if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
      Utility.setEnv(Utility.DEV_MOBILE);
      Utility.setEnv(Utility.OS_IPHONE);
      supported = true; // false;
    } else {
      Utility.setEnv(Utility.DEV_PC);// or Mac
      Utility.setEnv(Utility.OS_WINDOWS); // or Mac OS
      supported = true; // false;
    }

    if (isChrome()) {
      Utility.setEnv(Utility.BR_CHROME);
      supported = true;
    } else if (isMacSafari()) {
      Utility.setEnv(Utility.BR_SAFARI);
      supported = true;
    }

    return supported;
  };

  function isChrome() {
    // please note,
    // that IE11 now returns undefined again for window.chrome
    // and new Opera 30 outputs true for window.chrome
    // and new IE Edge outputs to true now for window.chrome
    // and if not iOS Chrome check
    // so use the below updated condition
    var isChromium = window.chrome;
    var winNav = window.navigator;
    var vendorName = winNav.vendor;
    var isOpera = winNav.userAgent.indexOf("OPR") > -1;
    var isIEedge = winNav.userAgent.indexOf("Edge") > -1;
    var isIOSChrome = winNav.userAgent.match("CriOS");

    var result = false;
    if (isIOSChrome) { // chrome in IOS
      result = true;
    } else if (isChromium != null && isChromium !== undefined && vendorName === "Google Inc." && isOpera === false && isIEedge === false) {
      result = true;
    } else {
      result = false;
    }

    return result;
    // http://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome/13348618#13348618
  }

  function isMacSafari() {
    var ua = navigator.userAgent.toLowerCase();
    return ((ua.indexOf("mac os x") > -1) &&
        (ua.indexOf("macintosh") > -1) &&
        (ua.indexOf("applewebkit") > -1) &&
        (ua.indexOf("safari") > -1));
  }

  Utility.CheckUserRight = function() {
    var userId = Utility.getUserId();
    // ToDo: 使用数据库
    if ((userId === 10000) || (userId === 10001) || (userId === 10011) || (userId === 10012)) {
      //  $("#tbDelete").button("enable");
    }
  };

  // Utility2:  使用了全局变量
  Utility.getMaxZ = function() {
    // 踩实在
    assertNotNull(currScene, TQ.Dictionary.FoundNull);
    assertNotNull(currScene.currentLevel, TQ.Dictionary.FoundNull);
    if ((!currScene) || (!currScene.currentLevel)) return 0;
    currScene.currentLevel.persist();
    return stageContainer.getNumChildren();
  };

  /*
    touch事件处理
     */

  Utility.isMouseEvent = function(e) {
    return (e instanceof MouseEvent);
  };

  Utility.getTouchNumbers = function(e) {
    return Utility.getTouches(e).length;
  };

  Utility.getTouches = function(e) {
    var touches;
    if (Utility.isMouseEvent(e)) {
      switch (e.type) {
        case "mousemove":
        case "mousedown":
          touches = [e];
          break;
        case "mouseup":
          touches = [];
          break;
        default:
          console.error(e.type + "found unprocessed event!");
      }
    } else if (e.gesture && e.gesture.touches) {
      touches = e.gesture.touches;
    } else if (e.touches) {
      touches = e.touches;
    } else {
      touches = [];
    }

    return touches;
  };

  Utility.isTouchEvent = function(e) {
    var e0 = getNativeEvent(e);
    return (!!e0 && (e0.touches != null) && (e0.changedTouches != null));
  };

  Utility.isMultiTouchEvent = function(e) {
    if (Utility.isTouchEvent(e)) {
      var e0 = getNativeEvent(e);
      return (e0.touches.length >= 2);
    }

    return false;
  };

  var __isTouchDevice = -1;
  Utility.isTouchScreen = function() {
    if (__isTouchDevice === -1) {
      var deviceAgent = navigator.userAgent.toLowerCase();
      __isTouchDevice = Modernizr.touch ||
                (deviceAgent.match(/(iphone|ipod|ipad)/) ||
                    deviceAgent.match(/(android)/) ||
                    deviceAgent.match(/(iemobile)/) ||
                    deviceAgent.match(/iphone/i) ||
                    deviceAgent.match(/ipad/i) ||
                    deviceAgent.match(/ipod/i) ||
                    deviceAgent.match(/blackberry/i) ||
                    deviceAgent.match(/bada/i));
    }

    return __isTouchDevice;
  };

  Utility.getOffsetTop = function(item) {
    if (item.offsetParent) {
      return item.offsetTop + Utility.getOffsetTop(item.offsetParent);
    }
    return item.offsetTop;
  };

  Utility.getOffsetLeft = function(item) {
    if (item.offsetParent) {
      return item.offsetLeft + Utility.getOffsetLeft(item.offsetParent);
    }
    return item.offsetLeft;
  };

  Utility.getDefultActionIcon = function() {
    var DEFAULT_ACTION_ICON = 100; // ToDo： 修改此值，根据实际缺省ICON的ID
    return DEFAULT_ACTION_ICON;
  };

  Utility.equalToZero = function(x) {
    return (Math.abs(x) < 0.000001);
  };

  Utility.equalWithin2 = function(x, y) { // 2位小数点
    return (Math.abs(x - y) < 0.01);
  };

  Utility.equalBoxSize = function(box1, box2) {
    return ((Math.abs(box1.w - box2.w) < 0.01) && (Math.abs(box1.h - box2.h) < 0.01));
  };

  Utility.equalBox = function(box1, box2) {
    return ((Math.abs(box1.x - box2.x) < 0.01) && (Math.abs(box1.y - box2.y) < 0.01) &&
            Utility.equalBoxSize(box1, box2));
  };

  Utility.limitToAcuteAngle = function(angle) {
    var absAngle = Math.abs(angle);
    while (absAngle > 180) {
      if (angle < 0) {
        angle = 360 + angle;
      } else {
        angle = -360 + angle;
      }
      absAngle = Math.abs(angle);
    }

    if (absAngle > 180) {
      console.error("应该是锐角" + angle);
    }

    return angle;
  };

  Utility.limitTo360 = function(angle) {
    if ((angle > 360) || (angle < -360)) {
      angle = (angle % 360);
    }
    return angle;
  };

  Utility.mirror = function(pStart, pEnd) {
    //                  Start--->End
    //   EndMirrored<---Start
    return {
      x: 2 * pStart.x - pEnd.x,
      y: 2 * pStart.y - pEnd.y
    };
  };

  Utility.getTopicId = function() {
    var topicIdFromScene = (currScene && currScene.topicId) ? currScene.topicId : 0;
    if (!topicIdFromScene) { // 防止"" 和 string型的数字
      topicIdFromScene = 0;
    } else {
      topicIdFromScene = parseInt(topicIdFromScene);
    }

    return (TQ.State && TQ.State.topic) ? TQ.State.topic._id : topicIdFromScene;
  };

  // private
  function getNativeEvent(e) {
    var e0 = e.nativeEvent;
    if (!e0 && e.gesture && e.gesture.srcEvent) { // gesture event of ionic
      e0 = e.gesture.srcEvent;
    }
    return e0;
  }

  Utility.getColorR = function(color) {
    checkColorString(color);
    return parseInt(color.substr(1, 2), 16);
  };

  Utility.getColorG = function(color) {
    checkColorString(color);
    return parseInt(color.substr(3, 2), 16);
  };

  Utility.getColorB = function(color) {
    checkColorString(color);
    return parseInt(color.substr(5, 2), 16);
  };

  Utility.RGB2Color = function(r, g, b) {
    return "#" + number2Hex(r) + number2Hex(g) + number2Hex(b);
  };

  Utility.getWorld2DcScale = function() {
    var sx = 1;
    var sy = 1;

    if (currScene) {
      sx = TQ.Config.workingRegionWidth / currScene.getDesignatedWidth();
      sy = TQ.Config.workingRegionHeight / currScene.getDesignatedHeight();
    }

    return { sx: sx, sy: sy };
  };

  Utility.getDc2WorldScale = function() {
    var sx = 1;
    var sy = 1;

    if (currScene) {
      sx = currScene.getDesignatedWidth() / TQ.Config.workingRegionWidth;
      sy = currScene.getDesignatedHeight() / TQ.Config.workingRegionHeight;
    }

    return { sx: sx, sy: sy };
  };

  Utility.world2css = function(x, y) {
    TQ.AssertExt.invalidLogic(!!TQ.State.innerHeight, "应该先让desktopEle ready");

    // window的左下角是（0,0）
    var canvas = TQ.Graphics.getCanvas();
    var canvasStyle = getComputedStyle(canvas, null);
    var xCanvasOriginInCss = removePx(canvasStyle.left);
    var yCanvasOriginInCss = removePx(canvasStyle.bottom);
    var sx = currScene.getDesignatedWidth() / TQ.Config.workingRegionWidth;
    var sy = currScene.getDesignatedHeight() / TQ.Config.workingRegionHeight;

    if (isNaN(yCanvasOriginInCss)) {
      yCanvasOriginInCss = TQ.State.innerHeight -
                (removePx(canvasStyle.top) + removePx(canvasStyle.height));
    }

    return { x: x / sx + xCanvasOriginInCss,
      y: y / sy + yCanvasOriginInCss };
  };

  Utility.world2cssFromTop = function(x, y) {
    TQ.AssertExt.invalidLogic(!!TQ.State.innerHeight, "应该先让desktopEle ready");
    var pos = Utility.world2css(x, y);
    return {
      x: pos.x,
      y: TQ.State.innerHeight - pos.y
    };
  };

  Utility.sendTextToClipboard = function(str) {
    var textArea = document.createElement("textarea");
    textArea.value = str;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    setTimeout(function() {
      document.execCommand("Copy");
    });
  };

  Utility.removeWelcomeTextPage = function() {
    function removeDomEleById(domId) {
      var domEle = document.getElementById(domId);
      if (domEle) {
        angular.element(domEle).remove();
      }
    }

    removeDomEleById("welcome-div");
    removeDomEleById("id-play-panel");
    removeDomEleById("welcome-brand");
  };

  function removePx(xInCss) {
    var result = Number(xInCss.replace("px", ""));
    if (isNaN(result)) {
      TQ.Log.error("css 取值错误， NaN： " + xInCss);
    }
    return result;
  }

  function number2Hex(n) {
    var str = n.toString(16).toUpperCase();
    if (n === 0) {
      return "00";
    } else if (n < 16) {
      return "0" + str;
    }

    return str;
  }

  function checkColorString(color) {
    TQ.Assert.isTrue(color[0] === "#", "颜色格式必须是#AABBCC");
  }

  Utility.isDithering = false;
  Utility.ditherStart = function() {
    Utility.isDithering = true;
    setTimeout(Utility.ditherEnd, 200);
  };

  Utility.ditherEnd = function() {
    Utility.isDithering = false;
  };

  Utility.preventDither = function() {
    var readyToGo = !Utility.isDithering;
    Utility.ditherStart();
    return readyToGo;
  };

  function createLocalId() {
    // localId是服务器Id（global Id）的补充，
    // 避免在object初创，没有global Id的时候导致混乱，简化逻辑
    // 比如： 缓存http存储的 storageManager就使用opus的localId来区别是否同一个对象
    // local Id, 唯一编号，平等对待各种对象，opus，level，element,....
    return "localId" + localIdTimeBase + "-" + (++localIdCounter);
  }

  Utility.createLocalId = createLocalId;
  Utility.parseUrl = parseUrl;
  TQ.Utility = Utility;
}());

/**
 * Created by admin on 12/7/2015.
 */
// 上报各种统计数据
angular.module("starter")
  .factory("StatService", StatService);

StatService.$inject = ["$timeout", "$http"];

function StatService($timeout, $http) {
  var MINIMUM_DURATION = 10000; // 必须看一段时间（例如：10秒）之后， 才算是一个有效的展示

  function startToShow() {
    report("start");
    $timeout(validShow, MINIMUM_DURATION);
  }

  function report(status) {
    TQ.Log.debugInfo("started");
    // 服务器收不到本页面#以后的内容（SPA应用的特点！！！）， 所以， 必须 把本页面url中的hash上传
    // 而且， 参数取值中，不能含特殊字符， 例如：#，/等
    $http.get(TQ.Config.TEST_HOST + "/share" + "?hash=" + status + location.hash.substr(2), {})
      .success(function(data, status, headers, config) {
        TQ.Log.debugInfo(data);
      }).error(function(data, status, headers, config) {
        TQ.Log.debugInfo(data);
      });
  }

  function validShow() {
    TQ.Log.debugInfo("valid");
    // ToDo： 确认是有效的， 例如： 画面是可见的， 具有focus，等
    report("valid");
  }

  function completed() {
    TQ.Log.debugInfo("completed");
  }
  return {
    startToShow: startToShow,
    validShow: validShow,
    completed: completed
  };
}


/**
 * Created by admin on 11/29/2015.
 */
var TQ = TQ || {};
TQ.userProfile = (function() {
  var self = {
    needManualLogin: true,
    loggedIn: false, // 没有login，其余的信息都无意义
    isSignUping: false,
    hasSignedUp: false, // 尚未注册的用户，显示注册界面。否则显示登录界面
    displayName: "",
    name: "",
    age: 6, // ToDo: 需要用户录入
    city: "无锡", // ToDo: 需要用户录入
    ID: "",
    sessionToken: "",
    timesShared: 0,
    readFromCache: readFromCache,
    saveToCache: saveToCache,
    isGuest: function() {
      return (self.name && (self.name.indexOf("guest") === 0) &&
          (self.displayName && (self.displayName.indexOf("guest") === 0)));
    },
    getUserName: function() {
      return (self.isGuest() ? "游客" : self.displayName);
    },
    hasWxUserGranted: function() {
      var guestName = "wxOpenIdF微信用户"; // 与后台，小程序保持一致
      // 区别：
      // wx游客： 'wxNewYearCard'，
      // wx授权用户，再次登录: 'wxUser' + OpenId,  wx中的昵称
      return (TQUtility.isMiniProgramWebView() &&
          (self.name.indexOf("wxOpenId") === 0) && (self.name !== guestName));
    }
  };

  var readCache = TQ.Base.Utility.readCache;
  var writeCache = TQ.Base.Utility.writeCache;

  function readFromCache() {
    self.name = readCache("user_name", "");
    self.displayName = readCache("user_displayName", "");
    self.ID = readCache("user_ID", "");
    self.hasSignedUp = readCache("user_hasSignedUp", false);
    self.age = readCache("user_age", self.age);
    self.city = readCache("user_city", self.city);
    self.needManualLogin = TQ.Base.Utility.readCacheWithParse("user_needManualLogin", self.needManualLogin);
  }

  function saveToCache() {
    writeCache("user_name", self.name);
    writeCache("user_displayName", self.displayName);
    writeCache("user_ID", self.ID);
    writeCache("user_age", self.age);
    writeCache("user_city", self.city);
    writeCache("user_needManualLogin", self.needManualLogin);
    writeCache("user_hasSignedUp", self.hasSignedUp);
  }

  readFromCache();

  return self;
})();

var TQ = TQ || {};
TQ.DomUtility = (function() {
  "use strict";
  return {
    createElement: createElement,
    showElements: showElements,
    showElementAsTable: showElementAsTable,
    showElement: showElement,
    closeElements: closeElements,
    closeElement: closeElement,
    hideElements: hideElements,
    hideElement: hideElement,
    createButtonInTableRow: createButtonInTableRow,
    createButtonInTable: createButtonInTable,
    createButton: createButton
  };

  function createElement(parent, tag, id, eleClass) {
    var ele = document.createElement(tag);
    ele.setAttribute("id", id);
    ele.style.visibility = "hidden";

    if (eleClass) {
      ele.className = eleClass;
    }

    if (parent) {
      parent.appendChild(ele);
    }

    return ele;
  }

  function createButton(parent, id, eleClass, text, onClick, onTouchStart) {
    var BUTTON_TAG = "button";
    var ele = createElement(parent, BUTTON_TAG, id, eleClass);
    ele.innerText = text;
    if (onTouchStart) {
      ele.addEventListener("touchstart", onTouchStart, true); // act as soon as captured
    } else if (onClick) {
      ele.addEventListener("click", onClick, true);
    }
    ele.style.display = "inline";
    return ele;
  }

  function createButtonInTable(parent, id, eleClass, text, callback) {
    var cell = createElement(parent, "tr", id + "-cell", null);
    return createButton(cell, id, eleClass, text, callback);
  }

  function createButtonInTableRow(parent, id, eleClass, text, onClick, onTouchStart) {
    var cell = createElement(parent, "td", id + "-cell", null);
    return createButton(cell, id, eleClass, text, onClick, onTouchStart);
  }

  function hideElement(ele) {
    ele.style.visibility = "hidden";
    ele.style.display = "none";
  }

  function hideElements(eles) {
    for (var i = eles.length - 1; i >= 0; i--) {
      hideElement(eles[i]);
    }
  }

  function closeElement(ele) {
    ele.setAttribute("style", "");
    ele.style.cssText = "";
    ele.style.display = "none";
    ele.style.visibility = "hidden";
  }

  function closeElements(eles) {
    for (var i = eles.length - 1; i >= 0; i--) {
      closeElement(eles[i]);
    }
  }

  function showElement(ele) {
    ele.style.visibility = "visible";
    ele.style.display = "block";
  }

  function showElementAsTable(ele) {
    ele.style.visibility = "visible";
    ele.style.display = "table";
  }

  function showElements(eles) {
    for (var i = eles.length - 1; i >= 0; i--) {
      showElement(eles[i]);
    }
  }
})();

window.TQ = window.TQ || {};
(function() {
  var MessageBubble = {};
  MessageBubble.visible = false;
  MessageBubble.dlg = null;
  MessageBubble.counter = 0;
  MessageBubble.initialize = function() {
    // 在 mcDeferLoad.html 中定义，由mc中的mcDeferLoad 统一加载；
    // 把小资源文件合并成大文件，提高加载速度
    MessageBubble.dlg = $("#messageBubbleDiv");
    MessageBubble.bubble = $("#bubble");
    MessageBubble.dlg.hide();
  };

  MessageBubble.close = function() {
    easyDialog.close();
  };

  MessageBubble.addMessage = function(msg) {
    if (MessageBubble.visible) {
      MessageBubble.bubble.text(MessageBubble.bubble.text() + "; " + msg);
    }
  };

  MessageBubble.show = function(defaultvalue, button1, callback1, button2, callback2) {
    return MYJS.alert_obj.alert("Test 信息", "OK", null, null);
  };

  TQ.MessageBubble = MessageBubble;
}());

/**
 * Created by Andrewz on 6/17/2016.
 */
var TQ = TQ || {};
TQ.MessageBox = (function() {
  var TYPE_PROMPT = "prompt";
  var TYPE_CONFIRM = "confirm";
  var TYPE_SHOW = "show";
  var TYPE_TOAST = "toast";
  var TYPE_PROGRESS = "progress";
  var MESSAGE_CRITICAL = 9;
  var MESSAGE_NO = 0;

  var isShowingByForce = false;
  var instances = {};
  var messageLevel = MESSAGE_NO;
  var timerNoFlash = null;
  var msgList = [];
  var timer = null;

  var instance = {
    getInstance: getInstance,
    hide: hide,
    hasCriticalError: hasCriticalError,
    reset: reset,
    hideProgressBox: hideProgressBox,
    prompt: prompt, // 可以被reset.
    promptNoFlash: promptNoFlash,
    promptWithNoCancel: promptWithNoCancel,
    confirm: confirm, // 有OK和Cancel两个按钮， 不能被reset, 用户必须click
    warn: warn,
    show: show, // show 就是alert，只有OK按钮
    show2: show2,
    showWaiting: showWaiting,
    toast: toast
  };

  initVex();
  return instance;

  function isEqualMsg(options1, options2) {
    return options1.content === options2.content;
  }

  function doShow(options) {
    if (isShowingByForce) {
      if ((msgList.length > 0) && isEqualMsg(options, msgList[msgList.length - 1])) {
        return;
      }
      return msgList.push(options);
    }

    if (options.duration) {
      isShowingByForce = true;
      timer = setTimeout(onDuration, options.duration);
    }
    var inst = show2(options);
    if (!options.mustClick) {
      instances[options.type] = inst;
    }
    return (inst);
  }

  function getInstance() {
    return instance;
  }

  function reset() {
    // 仅仅是清除任何显示的对话框，但是，要避免重入，特别是，此对话框的onOK调用reset
    setTimeout(hide);
  }

  function hide(ref) {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    if (timerNoFlash) {
      clearTimeout(timerNoFlash);
      timerNoFlash = null;
    }

    isShowingByForce = false;
    doHide(ref);
  }

  function onCancel() {
    TQ.Log.debugInfo("cancelled!");
  }

  function onOk() {
    TQ.Log.debugInfo("Ok!");
  }

  function hasCriticalError() {
    return messageLevel === MESSAGE_CRITICAL;
  }

  function promptWithNoCancel(msg, onOk1) {
    messageLevel = MESSAGE_CRITICAL;
    prompt(msg, onOKShell, null, true, { noCancel: true });
    function onOKShell() {
      messageLevel = MESSAGE_NO;
      if (onOk1) {
        onOk1();
      }
    }
  }

  function prompt(msg, onOk1, onCancel1, mustClick, options) {
    if (!options) {
      options = {};
    }

    options.mustClick = !!mustClick;
    options.unsafeMessage = msg;
    options.onOk = onOk1 || onOk;

    if (onCancel1) {
      options.onCancel = onCancel1;
    }

    options.type = TYPE_PROMPT;
    return (doShow(options));
  }

  // 3秒之内， 不显示waiting， 防止快闪
  function promptNoFlash(msg, onOk1, onCancel1, mustClick, options) {
    var NO_FLASH_TIME = 2000;
    if (timerNoFlash) {
      clearTimeout(timerNoFlash);
    }
    timerNoFlash = setTimeout(function() {
      prompt(msg, onOk1, onCancel1, mustClick, options);
      timerNoFlash = null;
    }, NO_FLASH_TIME);
  }

  function confirm(msg, onOk1, options) {
    // 只有确定， 必须点击才能消失
    if (!options) {
      options = {};
    }

    options.mustClick = true;
    options.noCancel = true;
    options.unsafeMessage = msg;
    options.onOk = !onOk1 ? onOk : onOk1;
    options.type = TYPE_CONFIRM;
    return doShow(options);
  }

  function warn(msg) {
    confirm(msg);
  }

  function show(str) {
    return doShow({ unsafeMessage: str, type: TYPE_SHOW });
  }

  function toast(str) {
    var duration = 1000;
    return doShow({ unsafeMessage: str, duration: duration, noOk: true, noCancel: true, type: TYPE_TOAST });
  }

  function onDuration() {
    isShowingByForce = false;
    hide(instances[TYPE_TOAST]);
    instances[TYPE_TOAST] = null;
    if (msgList.length <= 0) {
      return;
    }

    var oldList = msgList;
    msgList = [];
    for (; oldList.length > 0;) {
      doShow(oldList.pop());
    }
  }

  function showWaiting(msg) {
    var htmlStr = "<img src=\"/public/images/loading.gif\"> " + msg;
    return doShow({ unsafeMessage: htmlStr, position: "bottom", type: TYPE_PROGRESS });
  }

  function show2(options) {
    // {content: msg, onOk: onOk, onCancel: onCancel, duration: duration}
    var buttons = [];
    var vexOptions = {
      message: options.content,
      showCloseButton: !!options.showCloseButton,
      unsafeMessage: options.unsafeMessage,
      overlayClosesOnClick: !!options.overlayClosesOnClick,
      className: getClassName(options),
      mustClick: options.mustClick,
      callback: function(value) {
        if (value) {
          console.log("Ok");
          if (options.onOk) {
            options.onOk();
          }
        } else {
          console.log("canceled!");
          if (options.onCancel) {
            options.onCancel();
          }
        }
      }
    };

    if (options.overlayClassName) {
      vexOptions.overlayClassName = options.overlayClassName;
    }

    if (!options.noOK) {
      if (!options.okText) {
        options.okText = TQ.Locale.getStr("OK");
      }

      if (options.okText) {
        buttons.push($.extend({}, vex.dialog.buttons.YES, { text: options.okText }));
      }
    }

    if (!options.noCancel) {
      if (!options.cancelText) {
        options.cancelText = TQ.Locale.getStr("Cancel");
      }

      if (options.cancelText) {
        buttons.push($.extend({}, vex.dialog.buttons.NO, { text: options.cancelText }));
      }
    }

    if (buttons.length > 0) {
      vexOptions.buttons = buttons;
    }

    if (!options.onCancel) {
      return vex.dialog.alert(vexOptions);
    }
    return vex.dialog.confirm(vexOptions);
  }

  function getClassName(options) {
    var name = "vex-theme-default";
    if (options.position) {
      switch (options.position) {
        case "top":
          name = "vex-theme-top";
          break;
        case "bottom":
          name = "vex-theme-bottom-right-corner";
          break;
        default :
          break;
      }
    }

    return name;
  }

  function doHide(ref) {
    if (!ref) {
      hideProgressBox();
      if (instances[TYPE_SHOW]) {
        vex.close(instances[TYPE_SHOW]);
        instances[TYPE_SHOW] = null;
      }

      if (instances[TYPE_PROMPT]) {
        var options = instances[TYPE_PROMPT].options;
        if (!options.mustClick) {
          vex.close(instances[TYPE_PROMPT]); // 这个close， 还在调用callback，容易造成死循环
          instances[TYPE_PROMPT] = null;
        }
      }

      if (instances[TYPE_TOAST]) {
        vex.close(instances[TYPE_TOAST]);
        instances[TYPE_TOAST] = null;
      }
    } else {
      vex.close(ref);
    }
  }

  function hideProgressBox() {
    if (instances[TYPE_PROGRESS]) {
      hide(instances[TYPE_PROGRESS]);
      instances[TYPE_PROGRESS] = null;
    }
  }

  function initVex() {
    // popstate事件不close
    vex.defaultOptions.closeAllOnPopState = false;
  }
})();

TQ.MessageBubble = TQ.MessageBox; // 为了兼容老的代码，被代替了，


/**
 * Created by Andrewz on 3/4/2017.
 * 抽取并集中底层函数， 建立自己的绘图库layer，
 * 以便于将来切换到createJS之外的library，
 */
var TQ = TQ || {};
TQ.Graphics = (function() {
  "use strict";
  var ET_MOVETO = 1; // Element Type in polygon
  var ET_ARC = 2;
  var ET_LINE = 3;

  var _canvas = null;
  var canvasStyle = null;

  return {
    drawBubble: drawBubble,
    drawSolidCircle: drawSolidCircle,
    drawCircle: drawCircle,
    drawRect: drawRect,
    drawSolidRect: drawSolidRect,
    drawRectC: drawRectC,
    drawStar: drawStar,
    getCanvas: getCanvas,
    getCanvasBkgColor: getCanvasBkgColor,
    getCanvasWidth: getCanvasWidth,
    getCanvasHeight: getCanvasHeight,
    getCanvasStyle: getCanvasStyle,
    getStage: getStage,
    setCanvas: setCanvas,
    findEditableElementBelowZ: findEditableElementBelowZ
  };

  function getStage() {
    return stageContainer;
  }

  function getCanvas() {
    if (!_canvas) {
      _canvas = document.getElementById("testCanvas");
    }
    return _canvas;
  }

  function getCanvasStyle() {
    if (!canvasStyle) {
      canvasStyle = setCanvas();
    }
    return canvasStyle;
  }

  function getCanvasWidth() {
    if (!canvasStyle) {
      canvasStyle = setCanvas();
    }
    return TQ.Utility.getCssSize(canvasStyle.width);
  }

  function getCanvasHeight() {
    if (!canvasStyle) {
      canvasStyle = setCanvas();
    }
    return TQ.Utility.getCssSize(canvasStyle.height);
  }

  function getCanvasBkgColor() {
    TQ.AssertExt.invalidLogic(!!_canvas);
    return window.getComputedStyle(_canvas, null).getPropertyValue("background-color");
  }

  function setCanvas() {
    if (!canvasStyle) {
      canvasStyle = {};
    }
    var w = Math.round(TQ.Config.workingRegionWidth);
    var h = Math.round(TQ.Config.workingRegionHeight);

    if (!TQ.State.backgroundColor) {
      TQ.State.backgroundColor = TQ.Config.BACKGROUND_COLOR;
    }
    if (currScene) {
      if (!currScene.backgroundColor) {
        currScene.backgroundColor = TQ.State.backgroundColor;
      }
    }
    canvasStyle.width = w + "px";
    canvasStyle.height = h + "px";
    canvasStyle.top = Math.round(TQ.Config.workingRegionY0) + "px";
    canvasStyle.left = Math.round(TQ.Config.workingRegionX0) + "px";
    canvasStyle.backgroundColor = (currScene) ? currScene.backgroundColor : TQ.State.backgroundColor;
    if (_canvas) {
      _canvas.width = w;
      _canvas.height = h;
    }
    if (currScene) {
      TQ.Log.debugInfo(TQ.State.innerWidth, TQ.State.innerHeight, "---", TQ.Config.workingRegionWidth, TQ.Config.workingRegionHeight, "---", currScene.getDesignatedWidth(), currScene.getDesignatedHeight(), "AAAAA");
    }
    window.screenfull.update();
    return canvasStyle;
  }

  function drawCircle(shape, x, y, radius, gradientColorS, gradientColorE, solidColor) { // shape is createJS.Shape
    var thickness = 1;
    var edgeColor = "#000";

    if (!gradientColorS) { // 兼容
      gradientColorS = "#00F";
      gradientColorE = "#F00";
    }

    var strokes = shape.graphics;
    if (solidColor) {
      strokes = strokes.beginFill(solidColor);
    }
    strokes.ss(thickness).beginStroke(edgeColor)
      .beginRadialGradientFill([gradientColorS, gradientColorE], [0, 1], 0, 0, 0, 0, 0, radius)
      .drawCircle(x, y, 3)
      .drawCircle(x, y, radius)
      .endFill();
  }

  function drawSolidCircle(shape, color, x, y, radius, gradientColorS, gradientColorE) { // shape is createJS.Shape
    return drawCircle(shape, x, y, radius, gradientColorS, gradientColorE, color);
  }

  function drawBubble(shape, bubble) {
    //  正中心是 原点
    var geoModel = calBubbleModel(bubble.xmin, bubble.ymin, bubble.width, bubble.height,
      bubble.radiusTL, bubble.radiusTR, bubble.radiusBR, bubble.radiusBL, bubble.anchor);
    drawPolygon(shape, geoModel);
  }

  function drawRect(shape, x0, y0, w, h, radius, solidColor) {
    var xc = x0 + w / 2;
    var yc = y0 + h / 2;
    drawRectC(shape, xc, yc, w, h, radius, solidColor);
  }

  function drawSolidRect(shape, solidColor, x0, y0, w, h, radius) {
    return drawRect(shape, x0, y0, w, h, radius, solidColor);
  }

  function drawRectC(shape, xc, yc, w, h, radius, solidColor) {
    // 左下角， + pivot
    var thickness = 1;
    var edgeColor = "#000";

    radius = (radius === undefined) ? 2 : radius;
    var strokes = shape.graphics;
    if (solidColor) {
      strokes = strokes.beginFill(solidColor);
    }
    strokes.ss(thickness).beginStroke(edgeColor)
      .drawRoundRect(xc, yc, w, h, radius)
      .endFill();
  }

  function drawStar(shape, x, y, w, h) {
    var thickness = 1;
    var edgeColor = "#000";
    var radius = Math.min(w, h);
    var edgeNumber = 6;

    shape.graphics.ss(thickness).beginStroke(edgeColor)
      .drawPolyStar(x, y, radius, edgeNumber, 0)
      .endFill();
  }

  function calBubbleModel(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL, anchor) {
    // 在物体空间计算
    var max = (w < h ? w : h) / 2;
    var mTL = 0; var mTR = 0; var mBR = 0; var mBL = 0;
    var x2 = x + w;
    var y2 = y + h;

    if (radiusTL < 0) {
      radiusTL *= (mTL = -1);
    }
    if (radiusTL > max) {
      radiusTL = max;
    }
    if (radiusTR < 0) {
      radiusTR *= (mTR = -1);
    }
    if (radiusTR > max) {
      radiusTR = max;
    }
    if (radiusBR < 0) {
      radiusBR *= (mBR = -1);
    }
    if (radiusBR > max) {
      radiusBR = max;
    }
    if (radiusBL < 0) {
      radiusBL *= (mBL = -1);
    }
    if (radiusBL > max) {
      radiusBL = max;
    }

    return [{ type: ET_MOVETO, x: x2 - radiusTR, y: y },
      { type: ET_ARC, x: x2 + radiusTR * mTR, y: y - radiusTR * mTR, x2: x2, y2: y + radiusTR, r: radiusTR },
      { type: ET_LINE, x: x2, y: y2 - radiusBR },
      { type: ET_ARC, x: x2 + radiusBR * mBR, y: y2 + radiusBR * mBR, x2: x2 - radiusBR, y2: y2, r: radiusBR },
      { type: ET_LINE, x: x + radiusTL, y: y2 },
      { type: ET_ARC, x: x - radiusBL * mBL, y: y2 + radiusBL * mBL, x2: x, y2: y2 - radiusBL, r: radiusBL },
      { type: ET_LINE, x: x, y: y + radiusTL },
      { type: ET_ARC, x: x - radiusTL * mTL, y: y - radiusTL * mTL, x2: x + radiusTL, y2: y, r: radiusTL },
      { type: ET_LINE, x: anchor[2].x, y: anchor[2].y },
      { type: ET_LINE, x: anchor[1].x, y: anchor[1].y },
      { type: ET_LINE, x: anchor[0].x, y: anchor[0].y }
    ];
  }

  function drawPolygon(shape, geoModel) {
    // 转为设备空间
    var thickness = 1;
    var edgeColor = "#000";
    var fillColor = "#DDD";
    var brush = shape.graphics.ss(thickness).beginStroke(edgeColor)
      .beginFill(fillColor);
    for (let i = 0; i < geoModel.length; i++) {
      var item = geoModel[i];
      switch (item.type) {
        case ET_MOVETO:
          brush.moveTo(item.x, toCanvasDevice(item.y));
          break;
        case ET_LINE:
          brush.lineTo(item.x, toCanvasDevice(item.y));
          break;
        case ET_ARC:
          brush.arcTo(item.x, toCanvasDevice(item.y), item.x2, toCanvasDevice(item.y2), item.r);
          break;
        default:
          console.error("known type!", item.type);
      }
    }
    brush.closePath()
      .endFill();
  }

  function toCanvasDevice(objY) { // 只是反Y坐标， 不能被Height减，否则有系统误差
    return -objY;
  }

  // stage
  function findEditableElementBelowZ(z, direction) {
    var displayObj;
    var ele;
    var step = (direction > 0) ? 1 : -1;
    var num = stageContainer.getNumChildren();

    do {
      displayObj = stageContainer.getChildAt(z);
      ele = (!displayObj) ? null : displayObj.ele;
      z += step;
      if ((ele === null) || // virtual object
        (ele.isEditorEle())) { // marker
        continue;
      }
    } while ((z >= 0) && (z < num));

    while (ele && ele.parent) {
      ele = ele.parent;
    }

    return ele;
  }
})();

/**
 * Created by Andrewz on 2/13/2017.
 * 抽取并集中与create库直接相关的操作到此文件，
 * 以便于将来更换为其它的 lib
 */
var TQ = TQ || {};
(function() {
  "use strict";
  function CreateJSAdapter() {
  }

  var _rootBoneDefaultTsr = { // 缺省的TSR参数： 无平移， 无旋转， 无比例
    x: 0,
    y: 0,
    rotation: 0,
    sx: 1,
    sy: 1,
    M: TQ.Matrix2D.I(),
    IM: TQ.Matrix2D.I(), // Inverse Matrix, 逆矩阵
    visible: true, // 没有animeTrack， 没有M， 都应该是可见的
    alpha: 1
  };

  function getDefaultRootTsr() {
    return _rootBoneDefaultTsr;
  }

  CreateJSAdapter.getDefaultRootTsr = getDefaultRootTsr;
  CreateJSAdapter.attach = function(p) {
    for (var item in CreateJSAdapter) {
      if (typeof CreateJSAdapter[item] === "function") {
        if (item === "attach") {
          continue;
        }

        if (!p[item]) {
          p[item] = CreateJSAdapter[item];
        }
      }
    }
    return p;
  };

  CreateJSAdapter.getWidth = function() {
    var w;
    if (this.isVirtualObject()) { // 对于Group物体
      w = 1;
    } else if (this.isBitmap()) {
      w = this.displayObj.naturalWidth();
    } else {
      TQ.AssertExt.isNotNull(false, "发现新的元素类别：" + this.name);
    }

    return w;
  };

  CreateJSAdapter.getHeight = function() {
    var h;
    if (this.isVirtualObject()) { // 对于Group物体
      h = 1;
    } else if (this.isBitmap()) {
      h = this.displayObj.naturalHeight();
    } else {
      TQ.AssertExt.isNotNull(false, "发现新的元素类别：" + this.name);
    }
    return h;
  };

  CreateJSAdapter.toDeviceCoord = function(displayObj, jsonObj) {
    if (!this.justMoved) {
    }
    TQ.Log.debugInfo(this.jsonObj.type + ", jsonObj(x,y) = " + this.jsonObj.x + "," + this.jsonObj.y);
    this.justMoved = false;
    var obj_dc = this.world2Dc();
    displayObj.x = obj_dc.x;
    displayObj.y = obj_dc.y;
    if (!this.jsonObj.M) {
      this.updateM(this.parent, this.jsonObj);
    }
    if (this.jsonObj.M) {
      displayObj.scaleX = (this.getMirrorY() ? -obj_dc.sx : obj_dc.sx);
      displayObj.scaleY = (this.getMirrorX() ? -obj_dc.sy : obj_dc.sy);
    }
    displayObj.regX = obj_dc.pivotX * this.getWidth();
    displayObj.color = jsonObj.color;
    displayObj.alpha = jsonObj.alpha;

    // regX，Y坐标：(由createJS定义的)
    // *   +Y 向下， 同设备坐标一致
    // * 对于图像和Text： 原点regY=0在左上角，
    // * 对于Shape（圆， 矩形， 星形）： regXY（0，0) 在正中心

    // PivotXY: (在物体空间定义， 由TQ定义)
    // *   +Y 向上， 同世界坐标系一致
    // * 对于图像类： Pivot原点在左上角，
    // * 对于Shape中的圆：  Pivot原点在正中心
    if (displayObj instanceof createjs.Shape) {
      displayObj.regY = -obj_dc.pivotY * this.getHeight();
    } else {
      displayObj.regY = (1 - obj_dc.pivotY) * this.getHeight();
    }
    displayObj.rotation = this.getRotateDirection() * obj_dc.rotation;
  };

  CreateJSAdapter.getScale = function() {
    return this.getScaleInWorld();
  };

  CreateJSAdapter.getScaleInWorld = function() {
    return { sx: this.jsonObj.sx, sy: this.jsonObj.sy };
  };

  CreateJSAdapter.getPosition = function() { // in PDC
    return this.getPositionInWorld();
  };

  CreateJSAdapter.getPositionInWorld = function() {
    return { x: this.jsonObj.x, y: this.jsonObj.y };
  };

  CreateJSAdapter.getPositionInDc = function() {
    var obj_dc = this.world2Dc();
    return { x: obj_dc.x, y: obj_dc.y };
  };

  CreateJSAdapter.getPositionInNdc = function() {
    return this.pdc2Ndc(this.getPositionInWorld());
  };

  CreateJSAdapter.nw2World = function(oNWorld) {
    // 从规范化的世界坐标Normalized World到世界坐标系(像素坐标)
    var sx = currScene.getDesignatedWidth();
    var sy = currScene.getDesignatedHeight();

    var oWorld = {
      x: oNWorld.x * sx,
      y: oNWorld.y * sy,
      sx: oNWorld.sx * sx,
      sy: oNWorld.sy * sy,
      fontSize: (!oNWorld.fontSize) ? 0 : oNWorld.fontSize * sx,
      rotation: oNWorld.rotation,
      pivotX: oNWorld.pivotX,
      pivotY: oNWorld.pivotY
    };

    return oWorld;
  };

  CreateJSAdapter.pdc2Ndc = function(obj) {
    /* NDC 是归一化的设备坐标，DC， Y轴向上，[0,1]范围，jsonObj保存的是NDC坐标
         PDC是 伪设备坐标，DC， Y轴向上
         DC：是设备坐标， Y轴向下，用于displayObj
         */
    this.justMoved = true;
    var sx = 1 / TQ.Config.workingRegionWidth;
    var sy = 1 / TQ.Config.workingRegionHeight;

    return {
      x: (obj.x === undefined) ? Number.NaN : obj.x * sx,
      y: (obj.y === undefined) ? Number.NaN : obj.y * sy,
      sx: (obj.sx === undefined) ? 1 : obj.sx * sx,
      sy: (obj.sy === undefined) ? 1 : obj.sy * sy,
      fontSize: (obj.fontSize === undefined) ? 0 : obj.fontSize * sx,
      rotation: (obj.rotation === undefined) ? 0 : obj.rotation,
      pivotX: (obj.pivotX === undefined) ? 0 : obj.pivotX,
      pivotY: (obj.pivotY === undefined) ? 0 : obj.pivotY
    };
  };

  CreateJSAdapter.dc2World = function(ptDc) {
    var scale = TQ.Utility.getDc2WorldScale();
    return {
      x: (ptDc.x === undefined) ? 0 : ptDc.x * scale.sx,
      y: (ptDc.y === undefined) ? 0 : TQ.Utility.toWorldCoord(ptDc.y) * scale.sy,
      // sx: (ptDc.sx === undefined) ? 1 : ptDc.sx * sx,
      // sy: (ptDc.sy === undefined) ? 1 : ptDc.sy * sy,
      // fontSize: (ptDc.fontSize === undefined) ? 0 : ptDc.fontSize * sx,
      rotation: (ptDc.rotation === undefined) ? 0 : -ptDc.rotation
      // pivotX: (ptDc.pivotX === undefined) ? 0 : ptDc.pivotX,
      // pivotY: (ptDc.pivotY === undefined) ? 0 : ptDc.pivotY
    };
  };

  CreateJSAdapter.dc2World2 = function(ptDc) {
    // DC坐标：是event中的(pageX, pageY)，window的innerWidth和Height坐标系，不含address bar， 原点在左上角，
    // World坐标： Canvas上的实际绘图区，
    var scale = TQ.Utility.getDc2WorldScale();
    var x0d = (TQ.State.innerWidth - TQ.Config.workingRegionWidth) / 2;
    var y0d = TQ.State.innerHeight - (TQ.State.innerHeight - TQ.Config.workingRegionHeight) / 2;

    if (ptDc.x === undefined) {
      ptDc.x = 0;
    }
    if (ptDc.y === undefined) {
      ptDc.y = 0;
    }
    if (ptDc.rotation === undefined) {
      ptDc.rotation = 0;
    }

    return {
      x: (ptDc.x - x0d) * scale.sx,
      y: (y0d - ptDc.y) * scale.sy,
      rotation: -ptDc.rotation
    };
  };

  CreateJSAdapter.world2Dc = function(ptWorld) {
    var scale = TQ.Utility.getWorld2DcScale();
    var sx = scale.sx;
    var sy = scale.sy;
    var sMin = Math.min(sx, sy);
    var ptDc;

    sx = sy = sMin; // 可以自适应到任何屏幕， 但是， 必须等比例
    if (!ptWorld) {
      ptWorld = this.jsonObj;
      ptDc = {
        sx: (ptWorld.sx === undefined) ? 1 : ptWorld.sx * sx,
        sy: (ptWorld.sy === undefined) ? 1 : ptWorld.sy * sy,
        // fontSize: (ptWorld.fontSize === undefined) ? 0 : ptWorld.fontSize * sx,
        // createJS的角度： 逆时针是负的，所以要 改之
        rotation: (ptWorld.rotation === undefined) ? 0 : -ptWorld.rotation,
        pivotX: (ptWorld.pivotX === undefined) ? 0.5 : ptWorld.pivotX,
        pivotY: (ptWorld.pivotY === undefined) ? 0.5 : ptWorld.pivotY
      };
    } else {
      ptDc = {};
    }

    ptDc.x = (ptWorld.x === undefined) ? 0 : ptWorld.x * sx;
    ptDc.y = (ptWorld.y === undefined) ? 0 : TQ.Utility.toDeviceCoord(ptWorld.y * sy);
    return ptDc;
  };

  CreateJSAdapter.world2Object = function(ptWorld) {
    if (!ptWorld) {
      ptWorld = this.jsonObj;
    }

    if (!this.jsonObj.IM) {
      if (!this.jsonObj.M) {
        return ptWorld;
      } else {
        this.jsonObj.IM = this.jsonObj.M.inverse();
      }
    }

    var ptObject = this.jsonObj.IM.multiply($V([ptWorld.x, ptWorld.y, 1]));
    return { x: ptObject.elements[0], y: ptObject.elements[1] };
  };

  CreateJSAdapter.dWorld2Object = function(displacementInWorld) {
    var originInWorld = { x: 0, y: 0 };
    var originInObject = this.world2Object(originInWorld);
    var displacementInObj = this.world2Object(displacementInWorld);
    return { x: displacementInObj.x - originInObject.x, y: displacementInObj.y - originInObject.y };
  };

  CreateJSAdapter.dDc2Object = function(ptDc) {
    var p0Dc = { x: 0, y: 0, rotation: 0 };
    var p0World = this.dc2World2(p0Dc);
    var ptWorld = this.dc2World2(ptDc);
    var p0Object = this.world2Object(p0World);
    var ptObject = this.world2Object(ptWorld);

    return {
      x: ptObject.x - p0Object.x,
      y: ptObject.y - p0Object.y,
      rotation: ptObject.rotation - p0Object.rotation
    };
  };

  CreateJSAdapter.parentWorld2Object = function(ptWorld) {
    if (!ptWorld) {
      ptWorld = this.jsonObj;
    }

    if (!this.parent) {
      return ptWorld;
    }

    return this.parent.world2Object(ptWorld);
  };

  CreateJSAdapter.object2World = function(ptObj) {
    if (!ptObj || !this.jsonObj.M) {
      console.error("must have ptObj 和 M");
      return ptObj;
    }

    var ptWorld = this.jsonObj.M.multiply($V([ptObj.x, ptObj.y, 1]));
    if ((ptWorld.elements[2] < 0.99) || (ptWorld.elements[2] > 1.01)) {
      assertEqualsDelta(TQ.Dictionary.INVALID_PARAMETER, 1, ptWorld.elements[2], 0.01); // 齐次分量应该近似为1
    }

    return { x: ptWorld.elements[0], y: ptWorld.elements[1] };
  };

  CreateJSAdapter.tsrObject2World = function(pose) {
    // Pose 总是临时生成的，
    var tsrObj = pose;
    var shapeObj = [{ x: 0, y: 0 }];
    var originObj = shapeObj[0];

    // 物体坐标 ===>到 世界坐标下
    // 平移部分：
    var tsrWorld = this.jsonObj;
    var originWorld = this.object2World(originObj); //  only平移
    tsrWorld.x = originWorld.x;
    tsrWorld.y = originWorld.y;

    // 比例和旋转部分：
    var parentTSRWorld = (!this.parent || !this.parent.jsonObj) ? getDefaultRootTsr() : this.parent.jsonObj;
    tsrWorld.rotation = TQ.Utility.limitTo360(parentTSRWorld.rotation + tsrObj.rotation);
    tsrWorld.sx = parentTSRWorld.sx * tsrObj.sx;
    tsrWorld.sy = parentTSRWorld.sy * tsrObj.sy;

    // 可见性：
    tsrWorld.isVis = tsrObj.visible;
    if (tsrObj.color !== undefined) {
      tsrWorld.color = tsrObj.color;
    }
    if (tsrObj.alpha !== undefined) {
      tsrWorld.alpha = tsrObj.alpha;
    }
  };

  CreateJSAdapter.updateM = function(parent, Pose) {
    var tsrObj = Pose;
    if (!tsrObj) {
      TQ.Log.debugInfo("Root element, use default trsObj");
      tsrObj = getDefaultRootTsr();
    }

    if (!parent || !parent.M) {
      parent = getDefaultRootTsr();
    }

    var sx = tsrObj.sx;
    var sy = tsrObj.sy;
    var selfRotation = tsrObj.rotation;
    var parentRotation = parent.rotation;

    // 绕任意点任意轴的镜像和比例：
    // 先回到原点、正X轴，做比例和镜像，然后在变换回去
    // translate to (0,0)
    //    rotate to X
    //      mirror along X, scale,
    //    rotate back
    // translate back
    var MTranslateToP = TQ.Matrix2D.transformation(-tsrObj.x, -tsrObj.y, 0, 1, 1);
    var MRotateToX = TQ.Matrix2D.transformation(0, 0, -parentRotation, 1, 1);
    var MMirror;
    if (tsrObj.mirrorX) {
      if (tsrObj.mirrorY) {
        MMirror = TQ.Matrix2D.mirrorXY();
      } else {
        MMirror = TQ.Matrix2D.mirrorX();
      }
    } else if (tsrObj.mirrorY) {
      MMirror = TQ.Matrix2D.mirrorY();
    } else {
      MMirror = TQ.Matrix2D.I();
    }

    var MRotateBack = TQ.Matrix2D.transformation(0, 0, parentRotation, 1, 1);
    var MTranslateBack = TQ.Matrix2D.transformation(tsrObj.x, tsrObj.y, 0, 1, 1);
    var M = TQ.Matrix2D.transformation(tsrObj.x, tsrObj.y, selfRotation, sx, sy);
    var tsrWorld = this.jsonObj;
    tsrWorld.M = parent.M.multiply(MTranslateBack).multiply(MRotateBack).multiply(MMirror)
      .multiply(MRotateToX).multiply(MTranslateToP).multiply(M);
    tsrWorld.IM = null; // 必须清除上一个时刻的 IM,因为M变了,IM过时了, 但是, 不要计算, 等到用时再算.
    tsrWorld.visible = parent.isVis;
    tsrWorld.alpha = tsrWorld.alpha * parent.alpha;
    // TQ.Log.matrixDebugInfo("parent: ", parent.M);
    TQ.Log.matrixDebugInfo(this.id + ": ", tsrWorld.M);
  };

  CreateJSAdapter.scaleOne = function(desc) {
    desc.sx = desc.sy = 1;
  };

  CreateJSAdapter.markerScaleOne = function(desc) {
    desc.sx = desc.sy = 1;
  };

  CreateJSAdapter.fontScaleOne = function(desc) {
    desc.sx = desc.sy = 1;
  };

  TQ.CreateJSAdapter = CreateJSAdapter;
})();

angular.module("starter").factory("WxService", WxService);
WxService.$inject = ["$http", "$q"];
function WxService($http, $q) {
  // ToDo: CORS 无法读取server设置的cookie，
  //     ==> Auth用户统计， 必须和网页一个host
  //  ==> sever的cookie可以是 http读取only， 不让客户端读写它，以便于追踪
  var _isReady = false;
  var urlConcat = TQ.Base.Utility.urlConcat;
  var _shareData = null;
  var pageUrlSigned = null;

  // 在本应用中用到的API，（白名单）
  // 1) 白名单之外的API， 将无法使用
  // 2) 要检查、确认用户的环境支持这些API，否则，无法使用，
  var ApiList = [
    "checkJsApi",
    "onMenuShareTimeline",
    "onMenuShareAppMessage",
    "onMenuShareQQ",
    "onMenuShareWeibo",
    "hideMenuItems",
    "showMenuItems",
    "hideAllNonBaseMenuItem",
    "showAllNonBaseMenuItem",
    "translateVoice",
    "startRecord",
    "stopRecord",
    "onRecordEnd",
    "playVoice",
    "pauseVoice",
    "stopVoice",
    "uploadVoice",
    "downloadVoice",
    "chooseImage",
    "previewImage",
    "uploadImage",
    "downloadImage",
    "getNetworkType",
    "openLocation",
    "getLocation",
    "hideOptionMenu",
    "showOptionMenu",
    "closeWindow",
    "scanQRCode",
    "chooseWXPay",
    "openProductSpecificView",
    "addCard",
    "chooseCard",
    "openCard",
    "miniProgram",
    "miniProgram.navigateTo",
    "miniProgram.navigateTo",
    "miniProgram.navigateTo",
    "miniProgram.navigateBack",
    "miniProgram.switchTab",
    "miniProgram.reLaunch",
    "miniProgram.redirectTo",
    "miniProgram.postMessage",
    "miniProgram.getEnv"
  ];

  var title = "春节快乐！";
  var desc = "阖家欢乐，财源滚滚！";
  var link = TQ.Config.ENT_HOST;
  var imgUrl = urlConcat(urlConcat(TQ.Config.MAT_HOST, TQ.Config.IMAGES_CORE_PATH), "v1453298300/67.jpg");
  // TQ.Config.MAT_HOST + "v1453298300/67.jpg"; // "/mcImages/p10324.png",
  // imgUrl = TQ.Config.MAT_HOST + "/mcImages/animation1.gif",
  var imgData = imgUrl;

  // 微信配置
  var getSignature = function() {
    if (!TQ.Config.hasWx) {
      return false;
    }

    $http({
      method: "GET",
      url: TQ.Config.AUTH_HOST + "/getWSignature?filename=myfile",
      data: {}
    }).success(doConfig);
  };

  function doConfig(wechat_sign) {
    /* 1） 需要使用JS-SDK的页面必须先注入配置信息, 否则将无法调用
         2） 同一个url仅需调用一次，
         3） 对于变化url的SPA的web app可在每次url变化时进行调用,
         4） 目前Android微信客户端不支持pushState的H5新特性，
         所以使用pushState来实现web app的页面会导致签名失败，
         此问题会在Android6.2中修复）
         ？？ 2小时之后， 是否需要重新认证？
         */
    // pageUrlSigned = wechat_sign.url;
    pageUrlSigned = location.href;

    if (TQ.Config.WX_DEBUG_ENABLED) {
      TQ.Log.alertInfo(JSON.stringify(wechat_sign));
    }

    console.log("window.__wxjs_environment = " + window.__wxjs_environment);
    wx.config({
      debug: TQ.Config.WX_DEBUG_ENABLED, // true, // false,
      appId: TQ.Config.wx.appId,
      timestamp: wechat_sign.timestamp,
      nonceStr: wechat_sign.nonceStr,
      signature: wechat_sign.signature,
      jsApiList: ApiList,
      success: _onSuccess,
      fail: _onFail,
      complete: _onComplete,
      cancel: _onCancel
    });
    // 如果更换了页面，则需要向wx重新注册？
    // wx.ready如果注册1次， 则只执行1次。放在doConfig里面，以确保每个页面初始化之后，都能够执行1次
    wx.ready(function(msg) {
      TQ.Log.alertInfo("Wx Ready! " + JSON.stringify(msg));
      // 对于注册型的API，在此调用
      // checkAPI();
      _isReady = true;
      if (_shareData) {
        shareMessage(); // 其实，只是预制内容而已， 并非直接发送，
        // 只有等客户点击“分享给朋友”按钮之后，这些内容才会自动填入
      } else {
        TQ.AssertExt.invalidLogic(false, "shareCode不能为空");
      }
    });

    wx.error(function(error) {
      TQ.Log.alertError("Wx Error " + JSON.stringify(error));
    });
  }

  function checkAPI() {
    if (!TQ.Config.hasWx) {
      return false;
    }

    wx.checkJsApi({
      jsApiList: ApiList,
      success: function(res) {
        TQ.Log.alertInfo("All is supported!");
      },
      fail: function(res) {
        TQ.Log.alertInfo("不支持" + JSON.stringify(res));
      },
      complete: _onComplete,
      cancel: _onCancel
    });
  }

  // http://{host-name}/index.html?opus=100_00000025_123_1234567890
  function shareMessage() {
    if (!TQ.Config.hasWx || !_isReady) {
      return;
    }

    var param = {
      title: _shareData.title,
      desc: _shareData.desc,
      link: pageUrlSigned, // link + "?opus=" + shareCode,
      imgUrl: _shareData.ssPath,
      type: "link", // 分享类型,music、video或link，不填默认为link
      trigger: _onTrigger,
      // success: _onSuccess,
      // fail: _onFail,
      complete: _onComplete,

      success: function(res) {
        TQ.Log.alertInfo("微信分享成功！" + JSON.stringify(res));
      },
      fail: function(res) {
        TQ.Log.alertInfo("微信分享不成功，原因" + JSON.stringify(res));
      },

      cancel: _onCancel
    };
    TQ.Log.alertInfo(param);
    wx.onMenuShareAppMessage(param);
  }

  // private function:
  function _onSuccess(data) {
    TQ.Log.alertInfo("onSuccess：成功。" + data.errMsg + "\nData: \n" + JSON.stringify(data));
  }

  function _onFail(data) {
    TQ.Log.alertInfo("onFail：失败。" + data.errMsg + "\nData \n" + JSON.stringify(data));

    /*
         以上几个函数都带有一个参数，类型为对象，其中除了每个接口本身返回的数据之外，还有一个通用属性errMsg，其值格式如下：
         调用成功时："xxx:ok" ，其中xxx为调用的接口名
         用户取消时："xxx:cancel"，其中xxx为调用的接口名
         调用失败时：其值为具体错误信息
         */
  }

  function _onComplete(data) {
    TQ.Log.alertInfo("onComplete：无论成功与否");
    TQ.Log.alertInfo(data.errMsg);
    TQ.Log.alertInfo(JSON.stringify(data));
  }

  function _onCancel(data) {
    TQ.Log.alertInfo("_onCancel：。" + data.errMsg + "\n Data:" + JSON.stringify(data));
  }

  function _onTrigger(data) {
    TQ.Log.alertInfo("trigger: XX 菜单按钮被触发" + data.errMsg + "\n Data: " + JSON.stringify(data));
    /*
         备注：不要尝试在trigger中使用ajax异步请求修改本次分享的内容，因为客户端分享操作是一个同步操作，这时候使用ajax的回包会还没有返回。
         */
  }

  function chooseImage() {
    var q = $q.defer();
    if (!TQ.Config.hasWx) {
      setTimeout(function() {
        q.reject("no wx");
      });
    }
    wx.chooseImage({
      count: 2, // 默认9
      sizeType: ["original", "compressed"],
      sourceType: ["album", "camera"],
      success11: function(res) {
        var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片
        TQ.Log.alertInfo("已选择 " + localIds + " 张图片");
        TQ.Log.alertInfo("已选择 " + 222 + " 张图片");
      },

      success: function(res) {
        var localId = res.localIds[0];
        TQ.Log.alertInfo("已选择 " + res.localIds.length + " 张图片");
        q.resolve(localId);
      }
    });

    return q.promise;
  }

  function isReady() {
    if (!TQ.Config.hasWx) {
      return false;
    }

    return _isReady;
  }

  function init(shareData) {
    if (JSON.stringify(_shareData) === JSON.stringify(shareData)) {
      return;
    }

    _shareData = shareData;
    if (!TQUtility.isWeChat()) { // 如果不在微信里面， 则总是关闭此功能
      TQ.Config.hasWx = false;
    }

    if (!TQ.Config.hasWx) {
      return null;
    }

    return getSignature();
  }

  // 扫面印刷品上的二维码（不是微信上的图片)
  function scanQRCode() {
    if (_isReady) {
      wx.scanQRCode({
        needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，
        scanType: ["qrCode"], // 可以指定扫二维码还是一维码"barCode"，默认二者都有
        desc: "scanQRCode desc",
        success: function(res) {
          alert(JSON.stringify(res));
        }
      });
    }
  }

  return {
    init: init,
    config: getSignature,
    checkAPI: checkAPI,
    chooseImage: chooseImage,
    isReady: isReady,
    scanQRCode: scanQRCode
  };
}

/**
 * Created by Andrewz on 12/17/18.
 */

var TQ = TQ || {};
TQ.ImageCliper = (function() {
  var MASK_TYPE_NO = 0;
  var MASK_TYPE_CIRCLE = 1;
  var MASK_TYPE_RECT = 2;

  var canvas;
  var canvasWidth;
  var canvasHeight;
  var widthCompressed;
  var heightCompressed;
  var clipDiv;
  var context;
  var xOffset; var yOffset; // 图像右上角在canvas中的定位. (为了图像居中显示）
  var xc;
  var yc;
  var baseRadius = 100;
  var radius = baseRadius;
  var scale = {
    sx: 1,
    sy: 1
  };
  var resourceReady = true;
  var touchStarted = false;
  var maskType = MASK_TYPE_NO;
  var isCliping = false;
  var onClipCompleted = null;
  var imageObj = new Image();
  var imageFileOrBlob;
  var eleStart = {
    needReset: true,
    xc: 0,
    yc: 0,
    radius: 1,
    scale: { sx: 1, sy: 1 },
    deltaScale: null // 引用的ScaleCalculator尚未 ready
  };
  var mouseStart;
  var clipOps = [
    ["touch", onTouchOrDragStart],
    ["mousedown", onMouseDown],

    ["touchend", onTouchOrDragEnd],
    ["mouseup", onMouseUp],

    ["release", onRelease],
    ["rotate", onPinchAndRotate],
    ["pinch", onPinchAndRotate],

    ["drag", onDrag],
    ["touchmove", notHandled]
  ];

  return {
    clipImage: clipImage,
    setMask: setMask,
    confirm: confirm,
    cancel: cancel
  };

  function setMask(newType) {
    maskType = newType;
  }

  function setClip(x0, y0, scale) {
    switch (maskType) {
      case MASK_TYPE_NO:
        break;
      case MASK_TYPE_CIRCLE:
        drawCircle(x0, y0, scale);
        break;
      case MASK_TYPE_RECT:
        drawRect(x0, y0, scale);
        break;
      default:
        drawCircle(x0, y0, scale);
    }
    if (maskType !== MASK_TYPE_NO) {
      context.clip();
    }
  }

  function drawCircle(x0, y0, scale) {
    if (!scale) {
      scale = { sx: 1, sy: 1 };
    }

    radius = baseRadius * scale.sx;
    context.beginPath();
    context.arc(x0, y0, radius, 0, 2 * Math.PI, false);
    context.stroke();
  }

  function drawRect(xc, yc, scale) {
    if (!scale) {
      scale = { sx: 1, sy: 1 };
    }

    var halfWidth = baseRadius * scale.sx;
    var halfHeight = baseRadius * scale.sy;
    var x0 = xc - halfWidth;
    var x1 = xc + halfWidth;
    var y0 = yc - halfHeight;
    var y1 = yc + halfHeight;

    context.beginPath();
    context.moveTo(x0, y0);
    context.lineTo(x1, y0);
    context.lineTo(x1, y1);
    context.lineTo(x0, y1);
    context.lineTo(x0, y0);
    context.stroke();
  }

  function renderImage() {
    context.drawImage(imageObj, 0, 0, imageObj.width, imageObj.height, xOffset, yOffset, widthCompressed, heightCompressed);
  }

  function clipImage(imageFile, onCompleted) {
    isCliping = true;
    var imageUrl;
    if (!imageFile) {
      imageFile = "/img/welcome-bkg-phone.jpg";
    }

    if (TQUtility.isLocalFile(imageFile)) {
      imageUrl = TQUtility.fileToUrl(imageFile, { crossOrigin: "Anonymous" });
    } else {
      imageUrl = imageFile;
    }
    imageFileOrBlob = imageFile; // File, url, blob
    if (!canvas) {
      canvas = document.getElementById("clipCanvas");
      clipDiv = document.getElementById("clip-div");
      context = canvas.getContext("2d");
      canvas.width = TQ.State.innerWidth;
      canvas.height = TQ.State.innerHeight;
      canvasWidth = canvas.width;
      canvasHeight = canvas.height;
    }
    xc = canvasWidth / 2;
    yc = canvasHeight / 2;
    radius = baseRadius;
    clipDiv.style.display = "block";
    TQ.TouchManager.save();
    TQ.TouchManager.attachOps(clipOps, canvas);

    onClipCompleted = onCompleted;
    resourceReady = false;
    imageObj.src = imageUrl;
    imageObj.onload = function(ev) {
      var minWidth = Math.min(canvasWidth, imageObj.width); var // 不放大， 只缩小
        minHeight = Math.min(canvasHeight, imageObj.height);
      var sx = minWidth / imageObj.width;
      var sy = minHeight / imageObj.height;
      var sxy = Math.min(sx, sy);

      minWidth = sxy * imageObj.width;
      minHeight = sxy * imageObj.height;
      widthCompressed = minWidth;
      heightCompressed = minHeight;
      xOffset = (canvasWidth - widthCompressed) / 2;
      yOffset = (canvasHeight - heightCompressed) / 2;
      xc = xOffset + (widthCompressed / 2);
      yc = yOffset + (heightCompressed / 2);
      scale.sx = Math.min(0.5 * widthCompressed / baseRadius, 0.5 * heightCompressed / baseRadius);
      scale.sy = scale.sx;
      radius = baseRadius;
      resourceReady = true;
      mainLoop();
    };
  }

  function doClip(x0, y0, scale) {
    /*
	 * save() allows us to save the canvas context before
	 * defining the clipping region so that we can return
	 * to the default state later on
	 */
    context.save();
    setClip(x0, y0, scale);
    renderImage();
    /*
	 * restore() restores the canvas context to its original state
	 * before we defined the clipping region
	 */
    context.restore();
  }

  function mainLoop() {
    if (resourceReady) {
      context.clearRect(0, 0, canvas.width, canvas.height);
      doClip(xc, yc, scale);
    }
    if (isCliping) {
      requestAnimationFrame(mainLoop);
    }
  }
  function confirm() {
    if (maskType === MASK_TYPE_NO) {
      return skip();
    }

    setTimeout(getClipResult(function(imageClipedData) {
      var image3Obj = new Image();
      image3Obj.onload = function(ev) {
        // context.drawImage(imageObj, 0, 0);
        // context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(image3Obj, 0, 0);
      };
      image3Obj.src = imageClipedData;
    }));
  }

  function skip() {
    // 不clip， 直接把原图返回
    setTimeout(function() {
      if ((imageObj.width > canvasWidth) || (imageObj.height > canvasHeight)) {
        // 图像太大， 必须压缩
        var w = Math.min(canvasWidth, widthCompressed);
        var h = Math.min(canvasHeight, heightCompressed);
        compressImage(imageObj, w, h, complete);
      } else {
        complete(imageFileOrBlob);
      }
    });
  }

  function cancel() {
    setTimeout(function() {
      complete(null);
    });
  }

  function getClipResult(callback) {
    var image1Data = canvas.toDataURL("image/png"); // 默认生成透明图, 带alpha信息, PNG格式的
    var imageObj2 = new Image();
    console.log(image1Data.length);

    function drawClippedResult() {
      var widthClip;
      var heightClip;
      var xs = xc - radius;
      var ys = yc - radius;
      var xe = xc + radius;
      var ye = yc + radius;
      var canvas2 = document.createElement("canvas");
      var ctx;

      // 裁剪出的区域，不能超出图像的边界
      if (xs < xOffset) {
        xs = xOffset;
      }

      if (ys < yOffset) {
        ys = yOffset;
      }

      if (xe > (xOffset + widthCompressed)) {
        xe = xOffset + widthCompressed;
      }

      if (ye > (yOffset + heightCompressed)) {
        ye = yOffset + heightCompressed;
      }
      widthClip = xe - xs;
      heightClip = ye - ys;
      canvas2.width = widthClip;
      canvas2.height = heightClip;
      ctx = canvas2.getContext("2d");
      ctx.drawImage(imageObj2, xs, ys, widthClip, heightClip, 0, 0, widthClip, heightClip);
      setTimeout(function() {
        var image2Data = canvas2.toDataURL("image/png");
        console.log(image2Data.length);
        if (callback) {
          callback(image2Data);
        }
        complete(image2Data);
      });
    }

    imageObj2.onload = drawClippedResult;
    imageObj2.src = image1Data;
  }

  function compressImage(imageObj, destWidth, destHeight, callback) {
    var canvas2 = document.createElement("canvas");
    var ctx;

    canvas2.width = destWidth;
    canvas2.height = destHeight;
    ctx = canvas2.getContext("2d");
    ctx.drawImage(imageObj, 0, 0, imageObj.width, imageObj.height, 0, 0, destWidth, destHeight);
    setTimeout(function() {
      if (callback) {
        callback(canvas2.toDataURL("image/png"));
      }
    });
  }

  function complete(imageData) {
    isCliping = false;
    if (onClipCompleted) {
      if (!imageData) {
        // Canceled
      } else if (imageData instanceof File) { // 对于未clip的原文件
        imageData = TQUtility.fileToUrl(imageData);
      } else if (!TQ.Utility.isImage64(imageData)) {
        TQ.AssertExt.invalidLogic(false, "错误：未知的图像数据!");
      }

      onClipCompleted(imageData);
    }
    TQ.TouchManager.restore();
    clipDiv.style.display = "none";
  }

  function onTouchOrDragStart(e) { // ==mouse的onPressed，
    if (e.type === "mousedown") {
      document.addEventListener("keyup", onKeyUp);
      document.addEventListener("mouseup", onKeyUp);
    }

    TQ.Log.debugInfo("touch start or mousedown" + TQ.Utility.getTouchNumbers(e));
    touchStarted = true;
    updateStartElement(e);
    e.stopPropagation();
    e.preventDefault();
  }

  function onTouchOrDragEnd(e) {
    touchStarted = false;
    if (e.type === "mouseup") {
      document.removeEventListener("keyup", onKeyUp);
      TQ.TouchManager.detachHandler("mousemove", onDrag);
    }

    TQ.Log.debugInfo("touch end, or mouse up " + TQ.Utility.getTouchNumbers(e));
  }

  function updateStartElement(e) {
    resetStartParams(e);
    if (TQ.Utility.isMouseEvent(e)) {
      TQ.TouchManager.attachHandler("mousemove", onDrag);
    }
  }

  function resetStartParams(e) {
    if (!touchStarted) {
      return;
    }
    eleStart.needReset = false;
    eleStart.scale.sx = scale.sx; // 不能用object相等， 那是指针！！！
    eleStart.scale.sy = scale.sy;
    eleStart.xc = xc;
    eleStart.yc = yc;
    if (!eleStart.deltaScale) {
      eleStart.deltaScale = new TQ.ScaleCalculator();
    }
    eleStart.deltaScale.reset();

    var evt = touch2StageXY(e);
    mouseStart = { stageX: evt.stageX, stageY: evt.stageY, firstTime: true };
  }

  function onPinchAndRotate(e) {
    if (!touchStarted) {
      return onTouchOrDragStart(e);
    }
    eleStart.deltaScale.determineScale(null, e);

    if (!isNaN(eleStart.deltaScale.sx) &&
      !isNaN(eleStart.deltaScale.sy) &&
      (Math.abs(eleStart.deltaScale.sx) > 0.00001) &&
      (Math.abs(eleStart.deltaScale.sx) > 0.00001)) {
      doScale(eleStart.deltaScale);
    }
  }

  function doScale(deltaScale) {
    var sx = eleStart.scale.sx * deltaScale.sx;
    var sy = eleStart.scale.sy * deltaScale.sy;
    if ((sx * baseRadius < widthCompressed) || (sy * baseRadius < heightCompressed)) {
      scale.sx = sx;
      scale.sy = sy;
    }
  }

  function onMouseDown(e) {
    return onTouchOrDragStart(e);
  }

  function onMouseUp(e) {
    return onTouchOrDragEnd(e);
  }

  function onRelease() {
  }

  function onDrag(e) { // // ==mouse的onMove，
    if (e.type === "mousemove") {
      return;
    }
    if (!touchStarted) {
      return onTouchOrDragStart(e);
    }

    e = touch2StageXY(e);
    e.stopPropagation();
    e.preventDefault();
    doDrag(mouseStart, e);
  }

  function doDrag(pStart, evt) {
    if (!touchStarted) {
      return onTouchOrDragStart(evt);
    }

    xc = eleStart.xc + (evt.stageX - pStart.stageX);
    yc = eleStart.yc + evt.stageY - pStart.stageY;
  }

  function onKeyUp() {
    document.removeEventListener("keyup", onKeyUp);
    document.removeEventListener("mouseup", onKeyUp);
  }

  function touch2StageXY(e) { // 让ionic的 touch 和mouse 兼容createJs格式中部分参数
    var touches = TQ.Utility.getTouches(e);
    if (touches.length > 0) {
      var touch = touches[0];
      e.stageX = touch.pageX;
      e.stageY = touch.pageY;
    } else {
      TQ.AssertExt.invalidLogic(false, "应该有touch点");
    }

    return e;
  }

  function notHandled(e) {
    TQ.Log.debugInfo("event not handled: " + e.type + ", " + (e.touches ? e.touches.length : 0));
  }
}());

/**
 * Created by admin on 9/12/2015.
 */
angular.module("starter").factory("DeviceService", DeviceService);
function DeviceService() {
  var rootFolder;
  var _isReady = false;

  function getFullPath(file) {
    return (rootFolder + file);
  }

  function isReady() {
    return _isReady;
  }

  function initialize() {
    TQ.Log.debugInfo("device initialize... ");
    if (TQ.Base.Utility.isMobileDevice() && (typeof cordova !== "undefined")) {
      onFileSystemReady();
    } else { // for Chrome Desktop
      document.addEventListener(ImgCache.FILE_SYSTEM_READY, onFileSystemReady, false);
      ImgCache.options.debug = true;
      ImgCache.options.usePersistentCache = true;
      ImgCache.init();
    }
  }

  function onFileSystemReady() {
    TQ.Log.debugInfo("onFileSystemReady .....");
    if (TQ.Base.Utility.isMobileDevice()) {
      if (!TQ.Base.Utility.isCordovaDevice()) { // for Chrome simulator
        rootFolder = ImgCache.getRoot();
      } else {
        rootFolder = cordova.file.dataDirectory;
      }
    } else {
      rootFolder = ImgCache.getRoot();
    }
    TQ.Log.debugInfo("rootFolder = " + rootFolder);

    if (rootFolder !== "") {
      if ((rootFolder[rootFolder.length - 1] !== "/") && (rootFolder[rootFolder.length - 1] !== "\\")) {
        rootFolder += "/";
      }
    }
    TQ.Config.CacheRootFolder = rootFolder;
    _isReady = true;
    TQ.Log.debugInfo("TQ.Config.CacheRootFolder = " + TQ.Config.CacheRootFolder);
    TQ.Base.Utility.triggerEvent(document, TQ.EVENT.FILE_SYSTEM_READY);
    TQ.Log.debugInfo("onFileSystemReady leave .....");
  }

  // private function:
  return {
    initialize: initialize,
    isReady: isReady,
    getRootFolder: function() {
      return rootFolder;
    },
    getFullPath: getFullPath
  };
}

/**
 * Uses the new array typed in javascript to binary base64 encode/decode
 * at the moment just decodes a binary base64 encoded
 * into either an ArrayBuffer (decodeArrayBuffer)
 * or into an Uint8Array (decode)
 *
 * References:
 * https://developer.mozilla.org/en/JavaScript_typed_arrays/ArrayBuffer
 * https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array
 */

var Base64Binary = {
  _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

  /* will return a  Uint8Array type */
  decodeArrayBuffer: function(input) {
    var bytes = (input.length / 4) * 3;
    var ab = new ArrayBuffer(bytes);
    this.decode(input, ab);

    return ab;
  },

  removePaddingChars: function(input) {
    var lkey = this._keyStr.indexOf(input.charAt(input.length - 1));
    if (lkey === 64) {
      return input.substring(0, input.length - 1);
    }
    return input;
  },

  decode: function(input, arrayBuffer) {
    // get last chars to see if are valid
    input = this.removePaddingChars(input);
    input = this.removePaddingChars(input);

    var bytes = parseInt((input.length / 4) * 3, 10);

    var uarray;
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var j = 0;

    if (arrayBuffer) { uarray = new Uint8Array(arrayBuffer); } else { uarray = new Uint8Array(bytes); }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    for (let i = 0; i < bytes; i += 3) {
      // get the 3 octects in 4 ascii chars
      enc1 = this._keyStr.indexOf(input.charAt(j++));
      enc2 = this._keyStr.indexOf(input.charAt(j++));
      enc3 = this._keyStr.indexOf(input.charAt(j++));
      enc4 = this._keyStr.indexOf(input.charAt(j++));

      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;

      uarray[i] = chr1;
      if (enc3 !== 64) uarray[i + 1] = chr2;
      if (enc4 !== 64) uarray[i + 2] = chr3;
    }

    return uarray;
  }
};

/**
 * Created by admin on 9/9/2015.
 * FileService：提供本地文件存取IO，用于WCY文件及其screenshot的保存
 *     （对App是本地文件， 对PC用cache文件系统来模拟。
 * 主要接口是
 *    .saveImage64
 *    .saveFile
 * 在WCYService中使用
 */
angular.module("starter").factory("FileService", FileService);
FileService.$inject = ["$cordovaFile", "DeviceService"];

function FileService($cordovaFile, DeviceService) {
  var rootFolder = "";

  function createDir(dir, onSuccess, onError) {
    // 确保建立， 避免重复建立
    rootFolder = DeviceService.getRootFolder();
    var finalPath = DeviceService.getFullPath(dir);
    if (dir[dir.length - 1] === "/") {
      dir = dir.substr(0, dir.length - 1);
    }

    if (TQ.Base.Utility.isMobileDevice() && TQ.Base.Utility.isCordovaDevice()) {
      $cordovaFile.checkDir(rootFolder, dir)
        .then(function(success) {
          if (onSuccess) onSuccess(success);
        }, function(error) {
          console.error(error);
          $cordovaFile.createDir(rootFolder, dir, false)
            .then(onSuccess, onError);
        });
    } else {
      ImgCache.createDir(dir, onSuccess, onError);
    }
  }

  function saveFile(fullPath, data, onSuccess, onError) {
    // WRITE
    if (!TQ.Base.Utility.isMobileDevice()) {
      var cachePath = TQ.RM.toCachePath(fullPath);
      ImgCache.WriteFile(fullPath, cachePath, data, onSuccess, onError);
      return cachePath;
    }

    var fullname = TQ.Base.Utility.urlConcat(DeviceService.getRootFolder(), fullPath);
    $cordovaFile.writeFile(DeviceService.getRootFolder(), fullPath, data, true)
      .then(onSuccess, onError);

    return fullname;
  }

  function saveImage64(fullPath, image64Data, onSuccess, onError) {
    image64Data = image64Data.replace(/^data:image\/\w+;base64,/, "");
    image64Data = new Blob([Base64Binary.decodeArrayBuffer(image64Data)], { type: "image/png", encoding: "utf-8" });
    return saveFile(fullPath, image64Data, onSuccess, onError);
  }

  function saveWcy(fullPath, data, onSuccess, onError) {
    data = new Blob([data], { type: "text/plain" });
    return saveFile(fullPath, data, onSuccess, onError);
  }

  function onSuccess(info) {
    if (info) {
      TQ.Log.info(JSON.stringify(info));
    }
  }

  function onError(e) {
    if (e) {
      TQ.Log.info(JSON.stringify(e));
    }
  }

  function readFile(fullPath) {
    // WRITE
    if (!TQ.Base.Utility.isMobileDevice()) {
      return;
    }
    return $cordovaFile.readAsText(DeviceService.getRootFolder(), fullPath);
  }

  function testFilePathOP() {
    rootFolder = cordova.file.dataDirectory;
    $cordovaFile.getFreeDiskSpace()
      .then(function(success) {
        // success in kilobytes
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // CHECK
    $cordovaFile.checkDir(rootFolder, "demoDir1")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    $cordovaFile.checkFile(rootFolder, "demoFile1.txt")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // CREATE
    $cordovaFile.createDir(rootFolder, "demoDir1", false)
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    $cordovaFile.createFile(rootFolder + "/demoDir1", "demoFile2.txt", true)
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // WRITE
    $cordovaFile.writeFile(rootFolder, "demoFile3.txt", "demo data huge buffer end", true)
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // READ
    $cordovaFile.readAsText(rootFolder, "demoFile3.txt")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    $cordovaFile.writeExistingFile(rootFolder, "demoFile3.txt", "overriteFile")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // READ
    $cordovaFile.readAsText(rootFolder, "demoFile3.txt")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // MOVE
    $cordovaFile.moveDir(rootFolder, "dir", cordova.file.tempDirectory, "demoDir1")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    $cordovaFile.moveFile(rootFolder, "demoFile3.txt", cordova.file.tempDirectory)
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    // COPY
    $cordovaFile.copyDir(rootFolder, "dir", cordova.file.tempDirectory, "demoDir1")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    $cordovaFile.copyFile(rootFolder, "demoFile3.txt", cordova.file.tempDirectory, "demoFile2.txt")
      .then(function(success) {
        TQ.Log.debugInfo(success);
      }, function(error) {
        TQ.Log.error(error);
      });

    /*            // REMOVE
         $cordovaFile.removeDir(rootFolder, "demoDir1")
         .then(function (success) {
         TQ.Log.debugInfo(success);
         }, function (error) {
         TQ.Log.error(error);
         });

         $cordovaFile.removeFile(rootFolder +"/demoDir1", "demoFile1.txt")
         .then(function (success) {
         TQ.Log.debugInfo(success);
         }, function (error) {
         TQ.Log.error(error);
         });

         $cordovaFile.removeRecursively(rootFolder, "demoDir1")
         .then(function (success) {
         TQ.Log.debugInfo(success);
         }, function (error) {
         TQ.Log.error(error);
         });
         */
  }

  return {
    createDir: createDir,
    saveFile: saveFile,
    saveImage64: saveImage64,
    saveWcy: saveWcy,
    readFile: readFile,
    testFilePathOP: testFilePathOP
  };
}

/**
 * Created by admin on 9/11/2015.
 * NetService： 上传素材（image或者mp3）到clound服务器，主要接口是
 *     * uploadOne
 * 在controller中直接使用
 */
angular.module("starter").factory("NetService", NetService);
NetService.$inject = ["$q", "$http", "$cordovaFileTransfer", "Upload"];

function NetService($q, $http, $cordovaFileTransfer, Upload) {
  var baseUrl = TQ.Config.BONE_HOST;
  var urlConcat = TQ.Base.Utility.urlConcat;
  var IMAGE_CLOUD_URL = TQ.Config.MAT_UPLOAD_API;
  var C_OPUS_URL = TQ.Config.MAN_HOST + "/wcyList";
  const C_MAN_URL = TQ.Config.MAN_HOST + "/material";

  function isFullPath(url) {
    var protocols = ["http://", "https://"];
    for (var i = 0; i < protocols.length; i++) {
      if (url.indexOf(protocols[i]) === 0) {
        return true;
      }
    }
    return false;
  }

  function uploadImages(files, onSuccess) {
    if (!files) return;
    var surplus = files.length;

    function _onSuccess() {
      if ((--surplus) === 0) {
        onSuccess();
      }
    }

    angular.forEach(files, function(file) {
      uploadOne(file, _onSuccess);
    });
  }

  function uploadOne(file, matType, option) { // upload one material, fileOrBuffer
    option = option || {};
    var q = $q.defer();
    TQ.Assert.isTrue(!!file, "文件不能为null");
    if (option.type !== undefined) {
      TQ.Log.error("==> upgrade: type to matType");
    }
    option.matType = matType;

    if (TQUtility.isLocalFileOrBlob(file)) {
      if (!file.name) {
        file.name = generateName(file);
      }
      option.filename = file.name;
      if (file.isWx) {
        TQ.Log.alertInfo("isWx");
        TQ.Log.alertInfo(JSON.stringify(file));
        get(file.path);
      }
    } else {
      var filename = hasFileName(file) ? file.name
        : (isFullPath(file) ? file : getImageNameWithoutExt());
      option.filename = filename;
      option.tags = "myphotoalbum";
      option.context = "photo=" + "No";
    }
    createMatId(option)
      .success(onMatIdCreated)
      .error(onError);

    function onError(event, status, headers, config) {
      TQ.MessageBox.warn("hey, the network connection lost");
      TQ.Log.alertInfo("error" + angular.toJson(event));
      q.reject(event);
    }

    function onMatIdCreated(pkg) {
      if (pkg.existPath) {
        pkg.url = pkg.existPath;
        q.resolve(pkg);
      } else {
        return doUploadMat(pkg);
      }
    }

    function doUploadMat(signData) {
      doUploadImage(signData, file, option).success(onLoadedSuccess).error(onError);
    }

    function onLoadedSuccess(data, status, headers, config) {
      file.result = data;
      TQ.Log.debugInfo(data);
      data.type = matType; // ToDo: delete type, which is replaced by matType
      data.matType = matType;
      updateMat(data);
      q.resolve(data);
      TQ.MessageBox.hide();
    }

    return q.promise;
  }

  function doUploadImage(signData, fileOrBuffer, option) {
    if (option && !option.useBackgroundMode) {
      TQ.MessageBox.showWaiting(TQ.Locale.getStr("uploading..."));
    }
    // TQ.Log.debugInfo(JSON.stringify(signData)); // 图像数据太大
    signData.api_key = TQ.Config.Cloudinary.api_key;
    var res;
    if (TQUtility.isLocalFileOrBlob(fileOrBuffer)) {
      signData.file = fileOrBuffer;
      res = doUploadLocalFile(signData);
      res.progress(function(e) {
        fileOrBuffer.progress = Math.round((e.loaded * 100.0) / e.total);
        fileOrBuffer.status = "Uploading... " + fileOrBuffer.progress + "%";
      });
    } else {
      signData.file = hasFileName(fileOrBuffer) ? fileOrBuffer.data : fileOrBuffer;
      res = doSubmitImage64(signData);
    }

    return res;
  }

  function doUploadLocalFile(data) {
    return Upload.upload({
      url: IMAGE_CLOUD_URL,
      fields: data
    });
  }

  function doSubmitImage64(data) {
    return $http.post(IMAGE_CLOUD_URL, angular.toJson(data));
  }

  function getByXHR(uri) {
    // CHROME - browsers
    var xhr = new XMLHttpRequest();
    TQ.Log.alertInfo("X1: " + uri);
    xhr.open("GET", uri, true);
    xhr.responseType = "blob";
    var headers = {};
    xhr.onload = function() {
      TQ.Log.alertInfo("X2");
      TQ.Log.alertInfo(xhr.response.size + ",  " + xhr.response.type);
      if (xhr.response && (xhr.status === 200 || xhr.status === 0)) {
        TQ.Log.alertInfo("X2.5");
      } else {
        TQ.Log.alertInfo("Image could not be downloaded: " + xhr.status);
      }
    };
    xhr.onerror = function() {
      TQ.Log.alertInfo("X3 : " + xhr.status);
    };
    xhr.send();
  }

  function get(url, onSuccess, onError) {
    TQ.Log.alertInfo("Get 1 : " + url);
    var urlSource, urlTarget;
    var trustHosts = true;
    var options = {};
    if (typeof url === "string") {
      urlSource = url;
      urlTarget = TQ.RM.toCachePath(urlSource);
    } else {
      urlSource = url.source;
      urlTarget = url.target;
    }

    if (TQ.Base.Utility.isMobileDevice() && TQ.Base.Utility.isCordovaDevice()) {
      TQ.Log.alertInfo("Get 3");
      $cordovaFileTransfer.download(urlSource, urlTarget, options, trustHosts)
        .then(function(result) {
          TQ.Log.debugInfo(result);
          onSuccess(result);
        }, function(err) {
          TQ.Log.error(err);
          onError(err);
        }, function(progress) {
          var ratio = progress.loaded / progress.total;
          TQ.Log.debugInfo(ratio + ": " + progress);
          // $timeout(function () {
          // $scope_downloadProgress = (progress.loaded / progress.total) * 100;
          // })
        });
    } else {
      TQ.Log.alertInfo(" 4 ImageCache OK??");
      ImgCache.cacheFile(urlSource, urlTarget, onSuccess, onError);
    }
  }

  function put(path) {
    console.error("depreciated??? replace by post??");
    var url = urlConcat(baseUrl, path);
    TQ.Log.debugInfo("put " + path + " to ===> " + url);
  }

  var counter = 100;

  function getImageNameWithoutExt() {
    // the Cloundary will automatically add extion '.png'
    return "p" + (counter++);
  }

  var createMatId = function(option) {
    if (!option.useBackgroundMode) {
      // TQ.MessageBox.showWaiting(TQ.Locale.getStr('get material ID...'));
    }
    return $http.post(C_MAN_URL, angular.toJson(option));
  };

  function updateMat(data) {
    var data2 = {
      path: TQ.RM.toRelative(data.url),
      public_id: data.public_id,
      matType: data.type
    };

    return doUpdateMat(data2);
  }

  function requestToShareMat(data) {
    data.requestToShare = true;
    doUpdateMat(data);
  }

  function requestToBanMat(data) {
    data.requestToBan = true;
    doUpdateMat(data);
  }

  function shareMat(data) {
    data.share = true;
    doUpdateMat(data);
  }

  function banMat(data) {
    data.ban = true;
    doUpdateMat(data);
  }

  function requestToShareOpus(opus) {
    var url = C_OPUS_URL + "/apply/" + opus.wcyId;
    doUpdateOpus(url);
  }

  function shareOpus(opus) { // 批准发布作品，approveToShareOpus
    var url = C_OPUS_URL + "/approve/" + opus.wcyId;
    return doUpdateOpus(url);
  }

  function refineOpus(opus) { // 批准发布作品，approveToShareOpus
    var url = C_OPUS_URL + "/refine/" + opus.wcyId;
    return doUpdateOpus(url);
  }

  function requestToBanOpus(opus) {
    TQ.Log.warn("服务器尚未实现此命令，暂时");
    var url = C_OPUS_URL + "/requestToBan/" + opus.wcyId;
    doUpdateOpus(url);
  }

  function banOpus(opus) {
    var url = C_OPUS_URL + "/ban/" + opus.wcyId;
    doUpdateOpus(url);
  }

  function addSprite(sound) {
    doUpdateMat(sound, "sprite/");
  }

  function doUpdateOpus(url) {
    return $http.get(url).then(function(pkg) { // 发出event， 好让dataService等更新自己
      TQUtility.triggerEvent(document, TQ.EVENT.MAT_CHANGED, { matType: TQ.MatType.OPUS });
    });
  }

  function doUpdateMat(data, path) {
    var url = C_MAN_URL;
    if (path) {
      url = url + "/" + path;
    }
    TQ.AssertExt.isNotNull(data.matType, "db必须的参数");
    return $http.post(url, angular.toJson(data)).then(function(pkg) { // 发出event， 好让dataService等更新自己
      TQUtility.triggerEvent(document, TQ.EVENT.MAT_CHANGED, { matType: data.matType });
    });
  }

  function update(path) {
    TQ.AssertExt.depreciated("是不是无用了？");
    var url = urlConcat(baseUrl, path);
    TQ.Log.debugInfo("update: " + path + " to ==> " + url);
  }

  function del(path) { // delete is reserved key word!!!
    var url = urlConcat(baseUrl, path);
    TQ.Log.debugInfo("delete: " + url);
  }

  function initialize() {
    document.addEventListener(TQ.DownloadManager.DOWNLOAD_EVENT, onDownload, false);
  }

  // private functions:
  function onDownload(evt) {
    var data = evt.data;

    function onSuccess() {
      TQ.DownloadManager.onCompleted(data);
    }

    function onError(error) {
      TQ.DownloadManager.onError(error, data);
    }

    if (data) {
      get(data, onSuccess, onError);
    }
  }

  function hasFileName(file) {
    return (!!file.name);
  }

  function generateName(blobOrBuffer) {
    var prefix = {
      "audio": "配音",
      "image": "照片"
    };
    var dateString = (new Date()).toLocaleString().replace(/[^0-9]/g, "-");

    if (blobOrBuffer.type) {
      var words = blobOrBuffer.type.split("/");
      var type = words[0];
      var extension = words[words.length - 1];
    }

    return prefix[type] + dateString + "." + extension;
  }

  function addTopic(topic) {
    updateTopic(topic);
  }

  function banTopic(topic) {
    topic.ban = true;
    updateTopic(topic);
  }

  function shareTopic(topic) {
    topic.share = true;
    updateTopic(topic);
  }

  function updateTopic(topic) {
    var url = TQ.Config.OPUS_HOST + "/topic";
    if (TQ.State.isAudit) {
      url += "?isAudit=true";
    }
    $http.post(url, JSON.stringify(topic)).then(function(value) {
      console.log(value);
    },
    function(reason) {
      console.log(reason);
    });
  }

  function attachTopic(matType, matId, topicId) {
    doUpdateMatTopic("attachTopic", {
      matType: matType,
      matId: matId,
      topicId: topicId
    });
  }

  function detachTopic(matType, matId, topicId) {
    doUpdateMatTopic("detachTopic", {
      matType: matType,
      matId: matId,
      topicId: topicId
    });
  }

  function doUpdateMatTopic(operation, data) {
    var url = C_MAN_URL + "/" + operation;
    TQ.AssertExt.isNotNull(data.matType, "db必须的参数");
    $http.post(url, JSON.stringify(data)).then(function(value) {
      console.log(value);
      // 发出event， 好让dataService等更新自己
      TQUtility.triggerEvent(document, TQ.EVENT.MAT_CHANGED, { matType: data.matType });
    },
    function(reason) {
      console.log(reason);
    });
  }

  return {
    banMat: banMat, // 先ban， 后 delete, 不要急于删除， 以避免有些作品还在使用它们
    shareMat: shareMat,
    requestToShareMat: requestToShareMat,
    requestToBanMat: requestToBanMat,

    addSprite: addSprite,
    requestToBanOpus: requestToBanOpus,
    banOpus: banOpus, // 先ban， 后 delete, 不要急于删除， 以避免有些作品还在使用它们

    requestToShareOpus: requestToShareOpus,
    refineOpus: refineOpus,
    shareOpus: shareOpus,

    addTopic: addTopic,
    updateTopic: updateTopic,
    attachTopic: attachTopic,
    detachTopic: detachTopic,
    banTopic: banTopic,
    shareTopic: shareTopic,

    initialize: initialize,
    get: get,
    put: put,
    uploadImages: uploadImages,
    uploadOne: uploadOne,
    doUploadImage: doUploadImage,
    update: update,
    del: del
  };
}

/* jslint browser:true*/
/*global console,LocalFileSystem,device,FileTransfer,define,module*/
/*
 * ChromeFile: 在PC上用Chrome文件系统模拟app的本地文件， 实现离线的编辑和存储
 */

var ImgCache = {
  version: "1.0rc1",
  // options to override before using the library (but after loading this script!)
  options: {
    debug: false, /* call the log method ? */
    localCacheFolder: "imgcache", /* name of the cache folder */
    chromeQuota: 10 * 1024 * 1024, /* allocated cache space : here 10MB */
    usePersistentCache: true, /* false = use temporary cache storage */
    cacheClearSize: 0, /* size in MB that triggers cache clear on init, 0 to disable */
    headers: {}, /* HTTP headers for the download requests -- e.g: headers: { 'Accept': 'application/jpg' } */
    skipURIencoding: false /* enable if URIs are already encoded (skips call to sanitizeURI) */
  },
  overridables: {
    log: function(str, level) {
      "use strict";
      if (ImgCache.options.debug) {
        if (level === LOG_LEVEL_INFO) { str = "INFO: " + str; }
        if (level === LOG_LEVEL_WARNING) { str = "WARN: " + str; }
        if (level === LOG_LEVEL_ERROR) { str = "ERROR: " + str; }
        TQ.Log.debugInfo(str);
      }
    }
  },
  ready: false,
  attributes: {}
};
var LOG_LEVEL_INFO = 1;
var LOG_LEVEL_WARNING = 2;
var LOG_LEVEL_ERROR = 3;

(function($) {
  "use strict";

  /** Helpers *****************************************************************/
  var Helpers = {};

  // make sure the url does not contain funny characters like spaces that might make the download fail
  Helpers.sanitizeURI = function(uri) {
    if (ImgCache.options.skipURIencoding) {
      return uri;
    } else {
      var encodedURI = encodeURI(uri);
      return encodedURI;
    }
  };

  // with a little help from http://code.google.com/p/js-uri/
  Helpers.URI = function(str) {
    if (!str) { str = ""; }
    // Based on the regex in RFC2396 Appendix B.
    var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
    var result = str.match(parser);
    this.scheme = result[1] || null;
    this.authority = result[2] || null;
    this.path = result[3] || null;
    this.query = result[4] || null;
    this.fragment = result[5] || null;
  };
  // returns lower cased filename from full URI
  Helpers.URIGetFileName = function(fullpath) {
    if (!fullpath) {
      return;
    }
    // TODO: there must be a better way here.. (url encoded strings fail)
    var idx = fullpath.lastIndexOf("/");
    if (!idx) {
      return;
    }
    return fullpath.substr(idx + 1).toLowerCase();
  };

  // returns lower cased path from full URI
  Helpers.URIGetPath = function(str) {
    if (!str) {
      return;
    }
    var uri = Helpers.URI(str);
    return uri.path.toLowerCase();
  };

  // Returns a URL that can be used to locate a file
  Helpers.EntryGetURL = function(entry) {
    // toURL for html5, toURI for cordova 1.x
    return (typeof entry.toURL === "function" ? entry.toURL() : entry.toURI());
  };

  // Returns the full absolute path from the root to the FileEntry
  Helpers.EntryGetPath = function(entry) {
    return entry.fullPath;
  };

  /** Private *****************************************************************/
  var Private = { attributes: {}};

  Private.isImgCacheLoaded = function() {
    if (!ImgCache.attributes.filesystem || !ImgCache.attributes.dirEntry) {
      ImgCache.overridables.log("ImgCache not loaded yet! - Have you called ImgCache.init() first?", LOG_LEVEL_WARNING);
      return false;
    }
    return true;
  };

  Private.attributes.hasLocalStorage = false;
  Private.hasLocalStorage = function() {
    // if already tested, avoid doing the check again
    if (Private.attributes.hasLocalStorage) {
      return Private.attributes.hasLocalStorage;
    }
    try {
      var mod = TQ.Base.Utility.urlParser("imgcache_test").pathname;
      localStorage.setItem(mod, mod);
      localStorage.removeItem(mod);
      Private.attributes.hasLocalStorage = true;
      return true;
    } catch (e) {
      // this is an info, not an error
      ImgCache.overridables.log("Could not write to local storage: " + e.message, LOG_LEVEL_INFO);
      return false;
    }
  };

  Private.setCurrentSize = function(curSize) {
    ImgCache.overridables.log("current size: " + curSize, LOG_LEVEL_INFO);
    if (Private.hasLocalStorage()) {
      localStorage.setItem("imgcache:" + ImgCache.options.localCacheFolder, curSize);
    }
  };

  Private.getCachedFilePath = function(img_src) {
    return ImgCache.options.localCacheFolder + "/" + Private.getCachedFileName(img_src);
  };

  // used for FileTransfer.download only
  Private.getCachedFileFullPath = function(img_src) {
    var local_root = Helpers.EntryGetPath(ImgCache.attributes.dirEntry);
    return (local_root || "") + Private.getCachedFileName(img_src);
  };

  Private.getCachedFileName = function(img_src) {
    if (!img_src) {
      ImgCache.overridables.log("No source given to getCachedFileName", LOG_LEVEL_WARNING);
      return;
    }
    var nameInCache = TQ.Base.Utility.urlParser(img_src).pathname;
    return nameInCache;
  };

  Private.setNewImgPath = function() {};

  Private.createCacheDir = function(success_callback, error_callback) {
    var _fail = function(error) {
      ImgCache.overridables.log("Failed to get/create local cache directory: " + error.code, LOG_LEVEL_ERROR);
      if (error_callback) { error_callback(error); }
    };
    var _getDirSuccess = function(dirEntry) {
      ImgCache.attributes.dirEntry = dirEntry;
      ImgCache.overridables.log("Local cache folder opened: " + Helpers.EntryGetPath(dirEntry), LOG_LEVEL_INFO);
      if (success_callback) { success_callback(); }

      ImgCache.ready = true;
      TQ.Base.Utility.triggerEvent(document, ImgCache.FILE_SYSTEM_READY);
    };
    ImgCache.attributes.filesystem.root.getDirectory(ImgCache.options.localCacheFolder, { create: true, exclusive: false }, _getDirSuccess, _fail);
  };

  // This is a wrapper for phonegap's FileTransfer object in order to implement the same feature
  // in Chrome (and possibly extra browsers in the future)
  Private.FileTransferWrapper = function(filesystem) {
    this.filesystem = filesystem; // only useful for CHROME
  };

  Private.WriteFile = function(localPath, data, success_callback, error_callback) {
    var filesystem = ImgCache.attributes.filesystem;

    // assertTrue("需要本地的path， 不带host", TQ.Base.Utility.urlParser(localPath).host ==='');
    filesystem.root.getFile(localPath, { create: true }, function(fileEntry) {
      fileEntry.createWriter(function(writer) {
        writer.onerror = error_callback;
        writer.onwriteend = function() {
          if (success_callback) {
            success_callback(fileEntry);
          }
        };
        writer.write(data, error_callback);
      }, error_callback);
    }, error_callback);
  };

  Private.FileTransferWrapper.prototype.download = function(uri, localPath, success_callback, error_callback, on_progress) {
    var headers = ImgCache.options.headers || {};
    var isOnProgressAvailable = (typeof on_progress === "function");

    if (this.fileTransfer) {
      if (isOnProgressAvailable) {
        this.fileTransfer.onprogress = on_progress;
      }
      return this.fileTransfer.download(uri, localPath, success_callback, error_callback, false, { "headers": headers });
    }

    // CHROME - browsers
    var _fail = function(error, error_callback) {
      // mock up FileTransferError, so at least caller knows there was a problem.
      // Normally, the error.code in the callback is a FileWriter error, we return 0 if the error was an XHR error
      if (error_callback) {
        error.code = 0;
        error.source = uri;
        error.target = localPath;
        error_callback(error);
      } else {
        ImgCache.overridables.log(error, LOG_LEVEL_ERROR);
      }
    };
    var xhr = new XMLHttpRequest();
    xhr.open("GET", uri, true);
    if (isOnProgressAvailable) {
      xhr.onprogress = on_progress;
    }
    xhr.responseType = "blob";
    for (var key in headers) {
      xhr.setRequestHeader(key, headers[key]);
    }
    xhr.onload = function() {
      if (xhr.response && (xhr.status === 200 || xhr.status === 0)) {
        Private.WriteFile(localPath, xhr.response, success_callback, error_callback);
      } else {
        _fail({ msg: "Image could not be downloaded", http_status: xhr.status },
          error_callback);
      }
    };
    xhr.onerror = function() {
      _fail({ msg: "XHR error, could not be downloaded", http_status: xhr.status },
        error_callback);
    };
    xhr.send();
  };

  /** **************************************************************************/
  ImgCache.FILE_SYSTEM_READY = "imgCache ready";

  ImgCache.init = function(success_callback, error_callback) {
    if (!TQ.Config.ChromeFileEnabled) {
      TQ.Base.Utility.triggerEvent(document, ImgCache.FILE_SYSTEM_READY);
      return;
    }

    ImgCache.jQuery = !!((window.jQuery || window.Zepto)); /* using jQuery if it's available otherwise the DOM API */

    ImgCache.attributes.init_callback = success_callback;

    ImgCache.overridables.log("ImgCache initialising", LOG_LEVEL_INFO);

    var _checkSize = function(callback) {
      if (ImgCache.options.cacheClearSize > 0) {
        var curSize = ImgCache.getCurrentSize();
        if (curSize > (ImgCache.options.cacheClearSize * 1024 * 1024)) {
          ImgCache.clearCache(callback, callback);
        } else {
          if (callback) { callback(); }
        }
      } else {
        if (callback) { callback(); }
      }
    };
    var _gotFS = function(filesystem) {
      // store filesystem handle
      ImgCache.attributes.filesystem = filesystem;

      Private.createCacheDir(function() {
        _checkSize(ImgCache.attributes.init_callback);
      }, error_callback);
    };
    var _fail = function(error) {
      ImgCache.overridables.log("Failed to initialise LocalFileSystem " + error.code, LOG_LEVEL_ERROR);
      if (error_callback) { error_callback(error); }
    };

    // CHROME
    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    window.storageInfo = window.storageInfo || (ImgCache.options.usePersistentCache ? navigator.webkitPersistentStorage : navigator.webkitTemporaryStorage);
    if (!window.storageInfo) {
      ImgCache.overridables.log("Your browser does not support the html5 File API", LOG_LEVEL_WARNING);
      if (error_callback) { error_callback(); }
      return;
    }
    // request space for storage
    var quota_size = ImgCache.options.chromeQuota;
    window.storageInfo.requestQuota(
      quota_size,
      function() {
        /* success*/
        var persistence = (ImgCache.options.usePersistentCache ? window.storageInfo.PERSISTENT : window.storageInfo.TEMPORARY);
        window.requestFileSystem(persistence, quota_size, _gotFS, _fail);
      },
      function(error) {
        /* error*/
        ImgCache.overridables.log("Failed to request quota: " + error.message, LOG_LEVEL_ERROR);
        if (error_callback) { error_callback(error); }
      }
    );
  };

  ImgCache.getCurrentSize = function() {
    if (Private.hasLocalStorage()) {
      var curSize = localStorage.getItem("imgcache:" + ImgCache.options.localCacheFolder);
      if (curSize == null) {
        return 0;
      }
      return parseInt(curSize, 10);
    } else {
      return 0;
    }
  };

  // this function will not check if the image is already cached or not => it will overwrite existing data
  // on_progress callback follows this spec: http://www.w3.org/TR/2014/REC-progress-events-20140211/ -- see #54
  ImgCache.cacheFile = function(img_src, img_cache, success_callback, error_callback, on_progress) {
    if (!Private.isImgCacheLoaded() || !img_src) {
      return;
    }

    img_src = Helpers.sanitizeURI(img_src);

    var filePath = _toCacheRelative(img_cache); // Private.getCachedFileFullPath(img_src);

    var fileTransfer = new Private.FileTransferWrapper(ImgCache.attributes.filesystem);
    fileTransfer.download(
      img_src,
      filePath,
      function(entry) {
        entry.getMetadata(function(metadata) {
          if (metadata && Object.prototype.hasOwnProperty.call(metadata, "size")) {
            ImgCache.overridables.log("Cached file size: " + metadata.size, LOG_LEVEL_INFO);
            Private.setCurrentSize(ImgCache.getCurrentSize() + parseInt(metadata.size, 10));
          } else {
            ImgCache.overridables.log("No metadata size property available", LOG_LEVEL_INFO);
          }
        });
        ImgCache.overridables.log("Download complete: " + Helpers.EntryGetPath(entry), LOG_LEVEL_INFO);

        // iOS: the file should not be backed up in iCloud
        // new from cordova 1.8 only
        if (entry.setMetadata) {
          entry.setMetadata(
            function() {
              /* success*/
              ImgCache.overridables.log("com.apple.MobileBackup metadata set", LOG_LEVEL_INFO);
            },
            function() {
              /* failure */
              ImgCache.overridables.log("com.apple.MobileBackup metadata could not be set", LOG_LEVEL_WARNING);
            },
            { "com.apple.MobileBackup": 1 }
            // 1=NO backup oddly enough..
          );
        }

        if (success_callback) { success_callback(); }
      },
      function(error) {
        if ((!error.http_status) || (error.http_status !== 404)) {
          var msg = "下载文件出错";
          if (error.source) {
            msg += "，找不到文件：" + error.source;
          }

          if (!error.target) {
            msg += "，Cache中没有相应的目录！" + filePath;
          }

          msg += "， error code = " + error.code;
          TQ.Log.error(msg);
        } // else 由http系统报错
        error.handled = true;
        if (error_callback) { error_callback(error); }
      },
      on_progress
    );
  };

  // Returns the file already available in the cached
  // Reminder: this is an asynchronous method!
  // Answer to the question comes in response_callback as the second argument (first being the path)
  ImgCache.getCachedFile = function(img_src, response_callback) {
    // sanity check
    if (!Private.isImgCacheLoaded() || !response_callback) {
      return;
    }

    img_src = Helpers.sanitizeURI(img_src);

    var path = Private.getCachedFilePath(img_src);

    // try to get the file entry: if it fails, there's no such file in the cache
    ImgCache.attributes.filesystem.root.getFile(
      path,
      { create: false },
      function(file_entry) { response_callback(img_src, file_entry); },
      function() { response_callback(img_src, null); }
    );
  };

  // Returns the local url of a file already available in the cache
  ImgCache.getCachedFileURL = function(img_src, success_callback, error_callback) {
    var _getURL = function(img_src, entry) {
      if (!entry) {
        if (error_callback) { error_callback(img_src); }
      } else {
        success_callback(img_src, Helpers.EntryGetURL(entry));
      }
    };

    ImgCache.getCachedFile(img_src, _getURL);
  };

  // checks if a copy of the file has already been cached
  // Reminder: this is an asynchronous method!
  // Answer to the question comes in response_callback as the second argument (first being the path)
  ImgCache.isCached = function(img_src, response_callback) {
    ImgCache.getCachedFile(img_src, function(src, file_entry) {
      response_callback(src, file_entry != null);
    });
  };

  // clears the cache
  ImgCache.clearCache = function(success_callback, error_callback) {
    if (!Private.isImgCacheLoaded()) {
      return;
    }

    // delete cache dir completely
    ImgCache.attributes.dirEntry.removeRecursively(
      function() {
        ImgCache.overridables.log("Local cache cleared", LOG_LEVEL_INFO);
        Private.setCurrentSize(0);
        // recreate the cache dir now
        Private.createCacheDir(success_callback, error_callback);
      },
      function(error) {
        ImgCache.overridables.log("Failed to remove directory or its contents: " + error.code, LOG_LEVEL_ERROR);
        if (error_callback) { error_callback(error); }
      }
    );
  };

  ImgCache.removeFile = function(img_src, success_callback, error_callback) {
    img_src = Helpers.sanitizeURI(img_src);

    var filePath = Private.getCachedFilePath(img_src);
    var _fail = function(error) {
      ImgCache.overridables.log("Failed to remove file due to " + error.code, LOG_LEVEL_ERROR);
      if (error_callback) { error_callback(error); }
    };
    ImgCache.attributes.filesystem.root.getFile(filePath, { create: false }, function(fileEntry) {
      fileEntry.remove(
        function() {
          if (success_callback) { success_callback(); }
        },
        _fail
      );
    }, _fail);
  };

  // returns the URI of the local cache folder (filesystem:)
  // this function is more useful for the examples than for anything else..
  // Synchronous method
  ImgCache.getCacheFolderURI = function() {
    if (!Private.isImgCacheLoaded()) {
      return;
    }

    return Helpers.EntryGetURL(ImgCache.attributes.dirEntry);
  };

  ImgCache.WriteFile = function(filename, target, data, success_callback, error_callback) {
    // var localPath = Private.getCachedFileFullPath(filename);
    var localPath = _toCacheRelative(target);
    Private.WriteFile(localPath, data, success_callback, error_callback);
  };

  ImgCache.createDir = function(dirName, onSuccess, onError) {
    var _fail = function(error) {
      ImgCache.overridables.log("Failed to get/create local cache directory: " + error.code, LOG_LEVEL_ERROR);
      if (onError) onError(error);
    };
    var _getDirSuccess = function(dirEntry) {
      ImgCache.overridables.log("Local cache folder opened: " + Helpers.EntryGetPath(dirEntry), LOG_LEVEL_INFO);
      if (onSuccess) onSuccess(dirEntry);
    };

    var pathname = ImgCache.options.localCacheFolder + "/" + dirName;
    ImgCache.attributes.filesystem.root.getDirectory(pathname, { create: true, exclusive: false }, _getDirSuccess, _fail);
  };

  ImgCache.getRoot = function() {
    if (!TQ.Config.ChromeFileEnabled) {
      return "";
    }
    return Helpers.EntryGetURL(ImgCache.attributes.dirEntry);
  };

  // private methods can now be used publicly
  ImgCache.helpers = Helpers;
  ImgCache.private = Private;

  /** **************************************************************************/

  // Expose the class either via AMD, CommonJS or the global object
  if (typeof define === "function" && define.amd) {
    define("imgcache", [], function() {
      return ImgCache;
    });
  } else if (typeof module === "object" && module.exports) {
    module.exports = ImgCache;
  } else {
    window.ImgCache = ImgCache;
  }

  function _toCacheRelative(path) {
    var start = path.lastIndexOf(ImgCache.options.localCacheFolder);
    TQ.Assert.isTrue(start > 0, "target路径错误");
    return path.substr(start - 1);
  }
})(window.jQuery || window.Zepto || function() { TQ.AssertExt.invalidLogic(0, "jQuery is not available"); });

(function(exports) {
  // 公共方法
  var Util = {
    // 初始化
    init: function() {
      navigator.getUserMedia = navigator.getUserMedia ||
                                     navigator.webkitGetUserMedia ||
                                     navigator.mozGetUserMedia ||
                                     navigator.msGetUserMedia;

      window.AudioContext = window.AudioContext ||
                                  window.webkitAudioContext;
    },
    // 日志
    log: function() {
      console.log.apply(console, arguments);
    }
  };
    // 构造函数
  var Recorder = function(config) {
    var _this = this;
    var stopped = true;
    config = config || {}; // 初始化配置对象
    config.sampleRate = config.sampleRate || 44100; // 采样频率，默认为44100Hz(标准MP3采样率)
    config.bitRate = config.bitRate || 128; // 比特率，默认为128kbps(标准MP3质量)

    Util.init();

    if (navigator.getUserMedia) {
      navigator.getUserMedia({
        audio: true // 配置对象
      },
      function(stream) { // 成功回调
        var context = new AudioContext();
        var microphone = context.createMediaStreamSource(stream); // 媒体流音频源
        var processor = context.createScriptProcessor(16384, 1, 1); // js音频处理器
        var successCallback; var errorCallback;

        config.sampleRate = context.sampleRate;

        processor.onaudioprocess = function(event) {
          if (stopped) {
            Util.log("丢弃");
            return;
          }
          // 监听音频录制过程
          var array = event.inputBuffer.getChannelData(0);
          realTimeWorker.postMessage({ cmd: "encode", buf: array });
        };

        var realTimeWorker = new Worker("/worker.js"); // 开启后台线程
        realTimeWorker.onmessage = function(e) { // 主线程监听后台线程，实时通信
          switch (e.data.cmd) {
            case "init":
              Util.log("初始化成功");
              if (config.success) {
                config.success();
              }
              break;
            case "end":
              if (successCallback) {
                var blob = new Blob(e.data.buf, { type: "audio/mp3" });
                successCallback(blob);
                Util.log("MP3大小：" + blob.size + "%cB", "color:#0000EE");
              }
              break;
            case "error":
              Util.log("错误信息：" + e.data.error);
              if (errorCallback) {
                errorCallback(e.data.error);
              }
              break;
            default:
              Util.log("未知信息：" + e.data);
          }
        };
        // 接口列表
        // 开始录音
        _this.start = function() {
          if (processor && microphone) {
            realTimeWorker.postMessage({ cmd: "start" });
            microphone.connect(processor);
            processor.connect(context.destination);
            Util.log("开始录音");
            stopped = false;
          }
        };
        // 结束录音
        _this.stop = function() {
          realTimeWorker.postMessage({ cmd: "stop" });
          if (processor && microphone) {
            Util.log("录音结束");
            stopped = true;
          }
        };
        _this.close = function() {
          if (!stopped) {
            _this.stop();
          }
          if (microphone) {
            var tracks = microphone.mediaStream.getAudioTracks();
            tracks.forEach(function(track) {
              track.stop();
            });

            microphone.disconnect();
            microphone = null;
          }
          if (processor) {
            processor.disconnect();
            processor = null;
          }

          // stream.stop();
          context.close(); // 关闭AudioContext并释放资源，以便于其它app使用声音设备
          realTimeWorker.terminate();
        };
        // 获取blob格式录音文件
        _this.getBlob = function(onSuccess, onError) {
          successCallback = onSuccess;
          errorCallback = onError;
          realTimeWorker.postMessage({ cmd: "finish" });
        };
        realTimeWorker.postMessage({
          cmd: "init",
          config: {
            sampleRate: config.sampleRate,
            bitRate: config.bitRate
          }
        });
      },
      function(error) { // 失败回调
        var msg;
        switch (error.name || error.code) {
          case "SecurityError":
            msg = "安全错误，需要使用用https";
            break;
          case "PermissionDeniedError":
          case "PERMISSION_DENIED":
          case "NotAllowedError":
            msg = "用户拒绝访问麦克风";
            break;
          case "NOT_SUPPORTED_ERROR":
          case "NotSupportedError":
            msg = "浏览器不支持麦克风";
            break;
          case "MANDATORY_UNSATISFIED_ERROR":
          case "MandatoryUnsatisfiedError":
            msg = "找不到麦克风设备";
            break;
          default:
            msg = "无法打开麦克风，异常信息: error.code= " + error.code + ", error.name=" + error.name;
            break;
        }
        Util.log(msg);
        if (config.error) {
          config.error(msg);
        }
      });
    } else {
      Util.log("当前浏览器不支持录音功能");
      if (config.fix) {
        config.fix("当前浏览器不支持录音功能");
      }
    }
  };
    // 模块接口
  exports.Recorder = Recorder;
})(window);

/**
 * Created by Andrewz on 8/18/18.
 */
var TQ = TQ || {};
TQ.AudioRecorder = (function() {
  var CLOSE_MIC_WHEN_PENDING = true;
  var STATE_UNKNOWN = 0;
  var STATE_INITIALIZED = 1;
  var STATE_STARTED = 2;
  var STATE_PENDING = 3;
  var recorder = null;
  var state = STATE_UNKNOWN;
  var onStopCallback;

  return {
    get isPending() {
      return state === STATE_PENDING;
    },
    get isRecording() {
      return state === STATE_STARTED;
    },
    accept: accept,
    close: close,
    start: start,
    stop: stop
  };

  function init(onSuccess, onError) {
    recorder = new Recorder({
      sampleRate: 44100, // 采样频率，默认为44100Hz(标准MP3采样率)
      bitRate: 128, // 比特率，默认为128kbps(标准MP3质量)
      success: function() { // //成功回调函数
        state = STATE_INITIALIZED;
        console.log("录音设备初始化成功!");
        if (onSuccess) {
          onSuccess();
        }
      },

      error: function(msg) { // 失败回调函数
        alert(msg);
        if (onError) {
          onError();
        }
      },
      fix: function(msg) { // 不支持H5录音回调函数
        alert(msg);
        if (onError) {
          onError();
        }
      }
    });
  }

  function start(callback, refreshUI) {
    if (state >= STATE_INITIALIZED && state !== STATE_PENDING) {
      if (state === STATE_STARTED) { // 不能重复开始，但是，如果有pending的， 则忽略它
        return;
      }
      state = STATE_STARTED;
      onStopCallback = callback;
      recorder && recorder.start();
      if (refreshUI) {
        refreshUI();
      }
    } else {
      init(function() {
        start(callback, refreshUI);
      });
    }
  }

  function stop() {
    if (state < STATE_STARTED) {
      return setTimeout(function() {
        stop();
      });
    }

    state = STATE_PENDING;
    if (!onStopCallback) {
      onStopCallback = defaultCallback;
    }

    recorder && recorder.stop();
    recorder && recorder.getBlob(function(data) {
      onStopCallback(data);
      onStopCallback = null;
      setTimeout(function() {
        recorder.close();
      });
    });
  }

  function accept() {
    if (state === STATE_STARTED) {
      stop();
    }
    // recorder.close();
    state = STATE_UNKNOWN;
  }

  function defaultCallback(blob) {
    console.log("sound recorded: type = " + blob.type + ", size = " + blob.size);
    var audio = document.createElement("audio");
    audio.src = URL.createObjectURL(blob);
    audio.controls = true;
    document.appendChild(audio);
  }
})();

/**
 * Created by admin on 9/13/2015.
 * 建立系统目录
 * ToDo：避免重复建立
 */
angular.module("starter").factory("Setup", Setup);
Setup.$inject = ["FileService", "DeviceService"];

function Setup(FileService, DeviceService) {
  var dirCounter = 0;
  var dirs = [TQ.Config.IMAGES_CORE_PATH,
    TQ.Config.SOUNDS_PATH,
    TQ.Config.VIDEOS_CORE_PATH,

    TQ.Config.WORKS_CORE_PATH,
    TQ.Config.SCENES_CORE_PATH,
    TQ.Config.SCREENSHOT_CORE_PATH,

    TQ.Config.TEMP_CORE_PATH,
    TQ.Config.LOG_CORE_PATH];

  function createFolders() {
    if (!DeviceService.isReady()) {
      TQ.Log.error("Device not ready! in createFolders");
      return;
    }

    TQ.Config.setResourceHost(DeviceService.getRootFolder());

    if (TQ.Config.LocalCacheEnabled) {
      dirCounter = 0;
      FileService.createDir(dirs[dirCounter], onSuccess, onError);
    } else {
      _ready();
    }
  }

  function onSuccess(success) {
    dirCounter++;
    onDirCreated();
  }

  function onError(error) {
    TQ.Log.error("在创建目录的时候出错！！！: " + dirs[dirCounter]);
    if (error) {
      TQ.Log.error(JSON.stringify(error));
    }

    dirCounter++;
    onDirCreated();
  }

  // 对于Android，处理速度慢，不能使用for循环连续发出命令，必须使用这种 回调方式
  function onDirCreated() {
    if (dirCounter >= dirs.length) {
      _ready();
    } else {
      FileService.createDir(dirs[dirCounter], onSuccess, onError);
    }
  }
  function initialize() {
    createFolders();
  }

  function _ready() {
    TQ.Base.Utility.triggerEvent(document, TQ.EVENT.DIR_READY);
  }

  return {
    initialize: initialize
  };
}

/**
 * Created by Andrewz on 1/25/2016.
 * 纠正手机照片的Orientation
 * 等比例瘦身到 1024-2048范围，（长边）
 * callback参数：文件的name, data是image64数据
 */
var TQ = TQ || {};

(function(lib) {
  function ImageProcess() {
  }

  var _canvas = null;

  function start(file, options, callback) {
    var url = TQUtility.fileToUrl(file, options);
    loadImage.parseMetaData(file, function(data) {
      if (data.exif) {
        options.orientation = data.exif.get("Orientation");
      }
      loadData(url, file.name, options, callback);
    });
  }

  function loadData(url, filename, options, callback) {
    var ele = new Image();
    ele.onload = onload;
    if (options.crossOrigin) {
      ele.crossOrigin = options.crossOrigin;
    }
    ele.src = url;

    function determineScale(img) { // 只缩小， 不放大，不能超过屏幕的w和h
      var scale = Math.min(1, TQ.Config.designatedHeight / img.height);
      return Math.min(scale, TQ.Config.designatedWidth / img.width);
    }

    function onload() {
      var errorCode = 0;
      if ((ele.width > TQ.Config.designatedWidth) || (ele.height > TQ.Config.designatedHeight)) {
        errorCode = 1;
      }

      var scale = determineScale(ele);
      var ctx;
      var neededHeight = Math.round(ele.height * scale / 8) * 8;
      var neededWidth = Math.round(ele.width * scale / 8) * 8;

      if (!_canvas) {
        _canvas = document.createElement("canvas");
      }
      _canvas.width = neededWidth;
      _canvas.height = neededHeight;

      ctx = _canvas.getContext("2d");

      if (options.orientation) {
        applyOrientation(ctx, _canvas, options);
      }

      var xc = 0; var yc = 0;
      ctx.drawImage(ele, xc, yc, neededWidth, neededHeight);
      if (callback) {
        callback({ errorCode: errorCode, name: filename, data: _canvas.toDataURL("image/png") });
      }
    }
  }

  // helper
  function applyOrientation(ctx, canvas, options) {
    var width = canvas.width;
    var height = canvas.height;
    var orientation = options.orientation;

    if (!orientation || orientation > 8) {
      return;
    }
    if (orientation > 4) {
      canvas.width = height;
      canvas.height = width;
    }
    switch (orientation) {
      case 2:
        // horizontal flip
        ctx.translate(width, 0);
        ctx.scale(-1, 1);
        break;
      case 3:
        // 180° rotate left
        ctx.translate(width, height);
        ctx.rotate(Math.PI);
        break;
      case 4:
        // vertical flip
        ctx.translate(0, height);
        ctx.scale(1, -1);
        break;
      case 5:
        // vertical flip + 90 rotate right
        ctx.rotate(0.5 * Math.PI);
        ctx.scale(1, -1);
        break;
      case 6:
        // 90° rotate right
        ctx.rotate(0.5 * Math.PI);
        ctx.translate(0, -height);
        break;
      case 7:
        // horizontal flip + 90 rotate right
        ctx.rotate(0.5 * Math.PI);
        ctx.translate(width, -height);
        ctx.scale(-1, 1);
        break;
      case 8:
        // 90° rotate left
        ctx.rotate(-0.5 * Math.PI);
        ctx.translate(-width, 0);
        break;
    }
  }

  ImageProcess.start = start;
  lib.ImageProcess = ImageProcess;
})(TQ);

TQ = TQ || {};
(function() {
  /** *
     * 通用的事件处理机制， 可以添加任意事件的处理函数， 可以附加到任何class上，使其立即具有事件处理能力
     * @constructor
     */
  function EventHandler() {
  }
  var p = EventHandler.prototype;

  EventHandler.initialize = function(target) {
    target.addHandler = p.addHandler;
    target.removeHandler = p.removeHandler;
    target.removeAllHandlers = p.removeAllHandlers;
    target.hasHandler = p.hasHandler;
    target.handleEvent = p.handleEvent;
  };

  // constructor:

  p._handlers = null;
  p._captureHandlers = null;
  p.initialize = function() {};

  // public methods:
  p.handleEvent = function(eventName) {
    if (!this._handlers) return;
    var arr = this._handlers[eventName];
    if (arr) {
      for (var i = 0, num = arr.length; i < num; i++) {
        var fn1 = arr[i];
        if (fn1) fn1();
      }
    }
  };

  p.addHandler = function(type, handler, useCapture) {
    var handlers;
    if (useCapture) {
      handlers = this._captureHandlers = this._captureHandlers || {};
    } else {
      handlers = this._handlers = this._handlers || {};
    }
    var arr = handlers[type];
    if (arr) { this.removeHandler(type, handler, useCapture); } // 确保同一个函数，对每一个事件都不能重复使用。
    arr = handlers[type]; // remove may have deleted the array
    if (!arr) { handlers[type] = [handler]; } else { arr.push(handler); }
    return handler;
  };

  p.removeHandler = function(type, handler, useCapture) {
    var handlers = useCapture ? this._captureHandlers : this._handlers;
    if (!handlers) { return; }
    var arr = handlers[type];
    if (!arr) { return; }
    for (var i = 0, l = arr.length; i < l; i++) {
      if (arr[i] === handler) {
        if (l === 1) {
          delete (handlers[type]);
        } else { // allows for faster checks.
          arr.splice(i, 1);
        }
        break;
      }
    }
  };

  p.removeAllHandlers = function(type) {
    if (!type) { this._handlers = this._captureHandlers = null; } else {
      if (this._handlers) { delete (this._handlers[type]); }
      if (this._captureHandlers) { delete (this._captureHandlers[type]); }
    }
  };

  p.hasHandler = function(type) {
    var handlers = this._handlers; var captureListeners = this._captureHandlers;
    return !!((handlers && handlers[type]) || (captureListeners && captureListeners[type]));
  };

  TQ.EventHandler = EventHandler;
}());

/**
 * Created by admin on 9/26/2015.
 * DownloadManager： 下载素材到本地（app的本地文件，或PC的仿真cache），接口：
 *  * initialize
 *  * clearCache
 *
 *  * downloadBulk
 *  * downloadAux
 *  * onCompleted
 *  * onError
 *
 *  * hasCompleted
 *  * hasCached
 */
var TQ = TQ || {};

(function() {
  function DownloadManager() {
  }
  var p = DownloadManager;
  var urlConcat = TQ.Base.Utility.urlConcat;

  p.FAST_SERVER = TQ.Config.MAT_HOST;
  // p.FAST_SERVER = "http://www.udoido.com";
  // p.FAST_SERVER = "http://localhost:63342/eCard/www";
  // p.FAST_SERVER = "";
  p.DOWNLOAD_EVENT = "download-to-cache";
  var _tasks = 0;
  var _files = {};
  p.hasCached = function(name) {
    var item = _files[name];
    return (!!item && !!item.cacheName);
  };

  p.getCached = function(name) {
    var item = _files[name];
    TQ.Assert.isTrue(!!item, "必须存在");
    return (item.cacheName);
  };

  p.download = function(name, cacheName, resourceId) {
    TQ.Assert.isTrue(false, "Depreciated");
  };

  p.downloadAux = function(resourceId, cacheName, onSuccess, onError) {
    TQ.Assert.isFalse(this.hasCached(resourceId), "已经cached！！");
    var onLsError;

    if (TQ.Config.TwoMatServerEnabled) {
      onLsError = makeLsOnError();
    } else {
      onLsError = onError;
    }

    // full path in File Server
    var fullPathFs = TQ.RM.toFullPathFs(resourceId);
    _download(fullPathFs, cacheName, resourceId, onSuccess, onLsError);

    // server Fs
    function makeLsOnError() {
      return function() {
        var fullPathFs = _toFullPathFs(resourceId);
        TQ.Assert.isFalse(TQ.DownloadManager.hasCached(resourceId),
          "已经cache了！");
        _download(fullPathFs, cacheName, resourceId, onSuccess, onError);
      };
    }
  };

  p.onCompleted = function(data) {
    var cacheName = data.target;
    var resourceId = data.key;
    var item = _files[resourceId];
    if (!item) {
      TQ.Log.error("找不到callback： for" + resourceId);
      return;
    }

    item.cacheName = cacheName;
    var onSuccess = item.onSuccess;
    item.onSuccess = [];
    item.onError = [];
    this.save();
    var callback;
    if (onSuccess) {
      while (onSuccess.length > 0) {
        callback = onSuccess.shift();
        if (callback) {
          callback();
        }
      }
    }
    _tasks--;
  };

  p.onError = function(error, data) {
    var name = data.source;
    var resourceId = data.key;
    var item = _files[resourceId];
    if (!item) {
      TQ.Log.error("找不到callback： for" + resourceId);
      return;
    }

    _files[resourceId] = null; //  remove old one;
    this.save();
    if (!error.handled) {
      if (typeof error.http_status !== "undefined") {
        if (error.http_status === 404) {
          TQ.Log.error("找不到文件：" + name);
        } else {
          TQ.Log.error("下载文件出错: target目录缺失？ 或者无空间：" + name);
        }
      } else {
        TQ.Log.error("下载文件出错: " + name);
      }
    }
    item.cacheName = null; // no cache file
    var onError = item.onError;
    item.onSuccess = [];
    item.onError = [];
    var callback;
    if (onError) {
      while (onError.length > 0) {
        callback = onError.shift();
        if (callback) {
          callback();
        }
      }
    }
    _tasks--;
  };

  p.hasCompleted = function() {
    return (_tasks === 0);
  };

  p.clearCache = function() {
    _files = {};
    this.save();

    // ToDo: remove file from cache
  };

  p.save = function() {
    localStorage.setItem("fileList", JSON.stringify(_files));
  };

  p.downloadBulk = function(bulk) {
    for (var i = 0; i < bulk.length; i++) {
      if (Array.isArray(bulk[i])) {
        this.downloadBulk(bulk[i]);
        continue;
      }

      if (!bulk[i] || !bulk[i].path) {
        continue;
      }

      var resourceId = bulk[i].path;
      var cacheName = TQ.RM.toCachePath(resourceId);

      var use_cache_file = true;
      if (use_cache_file) {
        bulk[i].path = cacheName;
      }

      if (this.hasCached(resourceId)) {
        continue;
      }
      this.downloadAux(resourceId, cacheName);
    }
  };

  p.initialize = function() {
    var str = localStorage.getItem("fileList");
    if (str) {
      _files = JSON.parse(str);
      if (_files) {
        for (var i = 0; i < _files.length; i++) {
          var item = _files[i];
          if (item.onSuccess) {
            item.onSuccess.splice(0);
          }

          if (item.onError) {
            item.onError.splice(0);
          }
        }
      }
    }
  };

  // private
  function _toFullPathFs(name) { // File Server, such as udoido.com
    name = TQ.RM.toRelative(name);
    return urlConcat(this.FAST_SERVER, name);
  }

  function _download(name, cacheName, resourceId, onSuccess, onError) {
    var item = _files[resourceId];
    if (!item) {
      _files[resourceId] = { onSuccess: [onSuccess], onError: [onError], cacheName: null };
    } else {
      item.onSuccess.push(onSuccess);
      item.onError.push(onError);
      return;
    }

    _tasks++;
    TQ.Base.Utility.triggerEvent(document, this.DOWNLOAD_EVENT, { key: resourceId, source: name, target: cacheName });
  }

  TQ.DownloadManager = DownloadManager;
}());

/**
 * Created by Andrewz on 8/5.
 */
this.TQ = this.TQ || {};

(function() {
  function ResourceDesc() {
  }

  function isReady(desc) {
    if (desc.data) { // image buffer
      return true;
    }

    return TQ.RM.hasResourceReady(desc.src);
  }

  ResourceDesc.isReady = isReady;
  TQ.ResourceDesc = ResourceDesc;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
this.TQ = this.TQ || {};

(function() {
  // ToDo: RM内部只保存相对路径， 外部使用全路径。
  //      内部全部使用fullPath， 只有在保存文件的时候， 才使用相对路径， 既便于移植到不同的环节， 又能够唯一化代码
  // ToDo: 避免重复加入到Queue中，在addItem的时候， 如果已经在Queue中， 也不要加入，只处理其callback，
  // ToDo: 处理错误， 如果文件不存在， 则用"NoSound.wav" 或者“NoRes.png" 来替代。并执行其callback
  // ToDo: 加引用次数, 在内存不足的时候， 释放没有引用的资源
  // 资源管理器设计目标：
  //  * 预先加载资源，画面更流程，
  //  * 唯一化ID，避免重复加载:
  //  ** 一个资源，只加载1次，多次使用，在多个位置，多个角度
  //  ** 已经加载的资源， 用ID获取内容， 直接使用；
  //  ** 未加载的资源， 支持一对一的回调
  //  * 第一个Level加载完成之后， 马上开始播放该level， 同时， 继续加载后续的Level
  //  ** 如果当前Level加载没有完成， 则显示等待画面；
  //
  // 结构设计：
  // 1）level的资源， 及其回调函数（设置：dataReady）
  // 2）逐个加载每一个level，并且调用其回调函数，
  //
  // 已知的问题：
  //  1) preloadJS中的XHLLoader 会两次通过network加载同一资源， 只是第二次总是从cache中获取（从谷歌调试的network页面中看到）。
  //
  //

  function ResourceManager() {
  }

  var THUMBNAIL_EXP = "w_100,h_100,c_limit/";
  var OPUS_THUMBNAIL_EXP = "w_180,h_180,c_limit/";

  var urlParser = TQ.Base.Utility.urlParser;
  var urlConcat = TQ.Base.Utility.urlConcat;
  var maxConnectionsPerHost = 6;
  var RM = ResourceManager;

  RM.DATA_TYPE_SOUND = createjs.AbstractLoader.SOUND; // preloader lib中定义的
  RM.NOSOUND = "./mcSounds/p1.wav";
  RM.NOPIC = "./mcImages/p1.png";
  RM.BASE_PATH = null;
  // RM.BASE_PATH = "http://" + TQ.Config.DOMAIN_NAME;
  RM.BASE_PATH = TQ.DownloadManager.FAST_SERVER;
  // NOPIC和NOSOUND是基本的文件， 总是在本服务器（手机的本APP， desktop的本服务器）
  RM.FULLPATH_NOPIC = RM.NOPIC;
  RM.FULLPATH_NOSOUND = RM.NOSOUND;
  RM.isEmpty = true;
  RM.items = [];
  RM.preloader = {};
  RM.callbackList = [];
  RM.dataReady = false;
  RM.completeOnceHandlers = [];

  RM.initialize = function() {
    // var MAX_CONNECTIONS_PER_HOST={
    //    'chrome': 6,
    //    'safari': 6,
    //    'firefox': 6,
    //    'ie11': 8,
    //    'chrome mobile': 6,
    //    'safari mobile': 6,
    // };

    if (RM._hasCreated) { // 确保只创建一次
      return;
    }

    TQ.DownloadManager.initialize();
    RM._hasCreated = true;
    RM.hasDefaultResource = false;
    // Instantiate a queue.
    resetPreloader();
    _setupDefaultResource();
  };

  function _setupDefaultResource() {
    RM.hasDefaultResource = true;
    RM.addItem(RM.FULLPATH_NOPIC);
    RM.addItem(RM.FULLPATH_NOSOUND);
  }

  RM.setupListeners = function() {
    // Available PreloadJS callbacks
    var fileCounter = 0;
    RM.preloader.on("fileload", function(event) {
      var resId = event.item.id;
      var result = event.result;
      // ToDo: 唯一化断言
      RM.items[resId].res = result;
      RM.items[resId].type = event.item.type;
      fileCounter++;
      TQ.Log.info("Loaded: (" + fileCounter + "/" + Object.keys(RM.items).length + "): " + event.item.id);
      RM.onFileLoad(resId, result, event);
    });

    RM.preloader.addEventListener("complete", onCompleted);
    function onCompleted(event) {
      if (!event) {
        event = {};
      }
      // 下载没有完成， 但是预加载的已经完成了。
      if (!TQ.DownloadManager.hasCompleted()) {
        return;
      }
      TQ.Log.info(event.toString());
      RM.dataReady = true;
      var num = RM.completeOnceHandlers.length; // 防止动态添加的函数
      for (; num > 0; num--) {
        var handler = RM.completeOnceHandlers.shift();
        handler(event);
      }
      RM.isEmpty = true;
    }

    RM.onCompleted = onCompleted;
    RM.preloader.addEventListener("error", function(event) {
      var item = event.data;
      assertTrue("缺少系统文件",
        ((item.src !== RM.FULLPATH_NOSOUND) &&
                (item.src !== RM.FULLPATH_NOPIC)));
      TQ.Log.info(item.src + ": " + event.toString());
      TQUtility.triggerEvent(document, TQ.EVENT.SYSTEM_ERROR, { desc: event.title || "FILE_LOAD_ERROR", detail: event });
      var resId = item.id;
      var result = null;
      var altResId = null;

      switch (item.type) {
        case createjs.LoadQueue.IMAGE:
          altResId = RM.FULLPATH_NOPIC;
          break;

        case createjs.LoadQueue.SOUND:
          altResId = RM.FULLPATH_NOSOUND;
          break;

        case createjs.LoadQueue.TEXT: // 元件的文件, or bad file
          if (TQ.Utility.isImage(item.src)) {
            altResId = RM.FULLPATH_NOPIC;
            item.type = createjs.LoadQueue.IMAGE;
          } else if (TQ.Utility.isSoundResource(item.src)) {
            altResId = RM.FULLPATH_NOSOUND;
            item.type = createjs.LoadQueue.SOUND;
          } else {
            TQ.Log.error(item.type + ": 未处理的资源类型!");
          }
          break;
        case createjs.LoadQueue.VIDEO:
          altResId = "";
          item.type = createjs.LoadQueue.VIDEO;
          break;

        default :
          TQ.Log.error(item.type + ": 未处理的资源类型!");
      }

      if ((altResId != null) && (!!RM.items[altResId])) {
        result = RM.items[altResId].res;
      } else {
        assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      }

      RM.items[resId] = { ID: resId, res: result, type: item.type };
      if (result == null) {
        RM.addItem(altResId, function() {
          var item = RM.items[resId];
          var altItem = RM.items[altResId];

          if (item && altItem) {
            item.res = altItem.res;
            item.altResId = altItem.ID;
          } else {
            TQ.Log.error("RM.items error: resId = " + resId + " altResId=" + altResId);
          }
        });

        assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      } else {
        RM.items[resId].altResId = RM.items[altResId].ID;
        RM.onFileLoad(resId, result, null);
      }
    });

    RM.preloader.addEventListener("progress", function(event) {
      // TQ.Log.info("." + event.toString() + ": " + event.loaded);
    });
    RM.dataReady = false;
  };

  RM.onFileLoad = function(resId, result, event) {
    // check for callback
    for (var i = 0; i < RM.callbackList.length; i++) {
      if (RM.callbackList[i].ID === resId) {
        TQ.Log.info("find immediate call back to do");
        var item = RM.callbackList.splice(i, 1);
        item[0].func(event);
        i--;
      }
    }
  };

  RM.getId = function(item) {
    if (!item.altResId) {
      return item.ID;
    } else {
      return item.altResId;
    }
  };

  // 清除所有的资源，准备开始新的微创意
  RM.reset = function() {
    if (!RM._hasCreated) {
      return;
    }
    RM.completeOnceHandlers.splice(0);
    RM.preloader.removeAllEventListeners();
    RM.preloader.removeAll();
    RM.preloader.cancel();
    RM.preloader = null;
    resetPreloader();
    // RM.items.splice(0); 不行，因为不是数组，
    for (var item in RM.items) {
      if (Object.prototype.hasOwnProperty.call(RM.items, item)) {
        delete RM.items[item];
      }
    }
    RM.isEmpty = true;
  };

  function resetPreloader() {
    RM.preloader = new createjs.LoadQueue(true, null, true); // , "assets/");
    RM.preloader.setMaxConnections(maxConnectionsPerHost);

    if (TQ.Base.Utility.isMobileDevice()) {
      RM.preloader.installPlugin(createjs.CordovaAudioLoader);
    }
    RM.setupListeners();
  }

  // 信号：暂停预加载，以便于处理时间敏感的判定， 必须是短时间
  RM.setPaused = function(value) {
    RM.preloader.setPaused(value);
  };

  // 完成加载的顺序与开始加载顺序无关。 最先开始加载的资源， 如果很大，最后才加载完成。 如果后开始加载的资源下。
  // 只有遍历
  RM.on = function(eventName, callback) {
    RM.preloader.addEventListener(eventName, callback);
  };

  RM.onCompleteOnce = function(callback) {
    RM.completeOnceHandlers.push(callback);
  };

  RM.removeEventListener = function(eventName, callback) {
    RM.preloader.removeEventListener(eventName, callback);
  };

  function _addReference(resourceId, _callback) {
    var item = RM.getResource(resourceId);
    assertTrue("_addReference: 先确保resource 存在！", !!item);
    if (_callback) {
      RM.callbackList.push({ ID: resourceId, func: _callback });
    }

    // ToDo:@@@ 增加和减少 reference Counter
  }

  RM.addItem = function(resourceId, _callback) {
    if (isAudio(resourceId)) {
      return;
    }

    TQ.Assert.isTrue(RM.hasDefaultResource, "没有初始化RM！");
    resourceId = _toKeyPath(resourceId);
    if (_hasResource(resourceId)) {
      assertTrue("RM.addItem: check resource ready before call it!!", !this.hasResourceReady(resourceId));
      _addReference(resourceId, _callback);
    } else {
      var resourcePath = composeResourcePath(resourceId);
      TQ.Assert.isNotNull(resourcePath, "不支持的逻辑!");
      if (resourcePath) {
        loadResource(resourcePath, resourceId, null, _callback);
      }
    }
  };

  function loadResource(resourcePath, resourceId, type, _callback) {
    if (TQUtility.isVideoUrl(resourcePath) || TQUtility.isVideoFile(resourcePath)) {
      type = createjs.AbstractLoader.VIDEO; // 'video'
    }
    // 添加Item 到预加载队列中， 并启动运行预加载（如果没有运行的话）
    // ToDo: RM.Items.push({});
    RM.items[resourceId] = { ID: resourceId, res: null, type: type };

    if (_callback) {
      RM.callbackList.push({ ID: resourceId, func: _callback });
    }

    // RM.preloader.loadFile("assets/image0.jpg");
    RM.dataReady = false;
    RM.isEmpty = false;
    addToPreloader(resourcePath, resourceId, type);
  }

  function loadSoundFromFile(aFile, callback) {
    var resourcePath = TQUtility.fileToUrl(aFile, {});
    loadResource(resourcePath, resourcePath, RM.DATA_TYPE_SOUND, callback);
  }

  var cloudinarySubdomains = [
    "res.cloudinary.com",
    "res-3.cloudinary.com"];

  function accelerateByMultiHost(fullPath) {
    var mainHost = "res.cloudinary.com";
    if (fullPath.indexOf(mainHost) > -1) {
      try {
        var idIndex = fullPath.lastIndexOf(".");
        var fileId = parseInt(fullPath[idIndex - 1]) % 2;
        return fullPath.replace(mainHost, cloudinarySubdomains[fileId]);
      } catch (e) {

      }
    }
    return fullPath;
  }

  function addToPreloader(fullPath, resourceId, type) {
    RM.preloader.loadManifest([{
      type: type, // 对于本地声音， 必须加，因为blob类的url无法提供类别信息
      src: (TQ.Config.useCloudinaryMultiHost ? accelerateByMultiHost(fullPath) : fullPath),
      id: resourceId, // Sound资源的id是字符串, 不是数字
      data: 3 // 本资源最大允许同时播放N=3个instance。（主要是针对声音）
    }]);
  }

  function composeResourcePath(resourceId) {
    var resourcePath = null;
    function makeOnSuccess1(fullPath, ID) {
      return function() {
        addToPreloader(fullPath, ID);
      };
    }

    TQ.Assert.isTrue(resourceId.indexOf("imgcache") !== 0);
    // 先从本App的服务器下载， 没有的话， 在从File Server下载
    if (_isLocalFileSystem(resourceId)) {
      resourcePath = resourceId;
    } else {
      if (TQ.Config.LocalCacheEnabled) {
        TQ.Assert.isTrue(false, "ToDo: 需要重新修改");
        var cacheName = toCachePath(resourceId);
        if (TQ.DownloadManager.hasCached(resourceId)) {
          resourcePath = cacheName;
        } else {
          var onSuccess = makeOnSuccess1(cacheName, resourceId);
          TQ.DownloadManager.downloadAux(resourceId, cacheName, onSuccess, function() {
            TQ.Log.error(resourceId + "资源加载出错！");
          });
        }
      } else {
        resourcePath = _toFullPath(resourceId);
      }
    }
    return resourcePath;
  }

  /*
     如果成功地送到RM， 则返回true；对于有多个资源的情况，只有送入1个就返回true。
     如果没有送入RM， （比如:RM中已经有了）， 则 返回false
     */
  RM.addElementDesc = function(desc, callback) {
    TQ.AssertExt.isNotNull(desc);
    if (!desc) return false;
    var allChildrenReady = !(desc.children && desc.children.length > 0);
    var iReady = !desc.src;

    tryCallback(); // 预防空的元素

    if (!allChildrenReady) { // 先调入子孙的资源， 以便于执行callback
      var numOkChildren = 0;
      var numChildren = desc.children.length;
      function onChildReady() {
        numOkChildren++;
        if (numOkChildren >= numChildren) {
          allChildrenReady = true;
          tryCallback();
        }
      }
      for (var i = 0; i < numChildren; i++) {
        if (!desc.children[i]) {
          continue;
        }
        RM.addElementDesc(desc.children[i], onChildReady);
      }
    }

    if (!iReady) { // 处理自己的资源
      var resName = desc.src;
      iReady = RM.hasResourceReady(resName);
      if (iReady) {
        onIReady();
      } else {
        RM.addItem(resName, onIReady);
      }
    }

    function tryCallback() {
      if (allChildrenReady && iReady && callback) {
        callback();
      }
    }

    function onIReady() {
      iReady = true;
      tryCallback();
    }

    return allChildrenReady && iReady;
  };

  RM.addElementDescList = function(jsonElements) {
    var foundInvalidElement = false;
    for (let i = 0; i < jsonElements.length; i++) {
      var desc = jsonElements[i];
      if (!desc || isBlob(desc)) {
        foundInvalidElement = true;
        jsonElements[i] = null;
      } else {
        desc.src = TQUtility.unifyFormat(desc.type, desc.src);
        TQ.RM.addElementDesc(desc);
      }
    }

    if (foundInvalidElement) { // 删除非法element
      for (let i = jsonElements.length - 1; i >= 0; i--) {
        if (!jsonElements[i]) {
          jsonElements.splice(i, 1);
        }
      }
    }
  };

  RM.isLocalResource = function(resName) {
    return (resName.indexOf("file:///") === 0);
  };

  /*
     只要差一个资源未调入RM， 都必须返回false，
     */
  RM.hasElementDesc = function(desc) {
    TQ.AssertExt.isNotNull(desc);
    if (!desc) return true;
    var result = true;

    if (desc.children) { // 先调入子孙的资源， 以便于执行callback
      for (var i = 0; i < desc.children.length; i++) {
        TQ.Assert.isTrue(false, "addElementDesc or hasElementDesc???");
        if (!desc.children[i]) {
          continue;
        }
        if (RM.addElementDesc(desc.children[i])) {
          result = false;
        }
      }
    }

    if (desc.src) { // 处理自己的资源
      return RM.hasResourceReady(desc.src);
    }

    // for virtual object;
    return result;
  };

  function _hasResource(id) { // registered, may not loaded
    TQ.Assert.isTrue(_isKeyPath(id), "应该是Key路径");
    return !(!RM.items[id]);
  }

  RM.hasResourceReady = function(id) {
    if (isAudio(id)) {
      return true;
    }
    var res = RM.items[_toKeyPath(id)];
    return (!!res && !!res.res);
  };

  RM.getResource = function(id) {
    if (isAudio(id)) {
      return { ID: id };
    }

    id = _toKeyPath(id);
    if (!RM.items[id]) { // 没有发现， 需要调入
      TQ.Log.info(id + ": 没有此资源, 需要加载, 如果需要回调函数，用 addItem 替代 getResource");
      // 添加到预加载列表中
      // 设置回调函数
      return null;
    }

    return RM.items[id];
  };

  RM.toRelative = function(str) {
    if (_isLocalFileSystem(str)) {
      return str;
    }

    if (!_isFullPath(str)) {
      str = _removeMatFolder(str);
      str = _removeFirstSeperator(str);
      str = _removeImgCacheString(str);
      TQ.Assert.isTrue((str[0] !== "\\") && (str[0] !== "/"),
        "相对路径，开头不能是\\或者/");
      return str;
    }

    if (TQ.Config.LocalCacheEnabled && _isCachePath(str)) {
      return _removeCacheRoot(str);
    }

    var pathname = urlParser(str).pathname;
    pathname = _removeMatFolder(pathname);
    pathname = handleAndroidLocalhost(pathname);
    return _removeFirstSeperator(pathname);
  };

  RM.toRelativeWithoutCache = function(str) {
    if (TQ.Config.LocalCacheEnabled && _isCachePath(str)) {
      return _removeCacheRoot(str);
    }
    return RM.toRelative(str);
  };

  RM.getNameFromUrl = function(url) {
    if (!url) {
      return url;
    }
    var words = url.split("/");
    return words[words.length - 1];
  };

  function handleAndroidLocalhost(pathname) {
    var ANDROID_LOCALHOST = "/android_asset/www";
    if (pathname.indexOf(ANDROID_LOCALHOST) === 0) {
      pathname = pathname.substr(ANDROID_LOCALHOST.length);
    }

    return pathname;
  }

  function _removeMatFolder(pathname) {
    if ((TQ.Config.IMAGES_CORE_PATH !== "") && (pathname.indexOf(TQ.Config.IMAGES_CORE_PATH) >= 0)) {
      pathname = pathname.substr(TQ.Config.IMAGES_CORE_PATH.length);
    }
    if ((TQ.Config.SOUNDS_PATH !== "") && (pathname.indexOf(TQ.Config.SOUNDS_PATH) >= 0)) {
      pathname = pathname.substr(TQ.Config.SOUNDS_PATH.length);
    }

    return pathname;
  }

  function _removeFirstSeperator(path) {
    if ((path[0] === "\\") || (path[0] === "/")) {
      return path.substr(1);
    }
    return path;
  }

  function _removeImgCacheString(pathname) {
    if (_isFullPath(pathname)) {
      return pathname;
    }

    var IMG_CACHE = "imgcache/";
    if (pathname.indexOf(IMG_CACHE) === 0) {
      pathname = pathname.substr(IMG_CACHE.length);
    }

    return pathname;
  }

  function toCachePath(path) {
    if (_isLocalFileSystem(path)) {
      return path;
    }

    var cachePath = _toStdFolder(RM.toRelative(path));
    return urlConcat(TQ.Config.getResourceHost(), cachePath);
  }

  function _isCachePath(path) {
    return (path.indexOf(TQ.Config.getResourceHost()) === 0);
  }

  function _removeCacheRoot(path) {
    return (path.substr(TQ.Config.getResourceHost().length));
  }

  function _toStdFolder(path) {
    var MAX_FILE_NAME = 50;
    var std_folder;

    if (TQ.Utility.isImage(path)) {
      std_folder = TQ.Config.SCREENSHOT_CORE_PATH;
      if (path.indexOf(std_folder) === 0) {
      } else {
        std_folder = TQ.Config.IMAGES_CORE_PATH;
        if (path.indexOf(std_folder) >= 0) {
        }
      }
    } else if (TQ.Utility.isSoundResource(path)) {
      std_folder = TQ.Config.SOUNDS_PATH;
    } else if (TQ.Utility.isVideo(path)) {
      std_folder = TQ.Config.VIDEOS_CORE_PATH;
    } else if (TQ.Utility.isWCY(path)) {
      std_folder = TQ.Config.WORKS_CORE_PATH;
    } else {
      TQ.Assert.isTrue(false, "未处理的文件类别!");
    }

    if (path.indexOf(std_folder) === 0) {
      return path;
    }

    // ToDo: get unique file ID, like p123456.png;
    path = path.replace(/\//g, "_");
    var start = path.length - MAX_FILE_NAME;
    if (start > 0) {
      path = path.substr(start);
    }

    return urlConcat(std_folder, path);
  }

  function _isFullPath(name) {
    var protocols = ["filesystem:", "file:", "http://", "https://"];
    for (var i = 0; i < protocols.length; i++) {
      if (name.indexOf(protocols[i]) === 0) {
        return true;
      }
    }

    if (urlParser(name).pathname === name) {
      return false;
    }

    TQ.Assert.isTrue(RM.BASE_PATH !== "", "BASE_PATH是空，");
    return (name.indexOf(RM.BASE_PATH) >= 0);
  }

  function _isLocalFileSystem(name) {
    return ((name.indexOf("filesystem:") === 0) ||
            (name.indexOf("file:///") === 0) ||
            TQUtility.isBlobUrl(name));
  }

  function _toFullPath(name) {
    if (!name) {
      name = "";
    }
    if (_isLocalFileSystem(name)) {
      return name;
    }

    if (_isFullPath(name)) {
      return name;
    }

    if (RM.FULLPATH_NOPIC.indexOf(name) > -1) {
      return RM.FULLPATH_NOPIC;
    }

    if (RM.FULLPATH_NOSOUND.indexOf(name) > -1) {
      return RM.FULLPATH_NOSOUND;
    }

    var folder = (TQ.Utility.isImage(name)) ? TQ.Config.IMAGES_CORE_PATH : TQ.Config.SOUNDS_PATH;
    var fullpath = urlConcat(urlConcat(TQ.Config.MAT_HOST, folder), name);
    if (RM.BASE_PATH !== "") {
      TQ.Assert.isTrue(urlParser(RM.BASE_PATH).hostname === urlParser(fullpath).hostname, "hostname 不一致");
    }
    return fullpath;
  }

  function _toFullPathLs(name) { // Local Server: the server I'm running
    if (_isLocalFileSystem(name) || _isFullPath(name)) {
      return name;
    }

    var fullpath = TQ.Base.Utility.urlComposer(name);
    return fullpath;
  }

  function _toKeyPath(path) {
    // 只有两种keypath：
    //      本地文件（全路径， 不论是否cache的），
    //      远程文件
    if (_isLocalFileSystem(path)) {
      return path;
    }
    return RM.toRelative(path);
  }

  function _isKeyPath(path) {
    if (_isLocalFileSystem(path)) {
      return true;
    }

    return !_isFullPath(path);
  }

  RM.toRelativeFromThumbnail = function(url) {
    var pathname = TQ.Base.Utility.urlParser(url).pathname;
    var parts = (!pathname) ? [] : pathname.split("/");
    return (parts.length < 2) ? url : parts[parts.length - 2] + "/" + parts[parts.length - 1];
  };

  RM.toMatFullPath = function(relativePath) {
    return TQ.Config.MAT_UPLOAD_API + "/" + relativePath;
  };

  RM.toMatThumbNailFullPath = function(relativePath) {
    return (!relativePath) ? null : RM.toFullPathFs(toThumbNail(relativePath));
  };

  RM.toOpusThumbNailFullPath = function(relativePath) {
    return (!relativePath) ? null : RM.toFullPathFs(toOpusThumbNail(relativePath));
  };

  RM.removeThumbNail = function(path) {
    return path.replace(THUMBNAIL_EXP, "").replace(OPUS_THUMBNAIL_EXP, "");
  };

  function toOpusThumbNail(path) {
    TQ.Assert.isTrue(path[0] !== "/", "not separator");
    return (TQ.Utility.isImage(path) ? OPUS_THUMBNAIL_EXP : "") + path;
  }

  function toThumbNail(path) {
    TQ.Assert.isTrue(path[0] !== "/", "not separator");
    return (TQ.Utility.isImage(path) ? THUMBNAIL_EXP : "") + path;
  }

  function isBlob(desc) {
    return desc && desc.src && TQUtility.isBlobUrl(desc.src);
  }

  function isAudio(id) {
    return (id.indexOf(".mp3") >= 0);
  }

  RM.loadSoundFromFile = loadSoundFromFile;
  RM.toCachePath = toCachePath;
  RM.toFullPathFs = _toFullPath;
  TQ.RM = RM;
  TQ.ResourceManager = RM;
}());

/**
 * Created by Andrewz on 8/7.
 * Resource synchronizer: 在背景中运行， 把 用到的本地资源sync到服务器，
 * ** 在同步过程中， 显示“系统忙”标识，
 * ** 在同步成功之后， 更新element中的src，从本地url改为云资源url， 并且在RM中更改， 以便于播放， 复制。
 * ** 退出：如果sync任务没有完成，则提示它，
 * ** 保存：如果sync任务没有完成，则提示它， （把保存cmd，放到Queue中）
 * ** 如果没有完成， 下次启动之后，
 */

this.TQ = this.TQ || {};

this.TQ.ResourceSync = (function() {
  var numActiveTasks = 0;
  var events = {
    _oncomplete: [] // event name: 'complete'
  };

  return {
    on: on,
    once: once,
    isBusy: isBusy,
    local2Cloud: local2Cloud
  };

  function isBusy() {
    return numActiveTasks > 0;
  }

  function once(event, fn) {
    on(event, fn, 1);
  }

  function on(event, fn, once) {
    var listeners = events["_on" + event];

    if (typeof fn === "function") {
      listeners.push(once ? { fn: fn, once: once } : { fn: fn });
    }
  }

  function local2Cloud(ele, fileOrBuffer, matType) {
    numActiveTasks++;
    var option = {
      useBackgroundMode: true
    };

    return angular.element(document.body).injector().get("NetService").uploadOne(fileOrBuffer, matType, option)
      .then(function(res) {
        TQ.Log.debugInfo(res.url);
        if (ele && ele.jsonObj) {
          ele.jsonObj.src = TQUtility.unifyFormat(ele.jsonObj.type, res.url);
        }
        numActiveTasks--;
        if (numActiveTasks <= 0) {
          tryShowCompleteInfo();
          var listeners = events._oncomplete;
          if (listeners) {
            var num = listeners.length;
            for (let i = 0; i < num; i++) {
              if (listeners[i].fn) {
                setTimeout(listeners[i].fn);
              }
              if (listeners[i].once) {
                listeners.splice(i, 1);
                num--;
              }
            }
          }
        }
      });
  }

  function tryShowCompleteInfo() {
    if (numActiveTasks <= 0) {
      TQ.Log.debugInfo("background sync completed!");
    }
  }
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};
(function() {
  /**
     * GarbageCollector, 回收被deleted的元素，
     * 支持undelete
     * @class GarbageCollector
     * @static
     **/
  var GarbageCollector = function() {
    TQ.AssertExt.invalidLogic(0, "GarbageCollector cannot be instantiated");
  };
  GarbageCollector._members = [];

  GarbageCollector.initialize = function() {
    GarbageCollector.clear();
  };

  GarbageCollector.add = function(ele) {
    GarbageCollector._members.push(ele);
  };

  GarbageCollector.remove = function(ele) {
    if (!ele) return;
    var id = GarbageCollector._members.indexOf(ele);
    if (id >= 0) GarbageCollector._members.splice(id, 1);
    return ele;
  };

  GarbageCollector.reset = function() {
    GarbageCollector._members.splice(0);
  };

  GarbageCollector.clear = function() {
    for (var i = 0; i < GarbageCollector._members.length; i++) {
      var ele = GarbageCollector._members[i];
      assertNotNull(TQ.Dictionary.FoundNull, ele);
      GarbageCollector._members.splice(i, 1);
      ele.destroy();
    }

    GarbageCollector.reset();
  };

  TQ.GarbageCollector = GarbageCollector;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */

window.TQ = window.TQ || {};
(function() {
  /** 内部类,记录和执行一条命令
     **/
  function Command(f, params, path) {
    this.f = f;
    this.params = params;
    this.path = path == null ? true : path;
  }

  Command.prototype.exec = function(scope) { this.f.apply(scope, this.params); };

  var TaskMgr = {};
  TaskMgr.queue = [];
  TaskMgr.preferredQueue = [];
  TaskMgr.isWorking = false;
  TaskMgr._timerId = -1;
  TaskMgr.initialize = function() {
    TaskMgr.queue = [];
    TaskMgr.preferredQueue = [];
  };

  TaskMgr.invoke = function() {
    TaskMgr._timerId = setTimeout(function() { TaskMgr._runOnce(); }, 0);
  };

  TaskMgr.stop = function() {
    if (TaskMgr._timerId >= 0) clearTimeout(TaskMgr._timerId);
    TaskMgr._timerId = -1;
  };

  TaskMgr.addTask = function(func, params, topPriority) {
    if (topPriority) {
      TaskMgr.preferredQueue.push(new Command(func, params, null));
    } else {
      TaskMgr.queue.push(new Command(func, params, null));
    }

    if (!TaskMgr.isWorking) {
      TaskMgr.invoke();
    }
  };

  TaskMgr._getTask = function() {
    // 1) 每一次获取任务的时候, 都先检查高优先级的任务.
    // ToDo: 实现跳帧, 在绘制时间长的情况下, 只移动time, 不update和Render,直接绘制最新的帧.
    var task = TaskMgr.preferredQueue.shift();
    if (task == null) {
      return TaskMgr.queue.shift();
    }

    return task;
  };

  TaskMgr._runOnce = function() {
    TaskMgr.isWorking = true;

    for (var task = TaskMgr._getTask(); task != null; task = TaskMgr._getTask()) {
      task.exec(TaskMgr);
    }

    TaskMgr.isWorking = false;
  };

  TQ.TaskMgr = TaskMgr;
}());

/**
 * Created by Andrewz on 7/2/2016.
 */
/**
 * 命令的管理者类， 包括：
 *   1. 命令的Queue，优先Queue（不需要undo），
 *   2. 命令的undo堆栈， redo堆栈
 *   3. 添加命令到Que， do，undo和redo函数
 *
 * @type {Object}
 */
window.TQ = window.TQ || {};

(function() {
  var CommandMgr = {};

  var _queue = [];
  var _lastCmd = null;
  var _undoStack = [];
  var _redoStack = [];
  var _preferredQueue = [];
  var _isWorking = false;
  var _timerId = -1;
  var _cmdGroupId = 0;
  var _lastCmdGroupId = 0;

  CommandMgr.hasUndo = function() {
    return _undoStack.length > 0;
  };

  CommandMgr.hasRedo = function() {
    return _redoStack.length > 0;
  };

  CommandMgr.invoke = function() {
    _timerId = setTimeout(function() {
      CommandMgr._runOnce();
    }, 0);
  };

  CommandMgr.stop = function() {
    if (_timerId >= 0) clearTimeout(_timerId);
    _timerId = -1;
  };

  CommandMgr.startNewOperation = function() {
    _lastCmd = null; // 每一次start新操作的时候， 设置此值， 以阻止合并。
  };

  CommandMgr.addCommand = function(cmd, topPriority) {
    if (topPriority) {
      _preferredQueue.push(cmd);
    } else {
      _queue.push(cmd);
    }

    if (!_isWorking) {
      CommandMgr.invoke();
    }
  };

  CommandMgr._getCommand = function() {
    // 1) 每一次获取任务的时候, 都先检查高优先级的任务.
    // ToDo: 实现跳帧, 在绘制时间长的情况下, 只移动time, 不update和Render,直接绘制最新的帧.
    var cmd = _preferredQueue.shift();
    if (cmd == null) {
      return _queue.shift();
    }

    return cmd;
  };

  CommandMgr.addToUndoStack = function(cmd, fromRedo) {
    if (!fromRedo && (_redoStack.length > 0)) {
      _redoStack.splice(0);
    }
    while (_undoStack.length > TQ.Config.MAX_UNDO_STEP) {
      _undoStack.shift();
    }

    var mergedCmd;
    if ((mergedCmd = mergeCommand(_lastCmd, cmd)) != null) {
      _undoStack.pop();
      cmd = mergedCmd;
    }

    _undoStack.push(cmd);
    _lastCmd = cmd;
    _lastCmdGroupId = _cmdGroupId;
  };

  function mergeCommand(last, cmd) {
    if ((!!last) && (!!last.receiver) && // CompositeCommand没有receiver
            (_lastCmdGroupId === _cmdGroupId) &&
            (last.constructor.name2 === cmd.constructor.name2) &&
            (last.receiver.id === cmd.receiver.id)) {
      if ((last.constructor.name2 === "DeleteEleCommand") ||
                (last.constructor.name2 === "CompositeCommand")) {
        return null;
      } else {
        switch (cmd.constructor.name2) {
          case "MoveCommand":
          case "RotateCommand":
            cmd.oldValue = last.oldValue;
            break;
          case "GenCommand":
            switch (cmd.type2) {
              case TQ.GenCommand.SCALE: // 可以合并的命令种类
              case TQ.GenCommand.SCALE_AND_ROTATE:
              case TQ.GenCommand.CHANGE_LAYER:
                break;

              default:// 其余的种类，不能合并， 比如：GenCommand.ADD_ITEM, .PINIT, etc
                return null;
            }
            if (cmd.type2 === last.type2) {
              cmd.oldValue = last.oldValue;
            } else {
              return null;
            }
            break;
          default:
            return null;
        }
        return cmd;
      }
    }

    return null;
  }

  function addToRedoStack(cmd) {
    while (_redoStack.length > TQ.Config.MAX_UNDO_STEP) {
      _redoStack.shift();
    }

    _redoStack.push(cmd);
  }

  CommandMgr.directDo = function(cmd) {
    cmd.do();
    if (cmd.constructor.name2 === "CompositeCommand") {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, cmd.commands.length > 0);
    }
    if (!TQ.CompositeCommand.isOpen()) {
      CommandMgr.addToUndoStack(cmd);
    } else {
      TQ.CompositeCommand.addCommand(cmd);
    }
  };

  CommandMgr._runOnce = function() {
    _isWorking = true;

    for (var cmd = CommandMgr._getCommand(); cmd != null; cmd = CommandMgr._getCommand()) {
      CommandMgr.directDo(cmd);
    }

    _isWorking = false;
  };

  CommandMgr.undo = function() {
    if (_undoStack.length >= 1) {
      var cmd = _undoStack.pop();
      var result = cmd.undo();
      addToRedoStack(cmd);
      return result;
    }
    return null;
  };

  CommandMgr.redo = function() {
    if (_redoStack.length >= 1) {
      var cmd = _redoStack.pop();
      var result = cmd.redo();
      CommandMgr.addToUndoStack(cmd, true);
      return result;
    }

    return null;
  };

  CommandMgr.reset = function() {
    CommandMgr.stop();
    _undoStack.splice(0);
    _redoStack.splice(0);
    _queue.splice(0);
    _preferredQueue.splice(0);
    _isWorking = false;
    _cmdGroupId = 0;
  };

  CommandMgr.initialize = function() {
    CommandMgr.reset();
    $(document).mousedown(function() {
      _cmdGroupId++; // 开始一组新命令， 与前一组不能合并同类命令
    });

    TQ.InputMap.registerAction(TQ.InputMap.Z | TQ.InputMap.LEFT_CTRL_FLAG, CommandMgr.undo);
    TQ.InputMap.registerAction(TQ.InputMap.Y | TQ.InputMap.LEFT_CTRL_FLAG, CommandMgr.redo);
  };

  TQ.CommandMgr = CommandMgr;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */

window.TQ = window.TQ || {};

(function() {
  /**
     * 抽象命令类， 定义命令的接口
     * @constructor
     */
  function AbstractCommand() {
  }

  // 定义一个变量p代表该类的原型，以方便为其添加函数。
  var p = AbstractCommand.prototype;
  p.do = function() {};
  p.undo = function() {};
  p.redo = function() {};
  // 以下内容支持 复合命令
  p.addCommand = function(cmd) { return cmd; };
  p.removeCommand = function(cmd) { return cmd; };
  p.getCommand = function(id) { return id; };

  /**
     * 复合命令
     * @constructor
     */
  function CompositeCommand() {
    this.commands = [];
  }

  var __openedComposite = false;
  CompositeCommand.isOpen = function() {
    return __openedComposite;
  };

  CompositeCommand.addCommand = function(cmd) {
    if (!__openedComposite) {
      return TQ.Assert(!__openedComposite, "没有opened的compositeCommand");
    }

    return __openedComposite.addCommand(cmd);
  };

  TQ.inherit(CompositeCommand, AbstractCommand);
  CompositeCommand.prototype.do = function() {
    for (var i = 0; i < this.commands.length; i++) {
      this.commands[i].do();
    }
  };

  CompositeCommand.prototype.redo = function() {
    for (var i = 0; i < this.commands.length; i++) {
      this.commands[i].redo();
    }
  };

  CompositeCommand.prototype.undo = function() {
    for (var i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  };

  CompositeCommand.prototype.addCommand = function(cmd) {
    this.commands.push(cmd);
  };

  CompositeCommand.prototype.removeCommand = function(cmd) {
    var i = this.commands.indexOf(cmd);
    if (i < 0) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return false;
    }
    return (this.commands.splice(i, 1) != null);
  };

  CompositeCommand.prototype.getCommand = function(id) {
    if (this.commands.length === 0) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return null;
    }

    if (id < this.commands.length) {
      assertTrue(TQ.Dictionary.INVALID_PARAMETER, false);
      id = 0;
    }
    return this.commands[id];
  };

  // 以下open和close是为了让 Joint的移动可以快速undo
  CompositeCommand.open = function() {
    if (!__openedComposite) {
      __openedComposite = new CompositeCommand();
      document.addEventListener("mouseup", CompositeCommand.close);
    }
  };

  CompositeCommand.close = function() {
    if (!__openedComposite) {
      return;
    }
    document.removeEventListener("mouseup", CompositeCommand.close);
    TQ.CommandMgr.addToUndoStack(__openedComposite);
    __openedComposite = null;
  };

  function RotateCommand(ele, angle) {
    this.receiver = ele;
    this.newValue = Math.truncate6(angle);
    this.oldValue = Math.truncate6(ele.jsonObj.rotation);
  }

  TQ.inherit(RotateCommand, AbstractCommand);

  RotateCommand.prototype.do = function() {
    this.receiver.rotateTo(this.newValue);
    return ("rotate" + this.receiver);
  };

  RotateCommand.prototype.undo = function() {
    this.receiver.rotateTo(this.oldValue);
    return ("undo rotate" + this.receiver);
  };

  RotateCommand.prototype.redo = function() {
    this.receiver.rotateTo(this.newValue);
    return ("redo rotate" + this.receiver);
  };

  /* scale */
  function ScaleCommand(ele, scale) {
    this.receiver = ele;
    this.newValue = scale;
    this.oldValue = ele.getScaleInWorld(); // {sx:ele.jsonObj.sx, sy: ele.jsonObj.sy};
  }

  TQ.inherit(ScaleCommand, AbstractCommand);

  ScaleCommand.prototype.do = function() {
    this.receiver.scaleTo(this.newValue);
    return ("scale" + this.receiver);
  };

  ScaleCommand.prototype.undo = function() {
    this.receiver.scaleTo(this.oldValue);
    return ("undo scale" + this.receiver);
  };

  ScaleCommand.prototype.redo = function() {
    this.receiver.scaleTo(this.newValue);
    return ("redo scale" + this.receiver);
  };

  /* font, setSize */
  function SetSizeCommand(ele, scale) {
    this.receiver = ele;
    this.newValue = scale;
    this.oldValue = ele.getFontSize();
  }

  TQ.inherit(SetSizeCommand, AbstractCommand);

  SetSizeCommand.prototype.do = function() {
    this.receiver.setSize(this.newValue);
    return ("setSize" + this.receiver);
  };

  SetSizeCommand.prototype.undo = function() {
    this.receiver.setSize(this.oldValue);
    return ("undo setSize" + this.receiver);
  };

  SetSizeCommand.prototype.redo = function() {
    this.receiver.setSize(this.newValue);
    return ("redo setSize" + this.receiver);
  };

  /* font, setColor */
  function SetColorCommand(ele, scale) {
    this.receiver = ele;
    this.newValue = scale;
    this.oldValue = ele.getColor();
  }

  TQ.inherit(SetColorCommand, AbstractCommand);

  SetColorCommand.prototype.do = function() {
    this.receiver.setColor(this.newValue);
    return ("setColor" + this.receiver);
  };

  SetColorCommand.prototype.undo = function() {
    this.receiver.setColor(this.oldValue);
    return ("undo setColor" + this.receiver);
  };

  SetColorCommand.prototype.redo = function() {
    this.receiver.setColor(this.newValue);
    return ("redo setColor" + this.receiver);
  };

  // Move
  function MoveCommand(ele, pos) {
    this.receiver = ele;
    this.oldValue = ele.getPositionInWorld();
    this.newValue = pos;
  }

  TQ.inherit(MoveCommand, AbstractCommand);

  MoveCommand.prototype.do = function() {
    this.receiver.moveTo(this.newValue);
    return ("move" + this.receiver);
  };

  MoveCommand.prototype.undo = function() {
    this.receiver.moveTo(this.oldValue);
    return ("undo move" + this.receiver);
  };

  MoveCommand.prototype.redo = function() {
    this.receiver.moveTo(this.newValue);
    return ("redo move" + this.receiver);
  };

  // move pivot
  function MovePivotCommand(ele, pivot, pos, marker) {
    this.receiver = ele;
    this.receiver2 = marker;
    var oldPivot = { pivotX: Math.truncate6(ele.jsonObj.pivotX), pivotY: Math.truncate6(ele.jsonObj.pivotY) };
    var oldPos = ele.getPositionInWorld();
    oldPos.x = Math.truncate6(oldPos.x);
    oldPos.y = Math.truncate6(oldPos.y);
    this.oldValue = { pivot: oldPivot, pos: oldPos };
    pivot.pivotX = Math.truncate6(pivot.pivotX);
    pivot.pivotY = Math.truncate6(pivot.pivotY);
    pos.x = Math.truncate6(pos.x);
    pos.y = Math.truncate6(pos.y);
    this.newValue = { pivot: pivot, pos: pos };
  }

  TQ.inherit(MovePivotCommand, AbstractCommand);

  MovePivotCommand.prototype.do = function() {
    this.receiver.movePivot(this.newValue.pivot, this.newValue.pos, this.receiver2);
    return (this.name + this.receiver);
  };

  MovePivotCommand.prototype.undo = function() {
    this.receiver.movePivot(this.oldValue.pivot, this.oldValue.pos, this.receiver2);
    return ("undo move" + this.receiver);
  };

  MovePivotCommand.prototype.redo = MovePivotCommand.prototype.do;

  // Move anchor
  function MoveAnchorCommand(ele, pos) {
    this.receiver = ele;
    this.oldValue = ele.anchorMarker.getPositionInWorld();
    this.newValue = pos;
  }

  TQ.inherit(MoveAnchorCommand, AbstractCommand);

  MoveAnchorCommand.prototype.do = function() {
    this.receiver.moveAnchorTo(this.newValue);
    return ("move" + this.receiver);
  };

  MoveAnchorCommand.prototype.undo = function() {
    this.receiver.moveAnchorTo(this.oldValue);
    return ("undo move" + this.receiver);
  };

  MoveAnchorCommand.prototype.redo = MoveAnchorCommand.prototype.do;

  function SetTimeCommand(v) {
    this.receiver = TQ.FrameCounter;
    this.oldValue = TQ.FrameCounter.v;
    this.newValue = v;
  }

  TQ.inherit(SetTimeCommand, AbstractCommand);

  SetTimeCommand.prototype.do = function() {
    this.receiver.gotoFrame(this.newValue);
  };

  SetTimeCommand.prototype.undo = function() {
    this.receiver.gotoFrame(this.oldValue);
  };

  SetTimeCommand.prototype.redo = SetTimeCommand.prototype.do;

  function DeleteEleCommand(scene, ele) {
    this.receiver = scene;
    if (ele.parent != null) {
      this.receiver2 = ele.parent;
    } else {
      this.receiver2 = null;
    }
    this.oldValue = ele;
    this.newValue = ele;
  }

  TQ.inherit(DeleteEleCommand, AbstractCommand);

  DeleteEleCommand.prototype.do = function() {
    this.receiver.deleteElement(this.newValue);
  };

  DeleteEleCommand.prototype.undo = function() {
    if (this.receiver2 != null) {
      this.receiver2.undeleteChild(this.oldValue);
    } else {
      this.receiver.undeleteElement(this.oldValue);
    }
  };

  DeleteEleCommand.prototype.redo = DeleteEleCommand.prototype.do;

  AbstractCommand.name2 = "AbstractCommand";
  CompositeCommand.name2 = "CompositeCommand";
  MoveCommand.name2 = "MoveCommand";
  MoveAnchorCommand.name2 = "MoveAnchorCommand";
  MovePivotCommand.name2 = "MovePivotCommand";
  ScaleCommand.name2 = "ScaleCommand";
  SetColorCommand.name2 = "SetColorCommand";
  SetSizeCommand.name2 = "SetSizeCommand";
  RotateCommand.name2 = "RotateCommand";
  SetTimeCommand.name2 = "SetTimeCommand";
  DeleteEleCommand.name2 = "DeleteEleCommand";

  TQ.AbstractCommand = AbstractCommand;
  TQ.CompositeCommand = CompositeCommand;
  TQ.MoveCommand = MoveCommand;
  TQ.MoveAnchorCommand = MoveAnchorCommand;
  TQ.MovePivotCommand = MovePivotCommand;
  TQ.ScaleCommand = ScaleCommand;
  TQ.SetColorCommand = SetColorCommand;
  TQ.SetSizeCommand = SetSizeCommand;
  TQ.RotateCommand = RotateCommand;
  TQ.SetTimeCommand = SetTimeCommand;
  TQ.DeleteEleCommand = DeleteEleCommand;

  TQ.CommandMgr.scale = function(ele, newScale) {
    var oldValue = { sx: ele.jsonObj.sx, sy: ele.jsonObj.sy };
    TQ.CommandMgr.directDo(new TQ.GenCommand(TQ.GenCommand.SCALE, ele, newScale, oldValue));
  };

  TQ.CommandMgr.pinIt = function(ele) {
    TQ.CommandMgr.directDo(new TQ.GenCommand(TQ.GenCommand.PINIT, ele, null, null));
  };
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */

window.TQ = window.TQ || {};

(function() {
  var fns = null;
  function GenCommand(cmdIdOrArray, ele, newValue, oldValue) {
    if (!fns) {
      GenCommand.initialize();
    }
    this.receiver = ele;
    this.newValue = newValue;
    this.oldValue = oldValue;
    if (Array.isArray(cmdIdOrArray)) {
      this.type2 = cmdIdOrArray[0];
      this.dofn = cmdIdOrArray[0];
      this.undofn = cmdIdOrArray[1];
    } else {
      this.type2 = cmdIdOrArray;
      this.dofn = fns[cmdIdOrArray].dofn;
      this.undofn = fns[cmdIdOrArray].undofn;
    }
  }
  GenCommand.SCALE = "cmd_scale";
  GenCommand.SCALE_AND_ROTATE = "cmd_scale_rotate";
  GenCommand.MIN_JOINT_ANGLE = "cmd_min_joint_angle";
  GenCommand.MAX_JOINT_ANGLE = "cmd_max_joint_angle";
  GenCommand.CHANGE_LAYER = "cmd_change_layer";
  GenCommand.SET_3D_OBJ = "cmd_set_3D_obj";
  GenCommand.ADD_ITEM = "cmd_add_item";
  GenCommand.PINIT = "cmd_pin_it";

  GenCommand.initialize = function() {
    fns = [];
    fns[GenCommand.SCALE] = { dofn: "scaleTo", undofn: "scaleTo" };
    fns[GenCommand.SCALE_AND_ROTATE] = { dofn: "scaleAndRotateTo", undofn: "scaleAndRotateTo" };
    fns[GenCommand.MIN_JOINT_ANGLE] = { dofn: "setMinAngle", undofn: "setMinAngle" };
    fns[GenCommand.MAX_JOINT_ANGLE] = { dofn: "setMaxAngle", undofn: "setMaxAngle" };
    fns[GenCommand.CHANGE_LAYER] = { dofn: "moveZ", undofn: "moveToZ" };
    fns[GenCommand.SET_3D_OBJ] = { dofn: "attachTo", undofn: "detach" };
    fns[GenCommand.ADD_ITEM] = { dofn: "addElementDirect", undofn: "deleteElement" };
    fns[GenCommand.PINIT] = { dofn: "pinIt", undofn: "pinIt" };
  };
  TQ.inherit(GenCommand, TQ.AbstractCommand);

  GenCommand.prototype.do = function() {
    this.receiver[this.dofn](this.newValue);
    TQ.AssertExt.isTrue(typeof this.oldValue !== "undefined", "oldValue为什么没有赋值？");
  };

  GenCommand.prototype.undo = function() {
    this.receiver[this.undofn](this.oldValue);
  };

  GenCommand.prototype.redo = GenCommand.prototype.do;

  GenCommand.name2 = "GenCommand";
  TQ.GenCommand = GenCommand;
}());

// extensions:
(function() {
  TQ.CommandMgr.directScale = function(ele, newScale) {
    var cmd = new TQ.GenCommand(TQ.GenCommand.SCALE, ele, newScale, ele.getScaleInWorld());
    return TQ.CommandMgr.directDo(cmd);
  };

  TQ.CommandMgr.directScaleAndRotate = function(ele, scale, angle) {
    var oldValue = {
      scale: ele.getScaleInWorld(),
      angle: Math.truncate6(ele.jsonObj.rotation)
    };

    var newScaleAndRotate = {
      scale: scale,
      angle: angle
    };

    return TQ.CommandMgr.directDo(new TQ.GenCommand(TQ.GenCommand.SCALE_AND_ROTATE, ele, newScaleAndRotate, oldValue));
  };
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};
(function() {
  /**
   * TraceMgr, 负责Trace的增删改查/显示/Fixup/Save/Open等操作,
   * * 只显示当前Level的 trace, 不显示其余level的.
   * * 任何一个物体都可以显示Trace, 或者不显示. (但是整体的, 不能指定显示A到B时间段的Trace)
   * * 任何一个子物体, 都可以.
   * * 不保存到Scene文件, 而是临时生成的
   * * 它的目的是查看运动轨迹, 便于修改; 不同于: 按照预设轨迹的运动, 先绘制路径, 再按照轨迹来运动.
   * @class TraceMgr
   * @static
   **/
  var TraceMgr = function() {
    TQ.AssertExt.invalidLogic(0, "TraceMgr cannot be instantiated");
  };

  TraceMgr.initialize = function() {
  };

  TraceMgr.addVertexKeyPressed = false;
  TraceMgr.addNewPosition = function(ele) {
    var pDevice = TQ.Utility.worldToDevioce(ele.jsonObj.x, ele.jsonObj.y);
    if (!ele.trace) {
      TQ.InputMap.registerAction(TQ.InputMap.ADD_VERTEX, function() {
        TraceMgr.addVertexKeyPressed = true;
      });
      ele.trace = new Trace("#0000FF", 2);
    }
    if (TraceMgr.addVertexKeyPressed) {
      TraceMgr.addVertexKeyPressed = false;
      ele.trace.add(pDevice);
    } else if (ele.trace.isEmpty()) {
      ele.trace.add(pDevice);
      ele.trace.add(pDevice);
    } else {
      ele.trace.update(pDevice);
    }
  };

  TraceMgr.delete = function(ele) {
    if (!ele.trace) return;
    ele.trace.removeFromStage();
    ele.trace = null;
  };

  // Trace 类
  var Trace = function(color, thickness) {
    this.color = color;
    this.thickness = thickness;

    this.lastPt = null;
    this.points = [];
  };

  Trace.prototype.updateShape = function() {
  };

  Trace.prototype.update = function(pDevice) {
    if (this.points.length > 0) {
      this.points.pop(); // 先丢弃旧的临时点，再记录新的临时点
    }
    this.add(pDevice);
    this.draw();
  };

  Trace.prototype.isEmpty = function() {
    return (this.points.length === 0);
  };

  Trace.prototype.add = function(pDevice) {
    this.points.push(pDevice);
  };

  Trace.prototype.draw = function() {
    if (this.shape) {
      this.removeFromStage();
      this.shape = null;
      this.graphics = null;
    }
    this.shape = new createjs.Shape();
    this.addToStage();
    this.shape.x = 0;
    this.graphics = this.shape.graphics;
    this.graphics.setStrokeStyle(this.thickness, "round", null, null).beginStroke(this.color);
    this.shape.uncache();

    var len = this.points.length;
    if (len > 1) {
      this.graphics.moveTo(this.points[0].x, this.points[0].y);
      for (let i = 0; i < len; i++) {
        this.graphics.lineTo(this.points[i].x, this.points[i].y);
      }
    }
  };

  Trace.prototype.addToStage = function() {
    stageContainer.addChild(this.shape);
  };

  Trace.prototype.removeFromStage = function() {
    stageContainer.removeChild(this.shape);
  };

  Trace.prototype.destory = function() {
    stageContainer.removeChild(this.shape);
    this.shape = null;
    this.graphics = null;
  };

  Trace.prototype.toJSON = function() {
    return { color: this.color, thickness: this.thickness, points: this.points };
  };

  // static 函数
  Trace.build = function(desc) {
    if (!desc.points) {
      return null;
    }

    var trace = new Trace(desc.color, desc.thickness);
    for (var i = 0; i < desc.points.length; i++) {
      trace.add(desc.points[i]);
    }
    desc.points = null;

    return trace;
  };

  TQ.TraceMgr = TraceMgr;
  TQ.Trace = Trace;
}());

/**
 * 图强动漫引擎, 专利产品, 让生活动漫起来.
 * 强大的创意动力源泉
 * 微创意拍摄和播放专用的Timer,(实际上在内部就是 Framer Counter, 对外,为了用户方便, 按照当前FPS转为时间),
 * FrameCounter记录实际拍摄的时刻(帧编号), 而不是日历时长. 时间轴的0点在片头, 终点在片尾..
 * 例如: 假设每秒20帧: FPS = 20; i.e. 一帧的对应1/20 秒, === 0.05秒.
 * 片子的第一个画面(帧): FrameCounter =0, 第二个画面(帧): FrameCounter = 1, 或0.05秒, 依次类推,
 * 第100帧, FrameCounter = 100, 或5秒.
 * 在一个Scene内如此,
 * 在一个Level内部,也如此. Level 1里面有Frame 0, Level 2 里面也有. 各是各的.
 */

window.TQ = window.TQ || {};

(function() {
  function FrameCounter() {
    assertNotHere(TQ.Dictionary.INVALID_LOGIC); // Singleton, 禁止调用
  }

  var _isRecording = false;
  var NORMAL_SPEED = 1;
  var LOW_SPEED = 0.5;
  var STATE_GO = 1; // 调在使用之前, 常量在使用之前必须先定义(包括初始化,例如下面给_state赋值)
  var STATE_STOP = 0;
  var STATE_PAUSE = 2;
  var STATE_RESUME = 3;
  var baseStep = NORMAL_SPEED;
  var step = baseStep;
  var abOptions = null;
  var lastTimestamp;

  FrameCounter.EVENT_AB_PREVIEW_STOPPED = "ab preview stopped";
  FrameCounter.isNew = true; // 新的时刻, 需要更新数据
  FrameCounter.v = 0;
  FrameCounter.defaultFPS = 20;
  var vMax = 3 * FrameCounter.defaultFPS; // 空白带子, 长度为 30秒 * 每秒20帧,  600
  FrameCounter.cmdGotoFrame = cmdGotoFrame;

  var _FPS = FrameCounter.defaultFPS; // 下划线是内部变量, 禁止外面引用
  var state = STATE_STOP;
  var requestState = null;
  var autoRewind = false;
  var currLevel = null;

  FrameCounter.addHook = addHook;
  FrameCounter.toggleSpeed = toggleSpeed;

  var _hooks = [];
  function addHook(hook) {
    _hooks.push(hook);
  }

  /*  FrameCounter 是一个控制器, 不是存储器, 所以它不保留任何值,
     * 也不复制这些值, 以避免数据的不一致.
     * 而Level是存储器, (也可能带有执行器的功能, 复合型的), 保有 FPS, fileLength等值.
     * */
  FrameCounter.initialize = function(t0, FPS, level) {
    // ToDo: 要 最大长度吗? 要, 而且是当前level的实实在在的max
    assertNotNull(TQ.Dictionary.FoundNull, t0); // 必须强制调用者遵从, 以简化程序,  因为此部分与用户的任意性无关
    assertNotNull(TQ.Dictionary.FoundNull, FPS);
    assertNotNull(TQ.Dictionary.FoundNull, level);
    FrameCounter.v = t0 * FPS;
    _FPS = FPS;
    currLevel = level;
    vMax = t2f(level.getTime());
    TQ.InputMap.registerAction(TQ.InputMap.LAST_FRAME_KEY,
      function() {
        level.setTime(FrameCounter.t());
        vMax = FrameCounter.v;
      }
    );
  };

  FrameCounter.isAtBeginning = function() {
    return FrameCounter.v < 1;
  };

  FrameCounter.t = function() {
    return FrameCounter.v / _FPS;
  };

  FrameCounter.tGrid = function() {
    return FrameCounter.gridSnap(FrameCounter.t());
  };

  FrameCounter.gridSnap = function(t) {
    return Math.round(t * 100) / 100;
  };

  FrameCounter.f2t = function(frameNumber) {
    return (frameNumber / _FPS);
  };

  FrameCounter.f2tGrid = function(frameNumber) {
    return FrameCounter.gridSnap(FrameCounter.f2t());
  };

  FrameCounter.t2f = t2f;
  function t2f(t) {
    return t * _FPS;
  }

  FrameCounter.forward = function() {
    step = 2 * baseStep;
    state = STATE_GO;
  };

  FrameCounter.backward = function() {
    TQ.AssertExt.depreciated("backward: 过时了");
    step = -2 * baseStep;
    state = STATE_GO;
  };

  FrameCounter.gotoBeginning = function() {
    cmdGotoFrame(0);
  };

  FrameCounter.gotoEnd = function() {
    cmdGotoFrame(vMax);
  };

  FrameCounter.gotoFrame = function(v) {
    FrameCounter.v = v;
    TQ.FrameCounter.isNew = true;
  };

  FrameCounter.setABOptions = function(options) {
    abOptions = options;
  };

  FrameCounter.goto = function(t) {
    FrameCounter.gotoFrame(t * _FPS);
  };

  // 前进一个delta. (delta是负值, 即为倒带)
  FrameCounter.update = function() {
    FrameCounter.updateState();
    var newTimestamp = Date.now();
    var vDelta = t2f((newTimestamp - lastTimestamp) / 1000);
    lastTimestamp = newTimestamp;

    if (state === STATE_GO) {
      if (FrameCounter.hasUIData) {
        FrameCounter.hasUIData = false;
        return;
      }

      FrameCounter.v = FrameCounter.v + vDelta;

      if (abOptions) {
        if (FrameCounter.t() > abOptions.tEnd) {
          FrameCounter.stop();
        }
      } else if (FrameCounter.v > vMax) {
        if (_isRecording) {
          vMax += step;
        } else {
          // FrameCounter.v = vMax;
        }
      }

      if (FrameCounter.v < 0) {
        if (autoRewind) {
          FrameCounter.v = vMax;
        } else {
          FrameCounter.v = 0;
        }
      }

      TQ.FrameCounter.isNew = true;
      assertTrue(TQ.Dictionary.CounterValidation, FrameCounter.v >= 0);
    }

    if (_hooks.length > 0) {
      _hooks.forEach(updateHook);
    }
  };

  function updateHook(hook) {
    hook();
  }

  FrameCounter.updateState = function() {
    switch (requestState) {
      case null: break;
      case STATE_GO : {
        step = baseStep;
        state = STATE_GO;
        break;
      }
      case STATE_STOP: {
        state = STATE_STOP;
        break;
      }
      case STATE_PAUSE:
        state = STATE_PAUSE;
        break;

      case STATE_RESUME:
        state = STATE_GO;
        break;
    }
    requestState = null;
  };

  // state: 不能由外部改变, 必须是update自己改变, 以保持其唯一性
  FrameCounter.play = function() {
    lastTimestamp = Date.now();
    requestState = STATE_GO;
    // ToDo: 暂时关闭GIF文件的生成
    /* if (TQ.InputMap.isPresseds[TQ.InputMap.LEFT_CTRL])
        {
            canvas.width = 180;
            canvas.height = 180;
            $("#testCanvas").hide();
            TQ.GifManager.begin();
        }
        */
  };

  FrameCounter.stop = function() {
    requestState = STATE_STOP;
    if (abOptions) {
      var tStop = abOptions.stopAt;
      abOptions = null;
      setTimeout(function() {
        FrameCounter.goto(tStop);
        TQ.DirtyFlag.requestToUpdateAll();
        TQ.Base.Utility.triggerEvent(document, FrameCounter.EVENT_AB_PREVIEW_STOPPED);
      }, 100);
    } else {
      cmdGotoFrame(FrameCounter.v);
    }

    if (TQ.GifManager.isOpen) {
      TQ.GifManager.end();
      TQ.Graphics.setCanvas();
      $("#testCanvas").show();
    }
  };

  FrameCounter.pause = function() {
    if ((requestState === STATE_GO) ||
            (state === STATE_GO)) {
      requestState = STATE_PAUSE;
    }
  };

  FrameCounter.resume = function() {
    if ((requestState === STATE_PAUSE) ||
            (state === STATE_PAUSE)) {
      requestState = STATE_RESUME;
    }
  };

  FrameCounter.autoRewind = function() {
    autoRewind = !autoRewind;
  };

  FrameCounter.startRecord = function() {
    _isRecording = true;
  };

  FrameCounter.stopRecord = function() {
    _isRecording = false;
  };

  FrameCounter.isInverse = function() { return step < 0; };
  FrameCounter.isPlaying = function() { return ((state === STATE_GO) || (state === STATE_PAUSE)); };
  FrameCounter.isPaused = function() { return (FrameCounter.isPlaying() && (state === STATE_PAUSE)); };
  FrameCounter.isRecording = function() { return _isRecording; };
  FrameCounter.isRequestedToStop = function() { return (requestState === STATE_STOP); };
  FrameCounter.finished = function() { return (!_isRecording && (FrameCounter.v >= vMax)); };
  FrameCounter.abPreviewFinished = function() {
    return (abOptions && (FrameCounter.t() > abOptions.tEnd));
  };
  FrameCounter.isAutoRewind = function() { return autoRewind; };

  FrameCounter.maxTime = function() {
    return vMax / _FPS;
  };

  FrameCounter.reset = function() {
    requestState = null;
    vMax = 3 * FrameCounter.defaultFPS; // 空白带子, 长度为 30秒 * 每秒20帧,  600
    FrameCounter.v = 0;
    state = STATE_STOP;
  };

  FrameCounter.setTMax = function(tMax) {
    vMax = t2f(tMax);
    if (FrameCounter.v > vMax) {
      FrameCounter.v = vMax;
    }
  };

  FrameCounter.trim = function(tObj1, tObj2) {
    if (tObj1.levelId === tObj2.levelId) {
      vMax -= t2f(tObj2.t - tObj1.t);
    } else { // in tObj2.levelId,
      vMax -= t2f(tObj2.t);
    }
  };

  var stateReceiver = null;
  function toggleSpeed(flag, receiver) {
    if (flag && (flag === TQ.Const.TOGGLE_RESET)) {
      TQ.AssertExt.expectObject(!receiver);
      stateReceiver = receiver;
      stateReceiver.isLowSpeed = false;
      normalSpeed();
    } else {
      TQ.AssertExt.expectObject(!stateReceiver);
      stateReceiver.isLowSpeed = !stateReceiver.isLowSpeed;
      if (stateReceiver.isLowSpeed) {
        lowSpeed();
      } else {
        normalSpeed();
      }
    }
  }

  function lowSpeed() {
    if (baseStep === NORMAL_SPEED) {
      step = step * LOW_SPEED / NORMAL_SPEED;
    }
    baseStep = LOW_SPEED;
  }

  function normalSpeed() {
    if (baseStep === LOW_SPEED) {
      step = step * NORMAL_SPEED / LOW_SPEED;
    }
    baseStep = NORMAL_SPEED;
  }

  function cmdGotoFrame(v) {
    TQ.CommandMgr.directDo(new TQ.SetTimeCommand(v));
  }

  TQ.FrameCounter = FrameCounter;
}());

/**
 * 图强动漫引擎, 专利产品, 动画化的课件，一幅图胜过前言万语.
 * 强大的创意动力源泉
 * Begin, End,
 */

window.TQ = window.TQ || {};
var __gGifGenerator = null;

(function() {
  function GifManager() {
    assertNotHere(TQ.Dictionary.INVALID_LOGIC); // Singleton, 禁止调用
  }
  GifManager.isWorking = false;
  GifManager.isOpen = false;

  GifManager.begin = function() {
    if (GifManager.isWorking) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return;
    }

    if (!__gGifGenerator) {
      __gGifGenerator = new GIF({
        workers: "4",
        quality: "90",
        repeat: "0",
        background: "#000000",
        width: "180",
        height: "180"
      });
    }
    GifManager.isWorking = true;
    GifManager.isOpen = true;
  };

  GifManager.end = function() {
    if (!GifManager.isOpen) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return;
    }

    if (__gGifGenerator) {
      __gGifGenerator.on("finished", function(blob) {
        if (TQ.Utility.hasEnv(TQ.Utility.BR_CHROME)) {
          window.open(window.webkitURL.createObjectURL(blob));
        } else {
          window.open(window.URL.createObjectURL(blob)); // FireFox
        }
        __gGifGenerator = null;
        GifManager.isWorking = false;
        TQ.MessageBubble.close();
      });
      __gGifGenerator.render();
      GifManager.isOpen = false;
      TQ.MessageBubble.show(TQ.Dictionary.IS_PROCESSING);
    }
  };

  GifManager.addFrame = function() {
    if ((!GifManager.isOpen) || (!__gGifGenerator)) {
      return;
    }
    __gGifGenerator.addFrame(canvas, { copy: true, delay: 20 });
  };

  TQ.GifManager = GifManager;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * Input map , 映射输入的键盘和鼠标信息， 到一个内部数据，
 * 在每一个cycle， 清理一次
 * 静态变量
 */

TQ = TQ || {};
var TOUCH_MOVING_FLAG = 999;

(function() {
  var InputMap = {};
  InputMap.playOnlyFlag = true;
  InputMap.isPresseds = [];
  InputMap.lastPresseds = [];
  InputMap.DELETE_KEY = 46;
  InputMap.ERASE_KEY = InputMap.R = 82;
  InputMap.SHOW_ALL_HIDEN_OBJECT_KEY = InputMap.A = 65;
  InputMap.ADD_VERTEX = InputMap.A = 65;
  InputMap.CLONE_Key = InputMap.C = 67;
  InputMap.TEXT_EDIT_KEY = InputMap.E = 69;
  InputMap.GRID_ON_OFF_KEY = InputMap.G = 71;
  InputMap.HIDE_KEY = InputMap.H = 72;
  InputMap.SHOW_KEY = InputMap.S = 83;
  InputMap.ROTATE_KEY = InputMap.Z = 90;
  InputMap.ROTATE_KEY = InputMap.Y = 89;
  InputMap.PLAY_STOP_KEY = InputMap.SPACE = 32;
  InputMap.LAST_FRAME_KEY = InputMap.F7 = 118;
  InputMap.ENTER = 13;
  InputMap.LEFT_SHIFT = 16;
  InputMap.LEFT_CTRL = 17;
  InputMap.LEFT_ALT = 18;
  InputMap.EMPTY_SELECTOR = 27; // ESCAPE;
  InputMap.D0 = 48;
  InputMap.D1 = 49;
  InputMap.D2 = 50;
  InputMap.D3 = 51;
  InputMap.D4 = 52;
  InputMap.D5 = 53;
  InputMap.D6 = 54;
  InputMap.D7 = 55;
  InputMap.D8 = 56;
  InputMap.D9 = 57;
  InputMap.LEFT_ARROW = 39;
  InputMap.RIGHT_ARROW = 37;

  // 支持组合键
  InputMap.LEFT_SHIFT_FLAG = 0x1000;
  InputMap.LEFT_CTRL_FLAG = 0x2000;
  InputMap.LEFT_ALT_FLAG = 0x4000;

  InputMap.isMouseDown = false;
  InputMap.isTouchMoving = false;
  InputMap.toolbarState = InputMap.NO_TOOLBAR_ACTION = null;

  // 私有变量， 用下划线开头， 放在公共变量的后面，必须在所有函数的前面，
  InputMap._on = true; //  true, 由它处理键盘； false: 不.

  InputMap.setToolbarState = function(buttonIdString) {
    assertNotNull(TQ.Dictionary.FoundNull, buttonIdString);
    InputMap.toolbarState = buttonIdString;
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_TOOLBAR);
  };

  InputMap.IsOperating = function() {
    return ((InputMap.isTouchMoving || InputMap.isMouseDown) &&
      (InputMap.toolbarState == null));
  };

  InputMap.maps = [];
  InputMap.registerAction = function(key, action) {
    // key可以是组合键, 例如:
    // key = InputMap.DELETE_KEY | InputMap.LEFT_SHIFT_FLAG;
    InputMap.maps[key] = action;
  };

  InputMap.removeAction = function(key, action) {
    // key可以是组合键, 例如:
    // key = InputMap.DELETE_KEY | InputMap.LEFT_SHIFT_FLAG;
    delete InputMap.maps[key];
  };

  InputMap.restart = function() {
    InputMap.mouseMoving = false;
    InputMap.toolbarState = InputMap.NO_TOOLBAR_ACTION;
    InputMap.lastPresseds = InputMap.isPresseds;
    InputMap.isPresseds = [];
    // 复制长效键:
    InputMap.isPresseds[InputMap.Z] = InputMap.lastPresseds[InputMap.Z]; // 旋转
    InputMap.isPresseds[InputMap.LEFT_SHIFT] = InputMap.lastPresseds[InputMap.LEFT_SHIFT];
    InputMap.isPresseds[InputMap.LEFT_CTRL] = InputMap.lastPresseds[InputMap.LEFT_CTRL];
    InputMap.isPresseds[InputMap.LEFT_ALT] = InputMap.lastPresseds[InputMap.LEFT_ALT];
  };

  InputMap.initialize = function(playOnlyFlag) {
    if (playOnlyFlag) {
      return;
    }

    $(document).bind("mousemove touchmove touchcancel", function(e) {
      // TQ.Log.info("which:" + e.which + "mousedown:" + InputMap.isMouseDown + " type:" + e.type + "(x,y):" + e.screenX + "," + e.screenY);
      InputMap.updateSpecialKey(e);
    });

    $(document).bind("mouseup touchend", function(e) {
      InputMap.updateSpecialKey(e);
    });

    $(document).bind("mousedown touchstart", function(e) {
      InputMap.updateSpecialKey(e);
    });

    $(document).keydown(function(e) {
      if (!InputMap._on && e.which !== InputMap.ENTER) {
        return;
      }
      InputMap.updateSpecialKey(e);
      var action = InputMap.maps[InputMap.getCombination(e)];
      if ((action != null) && (!InputMap.isPresseds[e.which])) { // 有action, 而且首次按下
        // 一对down和up,复制一份, 持续按住不放, 只算一次.
        e.stopPropagation();
        e.preventDefault();
        TQ.TaskMgr.addTask(action, []);
      }

      InputMap._updateKey(e, true);
    });

    $(document).keyup(function(e) {
      if (!InputMap._on) {
        return;
      }
      InputMap.updateSpecialKey(e);
      InputMap._updateKey(e, false);
    });
  };

  InputMap._updateKey = function(e, isDown) {
    InputMap.isPresseds[e.which] = isDown;
    // displayInfo2(e.which);
  };

  InputMap.getCombination = function(e) {
    var result = e.which;
    if (InputMap.isPresseds[InputMap.LEFT_CTRL]) result |= InputMap.LEFT_CTRL_FLAG;
    if (InputMap.isPresseds[InputMap.LEFT_SHIFT]) result |= InputMap.LEFT_SHIFT_FLAG;
    if (InputMap.isPresseds[InputMap.LEFT_ALT]) result |= InputMap.LEFT_ALT_FLAG;
    return result;
  };

  InputMap.updateSpecialKey = function(e) {
    // 在复合键(例如：alt + Delete 放开的时候, 只有一次keyUp事件, 所有alt键放开的信息丢失了, 所以,需要下面的更新方法)
    InputMap.isPresseds[InputMap.LEFT_CTRL] = e.ctrlKey;
    InputMap.isPresseds[InputMap.LEFT_SHIFT] = e.shiftKey;
    InputMap.isPresseds[InputMap.LEFT_ALT] = e.altKey;

    //  mouse click只激发touchStart，不触发touchEnd，
    // 所以， 状态的控制， 必须
    // 让touchEnd和mouseUp使用相同的处理，（同理：
    // touchStart和mouseDown也使用相同的处理
    switch (e.type) {
      case "mousedown":
      case "touchstart":
        InputMap.isMouseDown = true;
        break;

      case "mouseup":
      case "touchend":
      case "touchcancel":
        InputMap.isMouseDown = false;
        break;
    }

    if (InputMap.isMouseDown) {
      switch (e.type) {
        case "mousemove":
        case "touchmove":
          InputMap.mouseMoving = true;
          break;
        case "touchcancel":
          InputMap.mouseMoving = false;
          break;
      }
    } else {
      InputMap.mouseMoving = false;
    }

    InputMap.updateTouch(e);
  };

  InputMap.updateTouch = function(e) {
    switch (e.type) {
      case "touchmove": InputMap.isTouchMoving = true; break;
      case "touchstart": InputMap.isTouchMoving = true; break;
      case "touchend": break;
      default: InputMap.isTouchMoving = false;
    }
  };

  InputMap.turnOn = function() {
    TQ.InputMap._on = true;
  };

  InputMap.turnOff = function() {
    TQ.InputMap._on = false;
  };

  TQ.InputMap = InputMap;
}());

/**
 * Tuqiang Game Engine
 * Copyright Tuqiang Tech
 * 创建了 一个 静态的 常量，类， State， 用于记录 Level的状态。
 * Created at : 12-11-14 下午4:06
 */

window.TQBase = window.TQBase || {};

(function() {
  function LevelState() {
  }

  LevelState.NOT_INIT = 0;
  LevelState.ISLOADING = 1; // 只是load，不能立即加入Stage
  LevelState.LOADED = 2;
  LevelState.INITING = 3;
  LevelState.RUNNING = 4;
  LevelState.EDITING = 5;
  LevelState.EXIT = 6;
  LevelState.SHOOTING = 16;
  LevelState.PLAYING = 17;
  LevelState.PAUSE = 18;

  LevelState.OP_NO = 0;
  LevelState.OP_TIMER_UI = 0x101;
  LevelState.OP_TOOLBAR = 0x103;
  LevelState.OP_TABS = 0x107;
  LevelState.OP_CANVAS = 0x10F; //  具体的操作, 及其元素, 见Element
  LevelState.OP_FLOATTOOLBAR = 0x11F;
  LevelState.operation = LevelState.OP_NO;
  LevelState.saveOperation = function(op) { LevelState.operation = op; };
  LevelState.isOperatingCanvas = function() { return (LevelState.operation === LevelState.OP_CANVAS); };
  LevelState.isOperatingTimerUI = function() { return (LevelState.operation === LevelState.OP_TIMER_UI); };
  LevelState.reset = function() {
    LevelState.operation = 0;
  };

  TQBase.LevelState = LevelState;
}());

/**
 * Tuqiang Game Engine
 * Copyright Tuqiang Tech
 * Created at : 12-11-14 下午4:06
 */

window.TQBase = window.TQBase || {};

(function() {
  function Trsa() {
  }

  Trsa.lastOperationFlag = 0;
  // 功能单一化:
  // 1) 只是 生成新的世界坐标.
  // 2) 不绘制了(不修改displayObj的值), 留给element.update 统一做
  //
  // 但是, 提供自己的状态, 供外界查询
  Trsa.do = function(element, thisLevel, offset, ev) {
    var target = element.displayObj;
    if (element.isPinned()) {
      displayInfo2(TQ.Dictionary.Locked);
      return;
    }
    if (target == null) {
      displayInfo2("empty object or deleted, element.TBD = " + element.TBD);
      return;
    }

    currScene.isSaved = false;
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
    if ((TQ.SkinningCtrl.hasNew)) { // 它们可能删除了当前选中的物体;
    } else if (TQ.InputMap.isPresseds[TQ.InputMap.LEFT_SHIFT] || TQ.InputCtrl.vkeyLift) {
      element.setFlag(TQ.Element.ZING);
      TQ.MoveCtrl.moveZ(element, offset, ev);
    } else if (element.isJoint() && !TQ.InputCtrl.inSubobjectMode) {
      element.setFlag(TQ.Element.TRANSLATING);
      element.setFlag(TQ.Element.ROTATING);
      Trsa.lastOperationFlag = element.getOperationFlags();
      TQ.CompositeCommand.open();
      TQ.IKCtrl.do(element, offset, ev, false);
    } else {
      if (altIsPressed(ev) || TQ.InputCtrl.vkeyRotate) {
        element.setFlag(TQ.Element.ROTATING);
        Trsa.lastOperationFlag = element.getOperationFlags();
        TQ.IKCtrl.do(element, offset, ev, true);
      } else if (TQ.InputMap.isPresseds[TQ.InputMap.LEFT_CTRL] || TQ.InputCtrl.vkeyScale) {
        element.setFlag(TQ.Element.SCALING);
        TQ.InputCtrl.scale(element, target, offset, ev);
      } else if (TQ.Utility.isMultiTouchEvent(ev) && ev.nativeEvent.scale) { // nativeEvent.scale在Win7触屏笔记本上不存在
        var scale = 1 + (ev.nativeEvent.scale - 1) * 0.5; // 减慢速度， 太快了
        TQ.InputCtrl.doScale(element, scale, scale);
      } else {
        element.setFlag(TQ.Element.TRANSLATING);
        this._move(element, thisLevel, offset, ev);
        if (target.isClipPoint) {
          this._calculateScale(target, thisLevel, offset, ev, element.host);
        }

        if (!target.isClipPoint) {
          Trsa.displayClips(target);
        } else {
          Trsa.displayClips(element.host);
        }
      }
    }

    Trsa.lastOperationFlag = element.getOperationFlags();
    var touches = TQ.Utility.getTouches(ev);
    var posInfo = (touches.length <= 0) ? ""
      : ", at(" + touches[0].pageX + ", " + touches[0].pageY + ")";
    TQ.Log.debugInfo(ev.type + ", OP: " + Trsa.lastOperationFlag + posInfo);
    element.dirty = true;
    element.dirty2 = true;
    element.isOperating = true;
    // indicate that the stage should be updated on the next tick:
    thisLevel.dirty = true;
  };

  Trsa._move = function(element, thisLevel, offset, ev) {
    // offsetY 是device下的， 必须转为jsonObj所用的World坐标系或用户坐标系，才能赋给jsonObj
    var ptDevice = {
      x: ev.stageX + offset.x,
      y: ev.stageY + offset.y
    };
    var ptWorld = element.dc2World(ptDevice);
    if (!element.isMarker()) {
      TQ.CommandMgr.directDo(new TQ.MoveCommand(element, ptWorld));
    } else {
      if (element.host) {
        element.host.onMoveMarker(element, ptWorld);
      }
    }
    if (TQ.InputCtrl.leaveTraceOn) {
      TQ.TraceMgr.addNewPosition(element);
    }
  };

  /** *
     *   ---> y
     *   |     0    7    6
     *   V
     *         1         5
     *
     *         2    3    4
     *
     * @param target
     */
  Trsa.displayClips = function(target) {
    if (!TQ.Config.DISPLAY_CLIPS) {
      return;
    }

    var CLIP_WIDTH_HALF = 16 / 2;
    if ((Trsa.clipPoints === undefined) || (Trsa.clipPoints == null) ||
            (Trsa.clipPoints[0] === undefined)) {
      Trsa.generateClips();
    }

    if (target.isClipPoint) {
      return;
    }

    var h = target.getHeight();
    var w = target.getWidth();

    var offsets = [
      { "x": 0, "y": 0 },
      { "x": 0, "y": h / 2 },
      { "x": 0, "y": h },
      { "x": w / 2, "y": h },
      { "x": w, "y": h },
      { "x": w, "y": h / 2 },
      { "x": w, "y": 0 },
      { "x": w / 2, "y": 0 },
      { "x": 0, "y": 0 }
    ];

    for (var i = 0; i < 8; i++) {
      Trsa.positionIt(Trsa.clipPoints[i], target.x + offsets[i].x - CLIP_WIDTH_HALF, target.y + offsets[i].y - CLIP_WIDTH_HALF);
    }
  };

  Trsa.positionIt = function(jsonObj, x, y) {
    if (jsonObj.displayObj === undefined) {
      return;
    }

    jsonObj.x = jsonObj.displayObj.x = x;
    jsonObj.y = jsonObj.displayObj.y = y;
  };

  Trsa.clipPoints = null;
  Trsa.generateClips = function() {
    var jsonObjs = [
      { isVis: 1, x: 10.0, y: 11.0, ID: 0, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 20.0, y: 11.0, ID: 1, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 30.0, y: 11.0, ID: 2, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 40.0, y: 11.0, ID: 3, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 50.0, y: 11.0, ID: 4, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 60.0, y: 11.0, ID: 5, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 70.0, y: 11.0, ID: 6, isClipPoint: true, src: "sysImages/dragpoint.jpg" },
      { isVis: 1, x: 80.0, y: 11.0, ID: 7, isClipPoint: true, src: "sysImages/dragpoint.jpg" }
    ];
    Trsa.clipPoints = new Array(8);
    for (var i = 0; i < 8; i++) {
      Trsa.clipPoints[i] = currScene.addItem(jsonObjs[i], jsonObjs[i].x, jsonObjs[i].y, 1);
    }
  };

  Trsa.getClipId = function(clip) {
    return clip.jsonObj.ID;
  };

  Trsa._calculateScale = function(target, thisLevel, offset, ev, item) {
    var sx = (target.x - item.getCenterX()) * 2 / item.naturalWidth();
    var sy = (target.y - item.getCenterY()) * 2 / item.naturalHeight();

    var clipId = this.getClipId(target);
    switch (clipId) {
      case 3:
        item.scaleY = sy;
        break;
      case 4:
        item.scaleX = sx;
        item.scaleY = sy;
        break;
      case 5:
        item.scaleX = sx;
        break;
      default:
        assertNotHere(TQ.Dictionary.INVALID_PARAMETER); // 夹点ID不对
    }

    item.jsonObj.scaleX = item.scaleX;
    item.jsonObj.scaleY = item.scaleY;
  };

  function altIsPressed(ev) {
    if (ev.altKey !== undefined) {
      return ev.altKey;
    } else if (ev.gesture && ev.gesture.srcEvent) {
      return ev.gesture.srcEvent.altKey;
    }
    return false;
  }
  TQBase.Trsa = Trsa;
}());

TQ = TQ || {};
(function() {
  var self;

  function Scene() {
    self = this;
    this.levels = [];
    this.outro = null;
    this.topic = TQ.State.topic;
    this.onsceneload = null; // 不能使用系统 的函数名称，比如： onload， 这样会是混淆
    this.version = Scene.VER_LATEST;
    this.setFilenameById(TQ.Config.UNNAMED_SCENE_ID); // filename是文件名， 仅仅只是机器自动生成的唯一编号
    this.setDesignatedSize(Scene.getDesignatedRegionDefault());
    this.isDirty = true;
    this.tMax = 0;
    this.iComponentInfo = null; // 不是iComponents
  }

  var allResourceReady = false;
  var allDataReady = false;
  Scene.EVENT_READY = "sceneReady";
  Scene.EVENT_ALL_RESOURCE_READY = "all resource sceneReady";
  Scene.EVENT_ALL_DATA_READY = "all data sceneReady";
  Scene.EVENT_SAVED = "sceneSaved";
  Scene.EVENT_END_OF_PLAY = "end_of_Play";
  Scene.VER1 = "V1";
  Scene.VER2 = "V2";
  Scene.VER3 = "V3"; // 采用归一化的坐标，记录保存wcy，以适应各种屏幕。
  Scene.VER3_1 = 3.1; // 采用指定分辨率的世界坐标系(以像素为单位)， 替代归一化世界坐标系
  Scene.VER3_3 = 3.3; // designated区域 大于1*1
  Scene.VER3_4 = 3.4; // 背景唯一： 每一个场景中，只能有1个背景，在最底层
  Scene.VER3_5 = 3.5; // 采用lZ压缩
  Scene.VER3_6 = 3.6; // 修改music的跨场景标志为： isCrossLevel
  Scene.VER3_7 = 3.7; // 纠正mirrorX 和Y颠倒的问题
  Scene.VER3_8 = 3.8; // ID 改为Id, 比如： SAG的categoryId
  Scene.VER_LATEST = Scene.VER3_8;
  var stateStack = [];
  var p = Scene.prototype;
  var _levelTs = [];
  var _levelTe = [];

  TQ.EventHandler.initialize(p); // 为它添加事件处理能力
  p.title = null; // title是微创意的标题，
  p.description = null; // 内容描述，摘要， 用于微信分享，FB分享的简介文字
  p.ssPath = null;
  p.isPreloading = false;
  p.currentLevelId = 0;
  p.currentLevel = null;
  p.overlay = null;
  p.stage = null;
  p.isSaved = false; // 用于提醒是否保存修改的内容，在close之前。
  p.hasSavedToCache = false;
  p.state = TQBase.LevelState.NOT_INIT;

  // static APIs:
  Scene.decompress = decompress;
  Scene.updateSSPath = updateSSPath;
  Scene.doReplay = doReplay;
  Scene.ensureFirstClick = ensureFirstClick;
  Scene.removeEmptyLevel = removeEmptyLevel;
  Scene.getEmptySceneJSON = getEmptySceneJSON;
  Scene.localT2Global = localT2Global;
  Scene.globalT2local = globalT2local;
  Scene.getTMax = getTMax;
  Scene.saveState = saveState;
  Scene.restoreState = restoreState;
  Scene.getDefaultTitle = getDefaultTitle;
  Scene.getWcyId = function() {
    return currScene.filename;
  };

  Scene.setWcyId = function(id) {
    currScene.setFilenameById(id);
  };

  Scene.getLocalId = function() {
    TQ.AssertExt.invalidLogic(!!currScene || !!currScene.moment, "在建立scene之后才能调用");

    if (!currScene.moment.localId) {
      currScene.moment.localId = TQ.Utility.createLocalId();
    }

    return currScene.moment.localId;
  };

  Scene.getSsSign = function() {
    return currScene.moment.ssSign;
  };

  Scene.isSameOpus = function(oldLocalId) {
    return Scene.getLocalId() === oldLocalId;
  };

  Scene.parseOpusSaveResult = function(data) {
    if (!currScene) {
      return false;
    }

    if (!!data && !!data.wcyId) {
      if (currScene && !currScene.hasFilename()) {
        currScene.setFilenameById(parseInt(data.wcyId));
      }
    }

    if (data.ssSign) {
      currScene.setSsSign(data.ssSign);
    }

    if (data.ssPath) {
      currScene.setSsPath(data.ssPath);
    }

    if (data.shareCode) {
      TQ.State.shareCode = data.shareCode;
    } else {
      TQ.State.shareCode = null;
    }
  };

  function ensureFirstClick(callback) {
    if (!TQ.State.hideWelcomeAutomatically && TQ.State.needUserClickToPlayAV && TQ.QueryParams && !TQ.QueryParams.hideFirstClickPrompt) {
      if (TQ.State.editorMode >= TQ.SceneEditor.MODE.EDIT_OR_PLAY) {
        if (TQUtility.isIOS()) {
          TQ.SoundMgr.stopAll();
          TQ.VideoMgr.stopAll();
        }
      }
      if (TQUtility.isMiniProgramWebView && TQUtility.isMiniProgramWebView()) {
        if (TQ.userProfile && TQ.userProfile.hasWxUserGranted()) {
          // if (TQ.Utility && TQ.Utility.removeWelcomeTextPage) {
          //   TQ.Utility.removeWelcomeTextPage();
          // }

          // TQ.State.needUserClickToPlayAV = false;
          // if (callback) {
          //   callback();
          // }
          wx.miniProgram.navigateBack({
            delta: 1,
            complete: function() {
              // if (callback) {
              //   callback();
              // }
            }
          });
          // wx.miniProgram.navigateTo({
          //   url: '/pages/index/index', // 大小写敏感
          //   complete: function () {
          //     if (callback) {
          //       callback();
          //     }
          //   }
          //   // success: onSuccess,
          //   // fail: onFail
          // });
        }
      }

      return false;
    }
    return true;
  }

  function saveState() {
    stateStack.push({ tT: Scene.localT2Global(TQ.FrameCounter.t()), levelId: currScene.currentLevelId });
  }

  function restoreState(options) {
    var state;

    do {
      state = stateStack.pop();
    } while (stateStack.length > 0);

    if (state) {
      if (!options || !Object.prototype.hasOwnProperty.call(options, "levelId")) {
        TQ.TimerUI.setGlobalTime(state.tT);
      }
    } else {
      // TQ.Log.error("state is null"); // 首次进入toAddMode，state就是空的
    }
  }

  p.getDesignatedRegion = function() {
    return {
      w: this.getDesignatedWidth(),
      h: this.getDesignatedHeight()
    };
  };

  Scene.getDesignatedRegionDefault = function() {
    var designated;
    if (TQUtility.isMobile()) {
      designated = {
        w: TQ.State.innerWidth,
        h: TQ.State.innerHeight
      };
    } else {
      if (!TQ.State.designatedWidth || !TQ.State.designatedHeight) {
        TQ.State.designatedWidth = TQ.Config.designatedWidth;
        TQ.State.designatedHeight = TQ.Config.designatedHeight;
      }
      designated = {
        w: TQ.State.designatedWidth,
        h: TQ.State.designatedHeight
      };
    }
    return designated;
  };

  // dynamic APIs
  p.shooting = function() {
    this.state = TQBase.LevelState.SHOOTING;
  };

  p.isUpdating = false;
  // 这是scene的主控程序
  var isStarted = false;

  p.start = function() {
    if (!isStarted) {
      isStarted = true;
      self.mainLoop();
    }
  };

  p.mainLoop = function() {
    if (TQ.State.waitForFirstClick) {
      return;
    }
    requestAnimationFrame(function() {
      if (isStarted) {
        self.updateAfterRender();
        self.onTick();
        self.mainLoop();
      }
    });
  };

  p.onTick = function() {
    if (this.state <= TQBase.LevelState.INITING) {
      this.update(0); // 只更新状态,
    }

    if ((this.state < TQBase.LevelState.RUNNING) || // Running 之前, 包括:init, loading等等, 不适合update
      (this.isUpdating) || // 避免重复进入
      (TQ.State.editorMode <= TQ.SceneEditor.MODE.FIRST)) { // UI：在欢迎页面，首页， 不update
      return;
    }

    this.isReadyToShow = true;
    if (this.onReadyToShowCallback) {
      this.onReadyToShowCallback();
      this.onReadyToShowCallback = null;
    }

    this.isUpdating = true;
    TQ.FrameCounter.update(); // 前进一帧, 只有play和播放的时候, 才移动Frame
    // ToDo:@UI  TQ.TimerUI.update();  // 必须先更新数据, 在更新UI
    if (this.isDirty || TQ.FrameCounter.isPlaying()) {
      this.update(TQ.FrameCounter.t());
      if (this.overlay) {
        this.overlay.update(TQ.FrameCounter.t());
      }

      this.render();
      if (this.isDirty) {
        this.isSaved = false;
        this.hasSavedToCache = false;
        this.isDirty = false;
      }
    }

    if (TQ.GifManager.isOpen) {
      TQ.GifManager.addFrame();
    }
    TQ.InputMap.restart(); // 必须是Game Cycle中最后一个, 因为JustPressed依赖于它
    TQ.FrameCounter.isNew = false;
    this.isUpdating = false;
  };

  p.onReadyToShow = function(callback) {
    if (this.isReadyToShow && callback) {
      callback();
    } else {
      this.onReadyToShowCallback = callback;
    }
  };

  p.update = function(t) {
    TQ.SceneEditor.updateMode();
    this.updateReadyFlag();
    this.updateLevelRange();
    // 谁都可以 要求Update， 不只是Player
    if (this.currentLevel != null) {
      this.currentLevel.update(t);
      if (this.version >= Scene.VER2) { // ToDo: 只在录制状态下才更新， 或者，初次运行的时候的时候才更新
        // this.updateTimeTable();
      }
      if (TQ.FrameCounter.finished() && TQ.FrameCounter.isPlaying()) {
        TQ.FrameCounter.update();
        if (this.isLastLevel() || TQ.FrameCounter.abPreviewFinished()) {
          // 声音是否播完
          if (this.hasMusicCompleted() || TQ.FrameCounter.abPreviewFinished()) {
            if (!TQ.FrameCounter.isAutoRewind()) {
              // this.stop();
              TQ.Log.checkPoint("Scene.EVENT_END_OF_PLAY");
              TQ.Base.Utility.triggerEvent(document.body, Scene.EVENT_END_OF_PLAY);
              this.stop();
            } else if (!TQ.FrameCounter.isInverse()) {
              this.doReplay();
            }
          }
        } else {
          this.nextLevel();
        }
      }
    }
  };

  p.updateTimeTable = function() {
    // update 当前level的时间
    if (!TQ.SceneEditor.isEditMode()) { // 录制的时候， 自动延长 本场景的时间长度
      TQ.FrameCounter.setTMax(this.currentLevel.getTime());
    }
    // update 其它level的 相对时间点
    this.updateT0();
  };

  p.updateT0 = function() {
    var t = 0;
    for (var i = 0; i < this.levelNum(); i++) {
      var level = this.getLevel(i);
      level.setT0(t);
      t += level.getTime();
    }
  };

  function doReplay(options) {
    if (!currScene) {
      return;
    }

    TQ.SoundMgr.reset();
    TQ.VideoMgr.reset();
    if (TQ.FrameCounter.isPlaying()) {
      currScene.stop();
    } else {
      saveState();
    }

    if (currScene.currentLevel && currScene.currentLevel.isEditMode()) {
      currScene.currentLevel.calculateLastFrame();
    }

    if (!options) {
      if (currScene.currentLevelId !== 0) {
        TQ.FrameCounter.gotoBeginning();
        currScene.gotoLevel(currScene.currentLevelId);
      } else {
        currScene.currentLevelId = -1;
        currScene.gotoLevel(0);
      }
      TQ.FrameCounter.gotoBeginning();
    } else if (options.thisLevelOnly) {
      TQ.FrameCounter.gotoBeginning();
    } else {
      TQ.FrameCounter.setABOptions(options);
      TQ.FrameCounter.goto(options.tStart);
    }

    currScene.play();
  }

  p.render = function() {
    TQ.Assert.isNotNull(stage);
    stage.update();
  };

  p.showLevel = function() {
    TQ.MessageBox.reset();
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, this.currentLevelId < this.levelNumWithOutro()); // level ID 超界
    if (this.currentLevelId < 0) {
      TQ.AssertExt.isTrue(this.currentLevelId >= 0, "为什么会是负的？");
      this.currentLevelId = 0;
    }
    this.currentLevelId = (this.currentLevelId < this.levelNumWithOutro()) ? this.currentLevelId : 0;
    TQ.Log.checkPoint("entering level " + this.currentLevelId);
    TQ.FrameCounter.gotoBeginning();
    this.selectLevel(this.currentLevelId);
    this.currentLevel.resetTimer();
    this.currentLevel.show();
    this.isDirty = true;
  };

  p.selectLevel = function(id) {
    this.currentLevelId = id;
    this.currentLevel = this.getLevel(this.currentLevelId);
    assertNotNull(TQ.Dictionary.INVALID_LOGIC, this.currentLevel);
    var thisScene = this;
    this.currentLevel.onLevelRunning = function() {
      if ((thisScene.state === TQBase.LevelState.RUNNING) ||
        (thisScene.state === TQBase.LevelState.EDITING)) {
        return;
      }
      thisScene.state = TQBase.LevelState.RUNNING;
      thisScene.handleEvent(Scene.EVENT_READY);
      thisScene.updateLevelRange();
      TQ.Base.Utility.triggerEvent(document.body, Scene.EVENT_READY);
      this.isDirty = true;
    };
    this.currentLevel.onSelected();
  };

  p.joint = function(elements, hasUnJointFlag) {
    if (hasUnJointFlag) {
      this.currentLevel.unJoint(elements);
    } else {
      if (!TQ.InputCtrl.inSubobjectMode) { // 必须在零件模式下, 才能让录制系统更新子物体的坐标为相对坐标.
        TQ.InputCtrl.setSubobjectMode();
      }
      this.currentLevel.joint(elements);
      TQ.InputCtrl.clearSubjectModeAndMultiSelect();
    }

    this.isSaved = false;
  };

  p.groupIt = function(elements, hasUnGroupFlag) {
    if (hasUnGroupFlag) {
      this.currentLevel.unGroup(elements);
    } else {
      this.currentLevel.groupIt(elements);
      TQ.InputCtrl.clearSubjectModeAndMultiSelect();
    }
    this.isSaved = false;
  };

  p.skinning = function(parent, child) {
    this.currentLevel.skinning(parent, child);
    this.isSaved = false;
  };

  // for both image and animation
  p.addItem = function(desc) {
    this.isDirty = true;
    var level = desc.dstLevel;
    delete (desc.dstLevel);
    if ((desc.toOverlay === undefined) || (desc.toOverlay == null)) {
      if (desc.levelId !== undefined) {
        level = this.getLevel(desc.levelId);
      }
    } else {
      assertTrue(TQ.Dictionary.INVALID_PARAMETER + ": " + desc.toOverlay, (desc.toOverlay === 1)); // overlay参数有误
      assertTrue("is empty? ", this.overlay);
      if (this.overlay) {
        level = this.overlay;
      }
    }

    var ele;
    if (TQ.Element.isBackground(desc) && (ele = level.getBackground())) {
      ele.changeSkin(desc.src || desc.data);
    } else {
      ele = TQ.Element.build(level, desc);
      assertTrue(TQ.INVALID_LOGIC, ele.level === level);
      ele.level = level;
      if (level.isActive()) {
        var thisScene = this;
        TQ.CommandMgr.directDo(new TQ.GenCommand(TQ.GenCommand.ADD_ITEM,
          thisScene, ele, ele));
      } else { // level都退出了Stage了，undo stack肯定也reset了，所有不能在加了
        this.addElementDirect(ele);
      }
    }
    return ele;
  };

  p.undeleteElement = function(ele) {
    TQ.GarbageCollector.remove(ele);
    ele.level = this.currentLevel;
    this.addElementDirect(ele);
  };

  p.addElementDirect = function(ele) {
    var level = ele.level;
    this.isDirty = true;
    level.addElementDirect(ele);
    if (ele.hasFlag(TQ.Element.LOADED) && !ele.hasFlag(TQ.Element.IN_STAGE)) {
      ele.addItemToStage();
    }
  };

  p.addText = function(desc) {
    this.isDirty = true;
    return this.currentLevel.addElement(desc);
  };

  p.deleteElement = function(ele) {
    this.isDirty = true;
    assertNotNull(TQ.Dictionary.PleaseSelectOne, ele);
    if (ele != null) {
      this.currentLevel.deleteElement(ele);
      if (ele.isSound()) {
        TQ.SoundMgr.deleteItem(ele);
      } else if (ele.isVideo()) {
        TQ.VideoMgr.deleteItem(ele);
      }
    }
  };

  p.preLevel = function() {
    if (this.currentLevelId > 0) {
      this.gotoLevel(this.currentLevelId - 1);
    }
  };

  p.nextLevel = function() {
    if (!this.isLastLevel()) {
      this.gotoLevel(this.currentLevelId + 1);
    }
  };

  p.isEmpty = function() {
    for (var i = 0; i < this.levelNum(); i++) {
      if (!this.getLevel(i).isEmpty()) {
        return false;
      }
    }

    return true;
  };

  p.isCurrentLevelEmpty = function() {
    return ((this.levelNum() === 0) ||
      !this.currentLevel ||
      this.currentLevel.isEmpty());
  };

  p.isAllResourceReady = function() {
    return allResourceReady;
  };

  p.isAllDataReady = function() {
    return allDataReady;
  };

  p.isLastLevel = function() {
    return ((this.currentLevelId + 1) >= this.levelNumWithOutro());
  };

  p.isIComponent = function() {
    return (this.iComponentInfo && !!this.iComponentInfo.Type);
  };

  p.iComponentHasThumbnail = function() {
    return (this.iComponentInfo && !!this.iComponentInfo.thumbPath);
  };

  p.isValidIComponent = function() {
    return (this.levelNum() === 1 && this.levels[0].itemNum() === 1);
  };

  p.setAsIComponent = function(type) {
    TQ.FrameCounter.goto(0);
    this.forceToComponent();
    if (!this.iComponentInfo) {
      this.iComponentInfo = {};
    }
    this.iComponentInfo.type = type;
    this.iComponentInfo.thumbPath = this.ssPath;
  };

  p.forceToComponent = function() {
    // 元件： 必须是以group元素为唯一root， （关节元素属于Element类， 不是group)
    if (this.levelNum() >= 1) {
      var level1 = this.levels[0];
      if ((level1.itemNum() > 1) ||
        ((level1.itemNum() === 1) && !(level1.elements[0] instanceof TQ.GroupElement))) {
        var elements = [];
        for (var i = 0; i < level1.itemNum(); i++) {
          elements.push(level1.elements[i]);
        }
        this.groupIt(elements, false);
      }
    }
  };

  p.hasMusicCompleted = function() {
    return (this.tMax < this.toGlobalTime(TQ.FrameCounter.t()));
  };

  p.hasAnimation = function() {
    return ((this.levelNum() === 1) && this.getLevel(0).hasAnimation());
  };

  p.gotoLevel = function(id) {
    this.isDirty = true;
    id = (id >= this.levelNumWithOutro()) ? (this.levelNumWithOutro() - 1) : id;
    id = (id < 0) ? 0 : id;
    if (this.currentLevel != null) {
      var level = self.getLevel(id);
      if (level.resourceReady) {
        self.doTransition(id);
      } else {
        level.onResourceReady = function() {
          setTimeout(function() { // 避免直接调用
            self.doTransition(id);
          });
        };
      }
    }
  };

  p.doTransition = function(id) {
    TQ.FloatToolbar.close();
    if (this.currentLevelId !== id) {
      if (TQ.State.allowPageTransition && TQ.PageTransition && (this.currentLevelId >= 0)) {
        TQ.PageTransition.start(self.currentLevelId, id, function() {
          self.doGotoLevel(id);
        });
      } else {
        self.doGotoLevel(id);
      }
    } else {
      TQ.Log.debugInfo("已经在本level，不变切换");
    }
  };

  p.doGotoLevel = function(id) {
    this.currentLevel.exit();
    this.currentLevelId = id;
    this.showLevel();
  };

  p.open = function(fileInfo) {
    p.isPlayOnly = (fileInfo.isPlayOnly === undefined) ? false : fileInfo.isPlayOnly;
    // TQ.MessageBox.showWaiting(TQ.Locale.getStr('prepare to open...'));
    this.reset();
    this.setFilenameById(fileInfo.filename);
    this.screenshotName = fileInfo.screenshotName;
    this.title = null;

    // 删除 旧的Levels。
    function onOpened() {
      TQ.Log.checkPoint("scene opened, 1st level: " + self.currentLevelId);
      self.showLevel();
      TQ.MessageBox.reset();
      setTimeout(function() {
        self.start();
      });
    }

    this.onsceneload = onOpened;

    if (!fileInfo.content &&
      (fileInfo.name === TQ.Config.UNNAMED_SCENE_ID)) {
      fileInfo.content = Scene.getEmptySceneJSON();
    }

    if (!fileInfo.content) {
      this.loadFromJson(fileInfo.name, "gameScenes");
    } else {
      this._jsonStrToScene(this, fileInfo.content, "gameScene");
    }
    if (this.overlay == null) {
      this.overlay = new TQ.Overlay({});
    }
    this.isDirty = true;
  };

  p.reset = function() { // 在打开文件，或者创建新文件的时候， 重新设置环境
    //   $('#stop').trigger('click');
    this.setEditor();
    this.setDefaultValue();
    _levelTe.splice(0);
    _levelTs.splice(0);
    this.setDesignatedSize(Scene.getDesignatedRegionDefault());
    // ToDo:@UI   initMenu(); // 重新设置菜单

    // close current if  has one;
    if (!((this.currentLevel === undefined) || (this.currentLevel == null))) {
      this.stop();
      this.close();
    }

    if (TQ.SceneEditor.isEditMode()) {
      TQ.FrameCounter.gotoBeginning();
      if (TQ.FrameCounter.isAutoRewind()) {
        $("#rewind").click();
      }
      if (TQ.TrackRecorder.style === TQ.Channel.JUMP_INTERPOLATION) {
        $("#linearMode").click();
      }
    }
  };

  p.setDefaultValue = function() {
    allResourceReady = false;
    allDataReady = false;
    TQ.QueryParams.shareCode = "";
    this.tMax = 0;
    this.isSaved = true; // 只是打开旧的文件， 没有尚未修改
    this.isShared = false; // 只是打开旧的文件， 没有尚未修改
    this.title = TQ.Config.UNNAMED_SCENE; // 必须reset, 因为currScene在New新作品的时候， reuse了
    this.setFilenameById(TQ.Config.UNNAMED_SCENE_ID);
    this.description = null;
    this.ssPath = null; // 初始化， 没有此值
    this.resetMoment();
    this.hasScreenShotManual = false;
    this.isDirty = true;
    this.hasSavedToCache = false;
    this.outroInitialized = false;
    this.outro = null;
    this.topic = (TQ.State && TQ.State.topic) ? TQ.State.topic : null;
    this.topicId = TQ.Utility.getTopicId();
    this.state = TQBase.LevelState.INITING;
    this.backgroundColor = TQ.Config.BACKGROUND_COLOR;
  };

  p.resetMoment = function() {
    // moment 存储短暂的数据，
    // 1) 不需要永久保存到opus文件中， ==> 例如：localId，ssSign, 但是ssPath不行
    // 2) 建立新文件的时候，要reset
    this.moment = {
      ssSign: null,
      localId: TQ.Utility.createLocalId()
    };
  };

  p.setDesignatedSize = function(region) {
    this.designatedWidth = region.w;
    this.designatedHeight = region.h;
    TQ.Config.snapDX = this.designatedWidth / 20;
    TQ.Config.snapDY = this.designatedHeight / 20;
    TQ.Config.FONT_LEVEL_UNIT = Math.min(this.designatedWidth, this.designatedHeight) / 30;
  };

  p.getDesignatedWidth = function() {
    return this.designatedWidth;
  };

  p.getDesignatedHeight = function() {
    return this.designatedHeight;
  };

  p.getLevel = function(id) {
    if (id < this.levelNum()) {
      return this.levels[id];
    } else {
      id = id - this.levelNum();
      if (id < this.outroLevelNum()) {
        return this.outro[id];
      }
    }
    return null;
  };

  p.getElement = function(id) {
    assertValid("this.currentLevel", this.currentLevel);
    return this.currentLevel.getElement(id);
  };
  p.getElements = function() {
    assertValid("this.currentLevel", this.currentLevel);
    return this.currentLevel.getElements();
  };

  p.getAllSounds = function() { // 只返回当前场景的声音， 不能跨场景操作其它场景里面的声音
    if (this.currentLevel) {
      var result = this.currentLevel.getSounds();
    } else {
      result = [];
    }
    return result;
  };

  p.findAtom = function(displayObj) {
    assertValid("this.currentLevel", this.currentLevel);
    return this.currentLevel.findAtom(displayObj);
  };

  p.getSelectedElement = function() {
    assertTrue(TQ.Dictionary.isDepreciated, false);
  };

  p.levelNum = function() {
    return this.levels.length;
  };

  p.levelNumWithOutro = function() {
    return this.levelNum() + this.outroLevelNum();
  };

  p.outroLevelNum = function() {
    return (!this.outro) ? 0 : this.outro.length;
  };

  /*
	 插入第id(id >=0）个场景， 如果该位置已经有场景， 把原来的场景向后顺延。
	 如果id超出下边界（id < 0), 则等价于id =0;.
	 如果id 超出上边界， 则自动在末尾添加一个场景
	 如果id没有定义，则自动在末尾添加一个场景
	 返回值是最大level编号
	 */
  p.addLevel = function(id, levelContent) {
    var levelNum = this.levelNum();
    if (id === undefined) {
      id = levelNum;
    }
    id = TQ.MathExt.range(id, 0, levelNum);
    this.isDirty = true;
    if (!levelContent) {
      var levelName = levelNum; // levelNum只是一个流水号， 暂时没有其它用途
      levelContent = new TQ.Level({ name: levelName });
      levelContent.onLoaded(); // 新建立的，没有任何元素， 所以,直接调用onLoaded, 以设置dataReady等标志
    }
    this.levels.splice(id, 0, levelContent);
    return this.levelNum() - 1;
  };

  /*
	 删除第id(id >=0）个场景， 并且把此后的场景前移。
	 如果id超出边界（id < 0)，则忽略
	 */
  p.deleteLevel = function(id) {
    return this.cutLevel(id);
  };

  p.cutLevel = function(id) {
    if ((id < 0) || (id >= this.levelNum())) {
      assertTrue(TQ.Dictionary.INVALID_PARAMETER, false);
      return;
    }
    this.isDirty = true;
    var deleted = this.levels.splice(id, 1);

    if (this.currentLevelId > id) {
      this.currentLevelId--;
    }
    return deleted;
  };

  /*
	 移动序号为srcId的场景，并插入到序号dstId的场景之前，
	 注意：srcId和dstId都是在执行此函数之前， 按照场景的顺序来编号的。
	 用户不需要关心
	 */
  p.moveTo = function(srcId, dstId) {
    var content = this.cutLevel(srcId);
    if (srcId < dstId) {
      dstId--;
    }
    this.addLevel(dstId, content);
  };

  /*
	 复制序号为srcId的场景的内容，并插入到序号dstId的场景之前，
	 */
  p.copyTo = function(srcId, dstId) {
    var srcLevel = this.getLevel(srcId);
    var jsonData;
    var newLevel;
    srcLevel.prepareForJSONOut();
    jsonData = JSON.stringify(srcLevel);
    srcLevel.afterToJSON();
    newLevel = new TQ.Level(JSON.parse(jsonData));
    return this.addLevel(dstId, newLevel);
  };

  p.duplicateCurrentLevel = function() {
    // 新增的level, 紧随currentLevel之后，id+1， 并且，设置为新的currentLevel
    var newLevelId = this.currentLevelId + 1;
    var newLevel;
    this.copyTo(this.currentLevelId, newLevelId);
    TQ.RM.onCompleteOnce(function() {
      newLevel.onLoaded();
    });
    newLevel = this.getLevel(newLevelId);
    this.startPreloader(newLevel);
  };

  // !!! can not recover, be careful!
  // empty the current scene
  p.empty = function() {
    var level;
    if (!this.isEmpty()) {
      this.stop();
      this.close(true); // discard
      while (this.levelNum() > 1) {
        var levelId = this.levelNum() - 1;
        this.deleteLevel(levelId);
      }

      level = this.getLevel(0);
      if (level) {
        level.empty();
      }
      this.selectLevel(0);
      this.currentLevel.state = TQBase.LevelState.INITING;
      this.currentLevel.resetTimer();
      this.currentLevel.show();
    } else {
      this.currentLevel.empty();// 主要是设置各种flag
    }

    this.setDefaultValue();
  };

  // JQuery Ajax version
  p.loadFromJson = function(filename, alias) {
    // TQ.MessageBox.showWaiting(TQ.Locale.getStr('is loading...'));
    (function(pt) {
      netOpen(filename, function(jqResponse) {
        pt._jsonStrToScene(pt, jqResponse, alias);
      });
    })(this);
  };

  p._jsonStrToScene = function(pt, jsonStr, alias) {
    // /任何修改，必须确保5种打开方式都OK:
    // ** url
    // ** latest opus
    // ** my opus pane
    // ** topic
    // ** new

    try {
      jsonStr = TQ.Element.upgrade(jsonStr);
      var objJson = JSON.parse(jsonStr);
    } catch (e) {
      displayInfo2(jsonStr);
      TQ.Log.error(jsonStr + ". " + e.toString());
      // 给一个空白文件， 确保可可持续进行
      objJson = getEmptySceneJSON();
    }
    objJson.alias = (alias == null) ? "none" : alias;
    if (!objJson.filename || objJson.filename === TQ.Config.UNNAMED_SCENE_ID) {
      objJson.filename = TQ.Config.UNNAMED_SCENE_ID;
      if (TQ.State.shareCode) {
        var idFromSC = TQ.Utility.shareCode2Id(TQ.State.shareCode);
        if (idFromSC && idFromSC !== TQ.Config.UNNAMED_SCENE_ID) {
          idFromSC = parseInt(idFromSC);
          if (idFromSC > 0) {
            objJson.filename = idFromSC;
          }
        }
      }
    }
    objJson.remote = true;
    if (p.isPlayOnly) { // 播放， 总是从第1场景的第t0=0时刻开始
      objJson.currentLevelId = 0;
      objJson.levels[0].t0 = 0.0;
    }

    pt._fixedUp(objJson);
  };

  function removeEmptyLevel(jsonObj) {
    for (var i = jsonObj.levels.length - 1; i >= 0; i--) {
      var desc = jsonObj.levels[i];
      if ((desc.elements == null) || (desc.elements.length <= 0)) {
        if ((i !== 0) || (jsonObj.levels.length > 1)) { // 至少保留一个level, 不论空白与否。
          this.isDirty = true;
          jsonObj.levels.splice(i, 1);
        }
      }
    }
    this.isDirty = true;
  }

  p._fixedUp = function(objJson) {
    if (TQ.Config.REMOVE_EMPTY_LEVEL_ON) {
      Scene.removeEmptyLevel(objJson);
    }
    // 删除临时办理，（升级用，防止，旧文件中带有这些参数）
    delete (objJson.isPlayOnly);

    if (objJson.currentLevelId >= objJson.levels.length) {
      objJson.currentLevelId = 0;
    }

    // copy non-object properties
    TQUtility.extendWithoutObject(this, objJson);
    this.topic = objJson.topic;
    objJson.topic = null;
    this.state = TQBase.LevelState.NOT_INIT;
    if (!objJson.version) {
      this.version = Scene.VER1; // 升级旧版的作品， 添加其版本号
    }

    if (objJson.version !== Scene.VER_LATEST) {
      TQ.Scene.upgradeToLatest(objJson);
      this.version = objJson.version;
    }

    var designated;
    if (!objJson.designatedWidth || !objJson.designatedHeight) {
      designated = Scene.getDesignatedRegionDefault();
    } else {
      designated = {
        w: objJson.designatedWidth,
        h: objJson.designatedHeight
      };
    }

    this.setDesignatedSize(designated);
    // initialize with defaults
    objJson.currentLevelId = (objJson.currentLevelId === undefined) ? 0 : objJson.currentLevelId;
    this.currentLevelId = objJson.currentLevelId;
    this.currentLevelId = 0; // ToDo: 迫使系统总是打开第一个场景
    this.title = (!objJson.title) ? null : objJson.title;
    this.topicId = objJson.topicId || 0;
    this.tMax = (objJson.tMax === undefined) ? this.tMax : objJson.tMax;

    if (this.title == null) {
      this.title = this.filename;
    }

    this.fixedUpLevels(this.levels, objJson);
    this.preload();
  };

  p.fixedUpLevels = function(levels, objJson) {
    // create levels
    var desc = null;
    var num = (!objJson || !objJson.levels) ? 0 : objJson.levels.length;
    for (var i = 0; i < num; i++) {
      desc = objJson.levels[i];
      if (desc.name == null) {
        desc.name = "level-" + i.toString();
      }
      levels[i] = new TQ.Level(desc);
    }

    if (num === 0 && this.levelNum() === 0) { // 纠错
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      desc = null;
      levels[0] = new TQ.Level(desc);
    }
  };

  p.preload = function() {
    // start preloader
    var self = this;
    var num = self.levelNumWithOutro();
    var levelToPreload = 0;

    // 设置each Level的resourceReady标志, and start show
    loadOneLevel(null, levelToPreload);

    function loadOneLevel(level, levelToPreload) {
      if (levelToPreload === 0) {
        if ((self.onsceneload !== undefined) && (self.onsceneload != null)) {
          self.onsceneload();
        }
      }

      if (level) {
        level.resourceReady = true;
        level.updateState();
        if (level.onResourceReady) {
          level.onResourceReady();
        }
        TQ.Log.checkPoint("level asset loaded: " + level.name);
        self.isDirty = true;
      }

      var nextLevel;
      for (; levelToPreload < (num + 1); levelToPreload++) {
        nextLevel = (levelToPreload === num) ? self.overlay : self.getLevel(levelToPreload);
        if (!nextLevel.resourceReady) {
          TQ.RM.onCompleteOnce(function() {
            loadOneLevel(nextLevel, levelToPreload + 1);
          });
          self.startPreloader(nextLevel);
          break;
        }
      }
    }

    TQ.Log.debugInfo(TQ.Locale.getStr("loading resource of ") + " <" + this.title + ">.");
  };

  p.setEditor = function() {
    if (TQ.SceneEditor.isEditMode()) {
      // $('#playRecord').click();
    } else if (TQ.SceneEditor.isPlayMode()) {
      if (p.isPlayOnly) {
        // TQ.WCY.doStopRecord();
      } else {
        // $('#stopRecord').click();
      }
    } else {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
    }
    this.isDirty = true;
  };

  p.setSsPath = function(ssPath) {
    ssPath = TQ.RM.toRelative(ssPath);
    if ((!this.ssPath) || (this.ssPath !== ssPath)) {
      this.ssPath = ssPath;
      this.isDirty = true;
      this.isSaved = false;
    }
  };

  p.setSsSign = function(ssSign) {
    if ((!this.moment.ssSign) || (this.moment.ssSign !== ssSign)) {
      this.moment.ssSign = ssSign;
      this.isDirty = true;
      this.isSaved = false;
    }
  };

  p.startPreloader = function(level) {
    if (level) {
      level.setupPreloader();
    }
    if (TQ.RM.isEmpty || TQ.RM.dataReady) {
      TQ.RM.onCompleted();
    }
  };

  p.afterToJSON = function() {
    for (var i = 0; i < this.levelNum(); i++) {
      this.getLevel(i).afterToJSON();
    }
  };

  p.toJSON = function() {
    var scene2 = TQ.Base.Utility.shadowCopy(this);
    // 必须忽略这些临时的变量，否则， 在open的时候，他们就会覆盖currScene中的值
    delete (scene2.currentLevel);
    delete (scene2.isUpdating);
    delete (scene2.isSaved);
    delete (scene2.onsceneload);
    delete (scene2.isPlayOnly);
    delete (scene2.state);
    if (scene2.outro !== undefined) {
      delete (scene2.outro);
    }
    if (scene2.outroInitialized !== undefined) { // 不需要保存的临时状态， 放在一个变量里面
      delete (scene2.outroInitialized);
    }
    return scene2;
  };

  p.getData = function() {
    TQ.AssertExt.invalidLogic(allDataReady, "有level没有完全加载和build，不能调用");
    for (var i = 0; i < this.levelNum(); i++) {
      this.getLevel(i).prepareForJSONOut();
    }
    this.updateShareData();
    var data = JSON.stringify(this);
    this.afterToJSON();

    if (data.length > TQ.Config.MAX_FILE_SIZE) {
      TQ.MessageBox.toast(TQ.Locale.getStr("file is too long, please save your work ASAP"));
    }

    return compress(data, this.ssPath, this.title);
  };

  p.attachOutro = function(outroJson) {
    this.outroInitialized = true;
    var tempOutro = [];
    this.fixedUpLevels(tempOutro, outroJson);
    if (tempOutro.length > 0) {
      this.outro = tempOutro;
      this.preload();
    }
  };

  p.getOutroId = function() {
    if (this.topic && this.topic.outroId !== undefined && this.topic.outroId !== 0) {
      return this.topic.outroId;
    }
    return null;
  };

  p.updateShareData = function() {
    var level1 = (this.levelNum() > 0) ? this.getLevel(0) : null;
    if (level1) {
      this.title = this.title || level1.getText(0);
      this.description = this.description || level1.getText(1);
      if (!this.description) {
        this.description = this.title;
      }
    }
  };

  // / close current scene
  p.close = function(discard) {
    if (this.isSaved || this.isEmpty() || !!discard) {
      if (this.currentLevel != null) {
        TQ.RM.reset(); // 必须先停止RM，否则其中的callback如果引用了Level对象就会出错
        TQ.SoundMgr.reset();
        TQ.VideoMgr.reset();
        // TQ.TextEditor.onNo();
        this.currentLevel.exit();
        this.currentLevel = null;
      }
      this.levels.splice(1, this.levelNum() - 1); // 释放原来的数据
      this.currentLevel = this.getLevel(0);
      this.currentLevelId = 0;
      this.currentLevel.empty();
      this.onsceneload = null;
      isStarted = false;
      return true;
    }

    TQ.Log.warn("请先保存作品！");
    return false;
  };

  p.toGlobalTime = function(t) {
    if (!this.currentLevel) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return t;
    }
    return (t + this.currentLevel.getT0());
  };

  p.stop = function() {
    if (this.currentLevel) {
      this.currentLevel.stop();
    }
    TQ.FrameCounter.stop();
    TQ.SoundMgr.pause();
    TQ.VideoMgr.pause();
    TQ.ParticleMgr.pause();
  };

  p.play = function() {
    TQ.FloatToolbar.close();
    TQ.FrameCounter.play();
    TQ.SoundMgr.resume();
    TQ.VideoMgr.resume();
    if (this.currentLevel) {
      this.currentLevel.play();
    }
  };

  function getEmptySceneJSON() {
    // this equals to the WCY01.WDM
    // it is provided to prevent loading WCY01.WDM from server
    var empty = {
      filename: TQ.Config.UNNAMED_SCENE_ID,
      version: Scene.VER_LATEST,
      topicId: TQ.Utility.getTopicId(),
      topic: TQ.State.topic, // 包括topicId, outroId
      title: getDefaultTitle(),
      "levels": [
        {
          "jsonElements": null,
          "FPS": 20,
          "_t": 0,
          "elements": null,
          "name": "0",
          "itemCounter": 8,
          "dataReady": true,
          "state": TQBase.LevelState.NOT_INIT,
          "isWaitingForShow": false,
          "isDirty": true,
          "dirty": true
        }
      ],
      "overlay": null,
      "currentLevelId": 0,
      "currentLevel": null,
      "state": TQBase.LevelState.NOT_INIT,
      "isUpdating": false
    };

    return JSON.stringify(empty);
  }

  p.updateLevelRange = function() {
    var ts = 0;
    var te = 0;
    var tGlobalLastFrame = 0;
    var numOfLevel = (TQ.FrameCounter.isPlaying() ? this.levelNumWithOutro() : this.levelNum());
    var level = null;

    if (TQ.FrameCounter.isRecording()) {
      if (this.currentLevel && (this.currentLevel.getTime() < TQ.FrameCounter.maxTime())) {
        this.currentLevel.setTime(TQ.FrameCounter.maxTime());
      }
    }

    if (_levelTe.length > numOfLevel) {
      _levelTe.splice(numOfLevel);
      _levelTs.splice(numOfLevel);
    }

    for (let i = 0; i < numOfLevel; i++) {
      level = this.getLevel(i);
      if (!level.resourceReady || !level.dataReady) {
        continue;
      }

      if (level.tMaxFrame === undefined) {
        TQ.AssertExt.invalidLogic(false, "new use case?");
        continue;
      }

      ts = te;
      te = ts + level.getTime();

      if (i < _levelTs.length) {
        _levelTs[i] = ts;
        _levelTe[i] = te;
      } else {
        _levelTs.push(ts);
        _levelTe.push(te);
      }

      tGlobalLastFrame = Math.max(tGlobalLastFrame, level.getGlobalTime());
    }

    te = Math.max(te, tGlobalLastFrame);
    if (Math.abs(this.tMax - te) > 0.1) {
      this.tMax = (allResourceReady) ? te : Math.max(this.tMax, te);
      this.updateT0();
      TQ.FrameCounter.setTMax(this.tMax);
      TQUtility.triggerEvent(document, TQ.EVENT.SCENE_TIME_RANGE_CHANGED);
    }
  };

  p.updateReadyFlag = function() {
    if (allDataReady && allResourceReady) {
      return;
    }

    var level;
    var _allResourceReady = true;
    var _allDataReady = true;
    for (var i = 0; i < this.levelNum(); i++) {
      level = this.getLevel(i);
      if (!level.resourceReady) {
        _allResourceReady = false;
        _allDataReady = false;
        break;
      }

      if (!level.dataReady) {
        _allDataReady = false;
      }
    }

    if (_allResourceReady && !allResourceReady) {
      allResourceReady = _allResourceReady;
      TQ.Base.Utility.triggerEvent(document, Scene.EVENT_ALL_RESOURCE_READY);
    }
    if (_allDataReady && !allDataReady) {
      allDataReady = _allDataReady;
      TQ.Base.Utility.triggerEvent(document, Scene.EVENT_ALL_DATA_READY);
    }
  };

  p.updateAfterRender = function() {
    if (this.currentLevel) {
      this.currentLevel.updateRenderFlag();
    }
  };

  p.setFilenameById = function(wcyId) {
    this.filename = wcyId;
    return this.filename;
  };

  p.hasFilename = function() {
    TQ.AssertExt.invalidLogic(this.filename !== TQ.Config.UNNAMED_SCENE, "filename 已经全部用纯数字的wcyId了");
    return (this.filename && (this.filename !== TQ.Config.UNNAMED_SCENE_ID));
  };

  function localT2Global(t) {
    if (!_levelTs) {
      TQ.Log.debugWarn(t);
      return (t = 0);
    }

    if (_levelTs.length <= currScene.currentLevelId) {
      if (_levelTs.length > 0) {
        return _levelTs[_levelTs.length - 1];
      } else {
        if (t > 0) {
          TQ.Log.debugWarn("not initialized" + t);
        }
        return t;
      }
    }

    return (t + _levelTs[currScene.currentLevelId]);
  }

  function findLevel(t) {
    if (t < _levelTs[0]) {
      return 0;
    }

    if (t > _levelTe[_levelTe.length - 1]) {
      return _levelTe.length - 1;
    }

    var i = 0;
    for (; i < _levelTe.length; i++) {
      if ((t >= _levelTs[i]) && (t <= _levelTe[i])) {
        return i;
      }
    }

    TQ.AssertExt.invalidLogic(i < _levelTe.length);
    return 0;
  }

  function globalT2local(t, skipLevelChange) {
    var id = currScene.currentLevelId;
    if ((t < _levelTs[id]) || (t > _levelTe[id])) {
      id = findLevel(t);
      if (!skipLevelChange && (id !== currScene.currentLevelId)) {
        currScene.gotoLevel(id);
      }
    }

    return { levelId: id, t: t - _levelTs[id], gt: t };
  }

  function getTMax() {
    return (!currScene) ? 0 : currScene.tMax;
  }

  function compress(wcyData, ssPath, title) {
    if (TQ.Config.useLZCompress) {
      var compressed = LZString.compressToBase64(wcyData);
      return JSON.stringify({
        zip64: true, len: compressed.length,
        ssPath: ssPath, title: title, data: compressed
      });
    }
    return wcyData;
  }

  function decompress(pkgJson) {
    var decompressed = pkgJson;

    if (!!pkgJson && (typeof pkgJson === "string")) {
      var obj = JSON.parse(pkgJson);
      if (obj.zip64 || obj.zip) {
        if (obj.zip) {
          decompressed = LZString.decompressFromUTF16(obj.data);
        } else {
          decompressed = LZString.decompressFromBase64(obj.data);
        }

        if (!decompressed || decompressed.length < obj.length) {
          TQ.AssertExt.invalidLogic(false, "解压后的长度小于压缩者，是不是结束符0出现了？");
          decompressed = pkgJson;
        }
      }
    }

    return decompressed;
  }

  function updateSSPath(pkg, newPath) {
    var opusObj = JSON.parse(pkg.opusJson);
    var opusDataObj = JSON.parse(decompress(pkg.opusJson));
    var title = opusDataObj.title;

    opusDataObj.ssPath = opusObj.ssPath = newPath;
    pkg.opusJson = compress(JSON.stringify(opusDataObj), newPath, title);
  }

  // private
  function getDefaultTitle() {
    return (TQ.State && TQ.State.topic && TQ.State.topic.title)
      ? TQ.State.topic.title : TQ.Config.UNNAMED_SCENE;
  }

  TQ.Scene = Scene;
}());

/**
 * Created by Andrewz on 2/20/2017.
 */

(function() {
  TQ.Scene.upgradeToLatest = function(objJson) {
    TQ.Log.debugInfo("upgrade: old version: " + (!objJson.version ? "No" : objJson.version));
    if (!objJson.version || isV_Format(objJson.version)) { // no version, V1, V2, V3
      switch (objJson.version) {
        case TQ.Scene.VER3:
          upgrade3ToVer31(objJson);
          break;
        case TQ.Scene.VER2:
          upgrade2ToVer31(objJson);
          break;
        case TQ.Scene.VER1:
          upgrade3ToVer31(objJson);
          break;
        default:
          console.error("not supported version: =" + objJson.version);
          return;
      }
    }
    if (objJson.version < TQ.Scene.VER_LATEST) {
      // V3_1+
      if (objJson.version < TQ.Scene.VER3_3) {
        upgrade3_1ToVer3_3(objJson);
      }

      if (objJson.version < TQ.Scene.VER3_4) {
        upgrade3_3ToVer3_4(objJson);
      }

      if (objJson.version < TQ.Scene.VER3_6) {
        upgrade3_4ToVer3_6(objJson);
      }
      if (objJson.version < TQ.Scene.VER3_7) {
        upgrade3_6ToVer3_7(objJson);
      }
      if (objJson.version < TQ.Scene.VER3_8) {
        upgrade3_7ToVer3_8(objJson);
      }
    }

    // now it's latest
    TQ.Log.debugInfo(" upgrade result: version = " + objJson.version + ", designed region(W,H)： W = " +
            objJson.designatedWidth + ", H=" + objJson.designatedHeight + ")");
  };

  function upgrade3_7ToVer3_8(objJson) {
    var num = objJson.levels.length;
    for (var i = 0; i < num; i++) {
      TQ.Level.upgradeEachElement(objJson.levels[i], function(eleDesc) {
        if (eleDesc.animeTrack) {
          TQ.AnimeTrack.upgradeTo3_8(eleDesc.animeTrack);
        }
      });
    }

    objJson.version = TQ.Scene.VER3_8;
    return objJson;
  }

  function upgrade3_6ToVer3_7(objJson) {
    var num = objJson.levels.length;
    for (var i = 0; i < num; i++) {
      TQ.Level.upgradeEachElement(objJson.levels[i], function(eleDesc) {
        var temp = eleDesc.mirrorX;
        eleDesc.mirrorX = eleDesc.mirrorY;
        eleDesc.mirrorY = temp;
      });
    }

    objJson.version = TQ.Scene.VER3_7;
    return objJson;
  }

  function upgrade3_4ToVer3_6(objJson) {
    var num = objJson.levels.length;
    for (var i = 0; i < num; i++) {
      TQ.Level.upgrade3_3ToVer3_4(objJson.levels[i]);
    }

    objJson.version = TQ.Scene.VER3_6;
    return objJson;
  }

  function upgrade3_3ToVer3_4(objJson) {
    var num = objJson.levels.length;
    for (var i = 0; i < num; i++) {
      TQ.Level.upgrade3_3ToVer3_4(objJson.levels[i]);
    }

    objJson.version = TQ.Scene.VER3_4;
    return objJson;
  }

  function upgrade3_1ToVer3_3(objJson) {
    if (!objJson.designatedWidth) { // 是PC做的， 只在 本地debug版
      objJson.designatedWidth = 1094;
      objJson.designatedHeight = 498;
    } else if (objJson.designatedWidth < 2) { // 归一化的， 无法转

    } // 剩余的是： 3.1, 有合理的W，H， 不需要变换
    objJson.version = TQ.Scene.VER3_3;
    return objJson;
  }

  function upgrade3ToVer31(objJson) {
    objJson.version = TQ.Scene.VER3_1;
    objJson.designatedWidth = 1;
    objJson.designatedHeight = 1;
    return objJson;
  }

  function upgrade2ToVer31(objJson) {
    objJson.version = TQ.Scene.VER3_1;
    objJson.designatedWidth = 1094;
    objJson.designatedHeight = 498;
    return objJson;
  }

  function isV_Format(version) { // "V1", --"V3"
    return isNaN(version);
  }
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

(function() {
  var DEFAULT_T_MAX_FRAME = 3; // seconds
  function Level(description) {
    TQ.AssertExt.isTrue(!description || (typeof description === "object"), "必须是object, 不能是json字串");
    this.background = null;
    this.latestElement = null; // 最新生成的复合物体
    this.tMaxFrame = 0; // 用户指定的时长， 缺省是0
    this.tMaxFrameMixed = DEFAULT_T_MAX_FRAME;
    this.tGlobalLastFrame = 0; // 他对作品最大时长的最低要求
    this.t0 = 0;
    this.updateCompletedHandlers = [];
    this.initialize(description);
  }

  Level.EVENT_START_SHOWING = "level start showing";

  Level.isCurrent = function(id) {
    return (currScene && (currScene.currentLevelId === id));
  };

  var p = Level.prototype;
  p.isDirty = false; //  变量赋值应该放在最前面, 确保在使用之前已经赋值. 小函数放在最后, 很少看.
  p.isPreloading = false;

  p.requestToUpdateAll = function() {
    this.isDirty = true;
    this.elements.forEach(function(ele) {
      ele.isDirty = true;
    });
  };

  p.initialize = function(description) {
    // initialize with defaults
    // 防止没有数据
    description = (!description) ? {} : description;
    description.elements = (!description.elements) ? [] : description.elements;
    this.elements = description.elements;
    TQ.AssertExt.isNotNull(this.elements);
    this.FPS = (!description.FPS) ? TQ.FrameCounter.defaultFPS : description.FPS;
    this.tMaxFrame = (!description.tMaxFrame) ? this.tMaxFrame : description.tMaxFrame;
    this._t = 0; // _t是临时变量， 每次播放都不同，没必要fixedUp 起止
    assertNotNull(TQ.Dictionary.FoundNull, description.name);
    this.name = description.name;
    this.itemCounter = 0;
    this.resourceReady = false; // img资源加载成功，尚未加入stage canvas
    this.dataReady = false; // 加入到stage canvas了，
    this.state = TQBase.LevelState.NOT_INIT;
    this.isWaitingForShow = false;
    this.isDirtyZ = false;
    this.isDirty = true;
  };

  p.onSelected = function() {
    if (this.dataReady) {
      this.setupTimer2();
    }
    //      this.state = TQBase.LevelState.NOT_INIT;
    //        this.dataReady = false;
    TQ.DirtyFlag.setLevel(this);
  };

  p.itemNum = function() {
    assertDepreciated(TQ.Dictionary.isDepreciated);
    return this.elements.length;
  };

  p.atomNum = function() {
    var sum = 0;
    for (var i = 0; i < this.elements.length; i++) {
      assertNotNull(TQ.Dictionary.FoundNull, this.elements[i]);
      sum += this.elements[i].atomNum();
    }
    return sum;
  };

  p.joint = function(elements) {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, TQ.InputCtrl.inSubobjectMode); // jointIt 必须运行在零件模式下!!!
    if (elements.length < 2) return null;
    var parent = elements[0];
    if (!parent.isJoint()) { // 对于已经是关键链的一部分的，不能设置为Root， 以避免多个Root
      parent.setFlag(TQ.Element.ROOT_JOINT); // 设置为关节链的根部
    }
    for (var i = 1; i < elements.length; i++) {
      this.pickOffChild(elements[i]);
      parent.addJoint(elements[i]);
      parent = elements[i];
    }
    TQ.DirtyFlag.setLevel(this);
  };

  /*
	打散本元件所在的关节链（整条链， 不是一个关节）
	 */
  p.unJoint = function(elements) {
    for (var i = 0; i < elements.length; i++) {
      // 先切断与 parent的联系（只有第一个元素有）， 再切断与孩子的联系
      var ele = elements[i];
      if (!ele) { // 有元素为null？？
        continue;
      }

      // 优先去除外层的附件，每次1层
      const attachmentID = ele.findAttachment();
      if (attachmentID >= 0) {
        const attachment = ele.children[attachmentID];
        ele.removeChild(attachment);
        this.addElementDirect(attachment);
        continue;
      }

      // 最后拆卸关节
      var parent = ele.parent;
      if (parent != null) {
        assertTrue(TQ.Dictionary.INVALID_PARAMETER, parent != null);
        parent.removeChild(ele);
        ele.clearFlag(TQ.Element.JOINTED);
        this.addElementDirect(ele);
      }
      var num = ele.children.length;
      for (var j = 0; j < num; j++) { //  动态地改变数组的尺寸， 所有num要先记录下来
        var child = ele.removeChild(ele.children[0]);
        this.addElementDirect(child);
        this.unJoint([child]);
      }
      ele.clearFlag(TQ.Element.JOINTED);
      ele.clearFlag(TQ.Element.ROOT_JOINT);
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.uniqueBone = function(elements) {
    // 最多只能有1个Bone，保留首个，剔除多余的
    let i = 0;
    const num = elements.length;
    let resultID = -1;
    for (i = num - 1; i >= 0; i--) {
      const x = elements[i];
      if (x.isJoint() || x.isRoot()) {
        if (resultID > -1) {
          elements.splice(resultID, 1);
        }
        resultID = i;
      }
    }
    return resultID;
  };

  p.doAttach = function(boneID, elements) {
    const host = elements[boneID];
    assertTrue("host must joint, not root", !!host && host.isJoint() && !host.isRoot());
    elements.splice(boneID, 1);
    assertTrue("empty elememts for group?", elements.length > 0);
    var aGroup = TQ.GroupElement.create(this, elements);
    host.addChild(aGroup);
    TQ.DirtyFlag.setLevel(this);
    return aGroup;
  };

  p.groupIt = function(elements) {
    TQ.SelectSet.turnOff();
    elements.forEach(function(ele) {
      if (ele && ele.hasBBox()) {
        ele.detachDecoration();
      }
    });

    const boneID = this.uniqueBone(elements);
    let host = null;
    if (boneID > -1) {
      host = elements[boneID];
      // case： 1个关节链， 转化为元件，
      if (host.isJoint() && !host.isRoot()) {
        return this.doAttach(boneID, elements);
      }
    }

    var aGroup = TQ.GroupElement.create(this, elements);
    this.addElementDirect(aGroup);
    this.latestElement = aGroup;
    TQ.DirtyFlag.setLevel(this);
    return aGroup;
  };

  p.unGroup = function(elements) {
    for (var i = 0; i < elements.length; i++) {
      var ele = elements[i];
      // if (ele.isJoint() || ele.isRoot()) {
      //   continue;
      // }
      if (!ele.isVirtualObject() && !!ele.parent) {
        ele = ele.parent;
      }
      if (ele == null) continue;
      if (ele.isGroup() || ele.children.length > 0) {
        const needDelete = (!!ele.isGroup());
        var parts = ele.explode();
        var j;
        for (j = 0; j < parts.length; j++) {
          this.addElementDirect(parts[j]);
        }
        if (needDelete) {
          this.deleteElement(ele);
        }
      }
    }

    TQ.DirtyFlag.setLevel(this);
    this.isDirtyZ = true;
  };

  p.cloneElement = function(elements) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      // var marker = elements[i].detachDecoration();
      elements[i].persist(); // 记录zIndex, 就在此层次clone, 把原来的物体抬高1个层次.
      var desc = JSON.parse(JSON.stringify(elements[i]));
      elements[i].afterToJSON();
      Level.removeMarker(desc);
      var newEle;
      if (elements[i].parent == null) {
        newEle = this.addElementDirect(TQ.Element.build(this, desc));
      } else {
        newEle = elements[i].parent.addChild(desc);
      }
      results.push(newEle);
    }
    TQ.DirtyFlag.setLevel(this, true);
    return results;
  };

  Level.removeMarker = function(desc) {
    if (!desc.children) return;
    for (var i = 0; i < desc.children.length; i++) { // 去除Marker部分
      if (desc.children[i].type === "JointMarker") {
        desc.children.splice(i, 1);
        break;
      }
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.skinning = function(hostElement, skinElement) {
    TQ.AssertExt.depreciated(false, "ToDo: 是不是被changeSkin代替了？");
    assertNotNull(TQ.Dictionary.FoundNull, hostElement);
    assertNotNull(TQ.Dictionary.FoundNull, skinElement);
    hostElement.skinning(skinElement);
    TQ.DirtyFlag.setLevel(this);
  };

  // 在整体模式下, 找到根物体； 在零件模式下， 返回子物体本身
  p.findAtom = function(displayObj) {
    // atom: 包括 元素element, 和 子元素subelement
    var result = null;
    for (var i = 0; i < this.elements.length; i++) {
      // 是结构性的虚拟物体, 例如Group的节点
      if ((this.elements[i].displayObj != null) &&
        (this.elements[i].displayObj.id !== undefined) &&
        (this.elements[i].displayObj.id === displayObj.id)) {
        return (result = this.elements[i]);
      } else {
        result = this.elements[i].findChild(displayObj);
        if (result != null) {
          if ((!TQ.InputCtrl.inSubobjectMode) && (!result.isJoint())) result = this.elements[i];
          break;
        }
      }
    }
    return result;
  };

  p.findAllDub = function() {
    // 临时限制：一个场景中只能有1个配音，元件中的配音不能消除
    // ToDo: 将来允许多个配音， 可以选择是否消除元件中的配音，
    var result = [];
    for (var i = 0; i < this.elements.length; i++) {
      var ele = this.elements[i];
      if (ele.isSound() && ele.isDub()) {
        result.push(ele);
      }
    }
    return result;
  };

  p.pickOffChild = function(ele) {
    assertNotNull(TQ.Dictionary.PleaseSelectOne, ele);
    var id = this.elements.indexOf(ele);
    if (id >= 0) {
      this.removeElementAt(id);
    } else {
      var parent = ele.parent;
      assertTrue(TQ.Dictionary.FoundNull, parent != null); // 应该有父元素
      if (parent) {
        parent.removeChild(ele);
      }
    }
    TQ.DirtyFlag.setLevel(this);
    return ele;
  };

  p.addElement = function(desc) {
    var newItem = TQ.Element.build(this, desc);
    return this.addElementDirect(newItem);
  };

  p.addElementDirect = function(ele) {
    assertNotNull(TQ.Dictionary.FoundNull, ele);
    // 记录新创建的元素到elements
    this.elements.push(ele);
    if (TQ.Element.isBackground(ele.jsonObj)) {
      // TQ.AssertExt.invalidLogic(!this.background, "应该只有1个背景");
      this.background = ele;
    }
    TQ.DirtyFlag.setLevel(this);
    this.isDirtyZ = true;
    // ToDo: 暂时关闭， 还需要多调试
    // if (! (ele.isSound() || ele.isGroupFile() || ele.isButton()) ) {
    //    TQ.SelectSet.add(ele);
    // }
    return ele;
  };

  p.getElements = function() {
    return this.elements;
  };

  /* 区别 delete 和 remove：
		 remove: 只是移动， 从一个地方， 移到另外一个地方，比如： 在打包的时候， 从level下移到 复合体的下面。
		 delete：包括了remove， 但是， 移到了 垃圾箱trash之中, 当undelete的时候， 可以恢复
	*/
  p.deleteElementAt = function(i) {
    var ele = this.removeElementAt(i);
    if (ele) {
      this.deleteElementFromStage(ele);
    }
  };

  p.deleteElementFromStage = function(ele) {
    if (this.background === ele) {
      this.background = null;
    }

    if (ele != null) {
      ele.removeFromStage();
      TQ.GarbageCollector.add(ele);
    }
    TQ.DirtyFlag.setElement(this);
    this.isDirtyZ = true;
    return ele;
  };

  p.removeElementAt = function(i) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, (i >= 0) && (i < this.elements.length)); // 数组超界
    TQ.DirtyFlag.setElement(this);
    return (this.elements.splice(i, 1))[0];
  };

  p.getBackground = function() {
    return this.background;
  };

  p.getElement = function(id) {
    if (this.elements.length <= 0) {
      assertFalse(TQ.Dictionary.INVALID_LOGIC, false);
      return null;
    }

    assertTrue("id < (this.elements.length)", id < (this.elements.length));
    id = (id < 0) ? 0 : id;
    id = (id >= (this.elements.length - 1)) ? (this.elements.length - 1) : id;
    return this.elements[id];
  };

  p.getText = function(id) {
    var j = 0;
    var n = this.elements.length;
    for (var i = 0; i < n; i++) {
      if (this.elements[i].isText()) {
        if (j === id) {
          return this.elements[i].getText();
        }
        j++;
      }
    }
    return null;
  };

  p.getSounds = function() {
    var result = [];
    if (this.resourceReady) {
      var num = this.elements.length;
      for (var i = 0; i < num; i++) {
        if (!this.elements[i].isSound) break;
        if (this.elements[i].isSound()) {
          result.push(this.elements[i]);
        }
      }
    }

    return result;
  };

  p.setDisplaceX = function() {
    assertNotHere(TQ.Dictionary.isDepreciated); // "xxx0 已经被取代, 该函数将被取消"
  };

  p.onLoaded = function() {
    this.resourceReady = true; // 适应于新建立的level， 他们没有元素，直接ready
    this.state = TQBase.LevelState.LOADED;
    this.build(); // 从Resource 到 canvas
    if (this.isActive() && !this.isOverlay()) {
      this.setupTimer2();
    }

    TQ.Log.checkPoint("onLoaded level:  " + this.name);
    if (this.isWaitingForShow) {
      this.isWaitingForShow = false;
      this.doShow();
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.doShow = function() {
    TQ.Log.checkPoint("doShow level: " + this.name);
    if (this.dataReady) {
      TQ.Log.info("data ready");
      this.onLevelCreated();
    } else {
      TQ.AssertExt.invalidLogic(true, "应该先调用show");
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.show = function() {
    TQ.Log.checkPoint("ask to show level: " + this.name);
    if (this.dataReady) {
      this.doShow();
    } else {
      TQ.Log.info("data ready: NO");
      this.isWaitingForShow = true;
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.build = function() {
    // 避免重复进入：
    if (this.dataReady) {
      return;
    }

    this.itemCounter = 0;
    var jsonElements = this.elements;
    this.elements = [];
    this.state = TQBase.LevelState.INITING;
    TQ.StageBuffer.open();
    for (var i = 0; i < ((jsonElements != null) && (jsonElements.length)); i++) {
      var desc = jsonElements[i];
      if (desc && TQ.Element.isValidDesc(desc)) {
        desc.src = TQUtility.unifyFormat(desc.type, desc.src);
        this.addElementDirect(TQ.Element.build(this, jsonElements[i]));
      }
    }
    TQ.StageBuffer.close();
    // ToDo: 是否应该分多个level, 来启动?
    TQ.SoundMgr.start();
    TQ.VideoMgr.start();
    jsonElements = null;
    this.dataReady = true;
    TQ.DirtyFlag.setLevel(this);
    this.calculateLastFrame();
  };

  p.fixupButtons = function() {
    for (var i = 0; i < (this.elements.length); i++) {
      var ele = this.elements[i];
      if ((ele.isButton !== undefined) && ele.isButton()) {
        ele.buildLinks();
      }
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.findByDescId = function(descId) {
    for (var i = 0; i < (this.elements.length); i++) {
      var ele = this.elements[i];
      if (ele.jsonObj.id === descId) return ele;
    }

    return null;
  };

  p.setupPreloader = function() {
    // send to RM
    // 避免重复进入：
    if (!this.hasSentToRM) {
      this.hasSentToRM = true;
    } else {
      return;
    }

    if (this.elements) {
      TQ.RM.addElementDescList(this.elements);
    }
  };

  p.addAllItems = function() {
    // add到stage， === 显示，show
    TQ.StageBuffer.open();
    var num = this.elements.length;
    for (var i = 0; i < num; i++) {
      this.elements[i].addItemToStage();
    }
    TQ.StageBuffer.close();
    this.state = TQ.SceneEditor.getMode();
    TQ.DirtyFlag.setLevel(this);
  };

  p.addLastItems = function() {
    // add到stage， === 显示，show
    assertDepreciated(TQ.Dictionary.isDepreciated);
    assertTrue(TQ.Dictionary.isDepreciated, false); // "应该只在临时添加的时候, 才调用"
    TQ.DirtyFlag.setLevel(this);
  };

  p.hitTest = function() {
    TQ.assertNotHere("not implemented: test if mouse hits element");
    var n = this.elements.length;
    for (let i = 0; i < n; i++) {
      var displayObj = this.elements[i].displayObj;
      if (displayObj.hitTest(stage.mouseX, stage.mouseY)) {
        displayObj.alpha = 0.5; // 加框子
        stage.update();
      }
    }
  };

  p.onLevelRunning = null;
  p.onLevelCreated = function() {
    if ((this.state === TQBase.LevelState.INITING) ||
      (this.state === TQBase.LevelState.LOADED) ||
      (this.state === TQBase.LevelState.EDITING) ||
      (this.state === TQBase.LevelState.EXIT)) {
      // 后续场景loaded是通过RM完成的， 所以可能还是INITING状态
      if (!this.isOverlay()) {
        this.setupTimer();
      }

      if (this.isActive() && !this.inStage) {
        // add all item to stage
        if (stageContainer.children.length > 0) {
          this._removeAllItemsFromStage();
        }
        this.addAllItems();
      }
      this.update(this._t);
      stage.update();
      this.watchRestart();
      this.state = TQ.SceneEditor.getMode();
      if (this.onLevelRunning != null) this.onLevelRunning();
      TQ.DirtyFlag.setLevel(this);
      if (this.isActive() && !this.inStage) {
        this.readyToShow = true;
      }
    } else {
      if ((this.state !== TQBase.LevelState.EDITING) && (this.state !== TQBase.LevelState.RUNNING)) {
        assertNotHere(TQ.Dictionary.CurrentState + this.state);
      }
    }
  };

  p.watchRestart = function() {
    // draw all elements to the canvas:
    stage.update();
  };

  p.removeNullElements = function() {
    for (var i = 0; i < this.elements.length; ++i) {
      if (!this.elements[i]) {
        this.elements.splice(i, 1);
        i--;
      }
    }
  };

  p.update = function(t) {
    this.updateState();
    this.removeNullElements();
    if (!this.dataReady) return;

    if (!(this.isDirtyZ || this.isDirty || TQ.FrameCounter.isPlaying())) {
      return;
    }

    if (TQ.State.isAddMode || TQ.State.isModifyMode) {
      this._t = t; // 临时存储,供保留现场, 不对外
    }
    // 如果是播放状态，
    for (var i = 0; i < this.elements.length; ++i) {
      if (!this.elements[i].TBD) {
        this.elements[i].update(t);
      } else {
        var thisEle = this.elements[i];
        this.elements[i].TBD = undefined;
        TQ.CommandMgr.directDo(new TQ.DeleteEleCommand(currScene, thisEle));
        i--;
      }
    }

    // 非播放状态
    if (this.isDirty) {
      this.calculateLastFrame();
      if (this.isActive() && !TQ.Utility.equalWithin2(TQ.FrameCounter.maxTime(), this.getTime())) {
        TQ.FrameCounter.setTMax(this.getTime());
        setTimeout(function() {
          TQ.DirtyFlag.setCurrentLevel();
        });
      }
      stage.update();
    }
    if (this.isDirtyZ) {
      this.persist();
    }
    this.isDirtyZ = false;
    this.isDirty = false;
    if (this.updateCompletedHandlers.length > 0) {
      for (const func of this.updateCompletedHandlers) {
        func();
      }
      this.updateCompletedHandlers.splice(0);
    }
  };

  p.updateState = function() {
    // TQ.Log.info("update state");
    if (this.state <= TQBase.LevelState.INITING) {
      if (this.resourceReady) {
        this.onLoaded();
      }
    }
  };

  p.updateRenderFlag = function() {
    if (!this.inStage && this.readyToShow) {
      this.inStage = true;
      var levelId = currScene.currentLevelId;
      setTimeout(function() {
        TQ.Base.Utility.triggerEvent(document, Level.EVENT_START_SHOWING, { levelId: levelId });
      });
    }
  };

  p.empty = function() {
    if (this.isActive()) {
      this.cleanStage();
    }
    this.elements.splice(0);
    this.latestElement = null;
    this.background = null;
    this.state = TQBase.LevelState.INITING;
    TQ.DirtyFlag.setLevel(this);
  };

  p.cleanStage = function() {
    TQ.DirtyFlag.setLevel(this);
    if (this.dataReady) {
      for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].resetStageFlag();
      }
    }

    TQ.SceneEditor.cleanStage();
  };

  p._removeAllItemsFromStage = function() {
    TQ.DirtyFlag.setLevel(this);
    // remove 从stage， 只是不显示， 数据还在
    if (this.elements && (this.elements.length > 0) && (this.elements[0].removeFromStage)) {
      for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].removeFromStage();
      }
    }
  };

  p.delete = function() {
    TQ.AssertExt.depreciated("是否已经被 cleanStage代替了？-2018.07.07");
    // 如果是EXIT， 则已经被exit()函数处理过了，
    TQ.DirtyFlag.setLevel(this);
    if (this.isElementInStage()) {
      this._removeAllItemsFromStage();
    }
  };

  p.deleteElement = function(ele) {
    // 删除level的时候，其中pin的元素也应该被删除
    // if (ele.isPinned()) {
    //  return;
    // }

    // 删除数据， 真删除
    var found = false;
    TQ.DirtyFlag.setLevel(this);
    for (var i = 0; i < this.elements.length; i++) {
      if (this.elements[i] === ele) {
        this.deleteElementAt(i);
        found = true;
        break;
      }

      // 检查是否子物体
      if (this.elements[i].deleteChild(ele) === true) {
        found = true;
        break;
      }
    }
    if (found) {
      this.isDirty = true;
      return true;
    } else {
      this.deleteElementFromStage(ele);
      TQ.AssertExt.invalidLogic(false, "在level上未找到此元素，但是显示在stage中，已经被删除了？");
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
    }

    return false;
  };

  /*
	stop sound, video, animations, etc.
	 */
  p.stop = function() {
    for (var i = 0; i < this.elements.length; i++) {
      if (this.elements[i].stop) {
        this.elements[i].stop();
      }
    }
  };

  p.play = function() {
    TQ.DirtyFlag.setLevel(this);
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].play();
    }
  };

  p.exit = function() {
    TQ.SelectSet.empty();
    if (this.isEditMode()) {
      this.calculateLastFrame();
    }
    if (this.isElementInStage()) {
      if (this.isEditMode()) {
        this.sort(); // 退出本层之前, 必须保存 Z可见性顺序.
      }
      this.cleanStage();
    } else {
      // is loading
      TQ.Log.debugInfo("is loading, or not loaded!");
    }
    TQ.SoundMgr.removeAll();
    TQ.VideoMgr.removeAll();
    TQ.ParticleMgr.removeAll();
    if (TQ.State.isAddMode) {
      TQ.SelectSet.clear();
      TQ.AnimationManager.clear();
      TQ.SoundMgr.reset();
    }
    this._removeAllItemsFromStage();
    this.state = TQBase.LevelState.EXIT;
    this.inStage = false;
  };

  p.prepareForJSONOut = function() {
    TQ.AssertExt.invalidLogic(this.dataReady, "数据没有加载完成， 不能调用");
    this.persist(); // 固化z-Index值
  };

  p.afterToJSON = function() {
    if (this.dataReady) { // 只对load的 level做这个操作
      for (var i = 0; i < this.elements.length; i++) {
        this.elements[i].afterToJSON();
      }
    }
  };

  p.persist = function() {
    if (!this.isActive()) {
      return;
    }
    for (var i = 0; i < this.elements.length; i++) { // 持久化zIndex, 只在退出时, 而不是每一个Cycle, 以节约时间
      this.elements[i].persist();
    }
  };

  p.sort = function() {
    // 按照当前物体在显示列表中的顺序, 重新排列elements的数据.
    TQ.DirtyFlag.setLevel(this);
    assertNotNull(this.elements);
    this.persist();
    this.elements.sort(TQ.Element.compare);
    for (var i = 0; i < this.elements.length; i++) {
      this.elements[i].sort();
    }
  };

  p.trim = function(t1, t2) {
    if (t1 < 0) {
      t1 = 0;
    }

    if (t1 >= t2) {
      return;
    }

    this.elements.forEach(function(ele) {
      if (ele) {
        ele.trim(t1, t2);
      }
    });
  };

  p.onItemLoaded = function(item) {
    TQ.DirtyFlag.setLevel(this);
    this.itemCounter++;
    if (this.isStageReady()) {
      // assertTrue("应该只在临时添加的时候, 才调用", !TQ.StageBuffer.isBatchMode);
      item.addItemToStage();
    } else {
      // 正在 loading, 或者fixup, 由update来控制状态
    }
  };

  p.setupTimer = function() {
    if (TQ.FrameCounter.isPlaying()) { // play mode
      this._t = 0;
      TQ.FrameCounter.gotoBeginning();
    } else { // edit mode
      TQ.FrameCounter.goto(this._t);
    }
  };

  p.setupTimer2 = function() {
    TQ.FrameCounter.initialize(this._t, this.FPS, this);
    if (!TQBase.LevelState.isOperatingTimerUI()) {
      TQ.TimerUI.initialize();
    } else {
      this._t = TQ.FrameCounter.t();
    }
  };

  p.resetTimer = function() {
    // 强制本level的_t为0, 避免在play返回之后，收到play之timer的影响
    this._t = 0;
  };

  // 自动拓展微动漫的时间
  p.calculateRealLastFrame = function() {
    if (!this.dataReady) return this.tMaxFrame;
    // 在退出本level的时候才调用，以更新时间，
    //  ToDo: ?? 在编辑本Level的时候， 这个值基本上是没有用的
    var tLastFrame = 0;
    var tGlobalLastFrame = 0;
    var ele;
    for (var i = 0; i < this.elements.length; i++) {
      ele = this.elements[i];
      assertNotNull(TQ.Dictionary.FoundNull, ele);
      if (!ele.calculateLastFrame) {
        assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      } else {
        if (ele.isCrossLevel) {
          tGlobalLastFrame = Math.max(tGlobalLastFrame, ele.calculateLastFrame());
        } else {
          tLastFrame = Math.max(tLastFrame, ele.calculateLastFrame());
        }
      }
    }
    this.tGlobalLastFrame = tGlobalLastFrame;
    return tLastFrame;
  };

  p.calculateLastFrame = function() {
    var tMaxFrameCalculated = this.calculateRealLastFrame();
    if (tMaxFrameCalculated > TQ.Config.MAX_LEVEL_LENGTH) {
      tMaxFrameCalculated = TQ.Config.MAX_LEVEL_LENGTH;
    }
    if (tMaxFrameCalculated < DEFAULT_T_MAX_FRAME) { // 没有设置时长， 也没有长时间的sound, video
      tMaxFrameCalculated = DEFAULT_T_MAX_FRAME;
    }
    this.tMaxFrameMixed = Math.max(this.tMaxFrame, tMaxFrameCalculated);
    return tMaxFrameCalculated;
  };

  function isStaticImage(tLastFrame) {
    return (tLastFrame < 0.1);
  }

  var stepSeries = [1, 2, 5, 10, 20, 50, 100, 500, 1000, 5000];

  function findStep(delta) {
    var ideaStep = 1;
    stepSeries.some(function(step) {
      if (delta > step) {
        ideaStep = step;
      }
      return (delta < step);
    });

    return ideaStep;
  }

  p.increaseTime = function() {
    var oldMax = this.getTime();
    var newMax = oldMax + findStep(oldMax * 0.2);
    if (newMax < 1) {
      newMax = 1;
    }
    this.setCapacity(newMax);
    TQ.DirtyFlag.setLevel(this);
  };

  p.decreaseTime = function() {
    var oldMax = this.getTime();
    var newMax = oldMax - findStep(oldMax * (1 - 1 / 1.2));
    if (newMax === oldMax) {
      if ((newMax > 2)) {
        newMax--;
      } else {
        newMax = newMax / 2;
      }
    }
    this.setCapacity(newMax);
    TQ.DirtyFlag.setLevel(this);
  };

  p.setTime = function(t) { // 用户指定时长
    if (t > TQ.Config.MAX_LEVEL_LENGTH) {
      t = TQ.Config.MAX_LEVEL_LENGTH;
    }
    this.tMaxFrame = t;
    this.calculateLastFrame(); // update mixed
    if (this.isActive()) {
      TQ.FrameCounter.setTMax(this.getTime());
    }
    TQ.DirtyFlag.setLevel(this);
  };

  p.setCapacity = function(t) {
    if (t >= this.getTime()) {
      if (this.isActive()) {
        TQ.FrameCounter.setTMax(t);
      }
    }
  };

  p.getTime = function() {
    return this.tMaxFrameMixed;
  };

  p.getGlobalTime = function() {
    return this.tGlobalLastFrame;
  };

  p.setT0 = function(t0) {
    this.t0 = t0;
  };
  p.getT0 = function() {
    return this.t0;
  };

  p.isEmpty = function() {
    return (!this.elements || (this.elements.length <= 0));
  };

  p.isStageReady = function() {
    return ((this.state === TQBase.LevelState.INITING) ||
      (this.isElementInStage()));
  };

  p.isElementInStage = function() {
    return ((this.state === TQBase.LevelState.EDITING) ||
      (this.state === TQBase.LevelState.RUNNING));
  };

  p.isActive = function() {
    return (currScene && (currScene.currentLevel === this) || (this.isWaitingForShow));
  };

  p.isShowing = function() {
    return this.inStage;
  };

  p.isOverlay = function() {
    return false;
  };

  p.isEditMode = function() {
    return ((this.state === TQBase.LevelState.EDITING) &&
      (TQ.State.editorMode === TQ.SceneEditor.MODE.EDIT));
  };

  p.hasAnimation = function() {
    return !isStaticImage(this.tMaxFrame);
  };

  p.hasGraph = function() {
    var result = false;
    this.elements.some(function(ele) {
      if (ele.hasGraph()) {
        result = true;
        return true;
      }
      return false;
    });
    return result;
  };

  // upgrade:
  Level.upgradeEachElement = function(levelDesc, upgradeElement) {
    var elements;

    if (!levelDesc || !(elements = levelDesc.elements)) {
      return;
    }

    for (var i = 0; i < (elements.length); i++) {
      upgradeElement(elements[i]);
    }
  };

  Level.upgrade3_4ToVer3_6 = function(levelDesc) {
    var elements,
      eleDesc;

    if (!levelDesc || !(elements = levelDesc.elements)) {
      return;
    }

    for (var i = 0; i < (elements.length); i++) {
      eleDesc = elements[i];
      if (eleDesc.eType === TQ.Element.ETYPE_AUDIO) {
        if (eleDesc.isMultiScene !== undefined) {
          eleDesc.isCrossLevel = eleDesc.isMultiScene;
        }
      }
    }
  };

  Level.upgrade3_3ToVer3_4 = function(levelDesc) {
    var foundBackground = false;
    var elements;
    var eleDesc;

    if (!levelDesc || !(elements = levelDesc.elements)) {
      return;
    }

    for (var i = 0; i < (elements.length); i++) {
      eleDesc = elements[i];
      if (eleDesc.eType === TQ.Element.ETYPE_BACKGROUND) {
        if (!foundBackground) {
          foundBackground = true;
        } else {
          eleDesc.eType = TQ.Element.ETYPE_PROP;
        }
      }
    }
  };

  p.registerHandler = function(func) {
    this.updateCompletedHandlers.push(func);
  };

  TQ.Level = Level;
}());

/**
 *  Overlay 存放的是系统用的咨询， 与用户创造的数据无关。
 *  所以， 程序启动之后， 初始化一次就够了，
 *  不需要在每次open/save/new文件的时候重新初始化。
 * */
window.TQ = window.TQ || {};

(function() {
  function Overlay(description) {
    this.initialize(description);
  }

  var p = Overlay.prototype = new TQ.Level();
  p.Level_update = p.update;
  p.Level_initialize = p.initialize;
  p.initialize = function(desc) {
    if (!desc.name) {
      desc.name = "overlay";
    }
    this.Level_initialize(desc);
    this.show();
  };

  p.update = function(deltaT) {
    this.Level_update(deltaT);
    if (stage.selectedItem == null) {
      this.hideClipPoint(true);
    } else {
      this.hideClipPoint(false);
    }
  };

  p.hideClipPoint = function(isVisible) {
    for (var i = 0; i < this.elements.length; ++i) {
      if (this.elements[i].isClipPoint() && (this.elements[i].displayObj !== undefined)) {
        this.elements[i].show(isVisible);
      }
    }
  };

  p.isOverlay = function() {
    return true;
  };

  TQ.Overlay = Overlay;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * Sound的Manager, 负责Sound的preload, play, stop, 等一系列工作.
 * 是singleton
 */
TQ = TQ || {};
(function() {
  function SoundMgr() {
  }

  SoundMgr.started = false;
  SoundMgr.isSupported = false;
  SoundMgr.items = [];
  var isReseting = false;

  SoundMgr.initialize = function() {
    SoundMgr.isSupported = true;
  };

  SoundMgr.start = function() {
    if (!SoundMgr.isSupported) return;

    // ToDo: 不重复 start ??
    SoundMgr.started = true;
  };

  /*
      专门用于试听声音，同时只允许播放1个。 试听新的必须关闭旧的。
     播放声音文件，id就是fileName，是声音文件的路径和名称， （从服务器的根目录计算， 不带域名)，
     例如： "mcSounds/test1.mp3"
     */
  var _auditioningInstance = null;
  SoundMgr.isPlaying = function(soundInstance) {
    return (soundInstance && soundInstance.isPlaying());
  };
  SoundMgr.play = function(id) {
    if (!SoundMgr.isSupported) return;
    TQ.Log.info("start to play " + id);
    var item = TQ.RM.getResource(id);
    stopAllDirectSound();
    _auditioningInstance = new TQ.HowlerPlayer(TQ.RM.getId(item));
    _auditioningInstance.play();
    return _auditioningInstance;
  };

  function stopAllDirectSound() {
    if (_auditioningInstance) {
      _auditioningInstance.stop();
      _auditioningInstance = null;
    }
  }

  SoundMgr.addItem = function(ele) {
    if (SoundMgr.items.indexOf(ele) >= 0) { // 避免同一个元素（跨场景的），重复插入
      return;
    }
    SoundMgr.items.push(ele);
  };

  SoundMgr.deleteItem = function(ele) {
    var id = SoundMgr.items.indexOf(ele);
    if (id >= 0) {
      ele.stop();
      SoundMgr.items.splice(id, 1);
    }
  };

  SoundMgr.pause = function() {
    for (var i = SoundMgr.items.length; i--;) {
      SoundMgr.items[i].pause();
    }
  };

  SoundMgr.resume = function(spriteName) {
    var t = TQ.FrameCounter.t();
    for (var i = 0; i < SoundMgr.items.length; i++) {
      var ele = SoundMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      if (ele.isCrossLevel) {
        var tt = currScene.toGlobalTime(t);
        ele.resume(tt);
      } else {
        ele.resume(t, spriteName);
      }
    }
  };

  SoundMgr.stopAll = function() {
    for (var i = 0; i < SoundMgr.items.length; i++) {
      var ele = SoundMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      ele.stop();
    }
    stopAllDirectSound();
  };

  SoundMgr.iosForceToResumeAll = function() {
    for (var i = 0; i < SoundMgr.items.length; i++) {
      var ele = SoundMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      if (ele.isVisible()) {
        ele.forceToReplay();
      }
    }
    stopAllDirectSound();
  };

  SoundMgr.removeAll = function() {
    // 只删除那些不跨场景的
    for (var i = SoundMgr.items.length - 1; i >= 0; i--) {
      var ele = SoundMgr.items[i];
      if (ele.isCrossLevel && !isReseting) continue;
      ele.stop();
      SoundMgr.items.splice(i, 1);
    }
    stopAllDirectSound();
  };

  SoundMgr.reset = function() {
    isReseting = true;
    SoundMgr.close();
    isReseting = false;
  };

  SoundMgr.close = function() {
    if (!SoundMgr.isSupported) return;
    SoundMgr.stopAll();
    SoundMgr.removeAll();
    SoundMgr.items.splice(0); // 在退出微创意的时候，清除跨场景声音
    SoundMgr.started = false;
  };

  SoundMgr.stopAllDirectSound = stopAllDirectSound;
  TQ.SoundMgr = SoundMgr;
}());

/**
 * Created by Andrewz on 1/6/19.
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 选择集: 所有的操作都是基于选择集的
 */

TQ = TQ || {};
(function() {
  function Video(src, onStarted) {
    this.playState = 0;
    this.host = null;
    this.createVideoElement(src, onStarted);
  }

  Video.UNKNOWN = 1;
  Video.LOADED = 2;
  Video.SHOW_FIRST_PAGE = 3;
  Video.PLAY_SUCCEEDED = 100; // === PLAYING, STARTED
  Video.PLAY_FINISHED = 230;
  Video.PLAY_INTERRUPTED = 300;
  Video.PLAY_FAILED = 310;
  Video.INTERRUPT_NONE = 320;

  var contentDiv;

  Video.loadVideoRes = loadVideoRes;
  Video.play = function(resId, onStarted) {
    var instance = new Video(resId, function() {
      instance.play();
      if (onStarted) {
        onStarted(instance);
      }
    });
    return instance;
  };

  Video.stop = function(instance) {
    if (instance) {
      instance.stop();
    }
  };

  var p = Video.prototype;
  p.initialize = function() {
  };

  p.reset = function() {
    if (this.domEle) {
      this.domEle.currentTime = 0;
    }
  };

  p.play = function() {
    if (!this.domEle) {
      TQ.AssertExt.depreciated("不支持这种case，必须有domEle，因为这是内部函数, 应该简化");
    }
    this.addToDom();
    if (this.domEle) {
      this.domEle.style.visibility = "visible";
      var self = this;
      if (!TQ.State.needUserClickToPlayAV) {
        var playPromise = this.domEle.play();
        // if (playPromise != null) {
        //   playPromise.catch(function(){self.domEle.play();});
        // }

        if (playPromise !== undefined) {
          playPromise.then(function(value) {
            self.domEle.play();
            if (self.host) {
              TQ.DirtyFlag.setElement(self.host);
            }
          }).catch(function(error) {
            console.log(error);
            console.log("Autoplay was prevented." +
              "Show a \"Play\" button so that user can start playback");
          });
        }
      }
    }
  };

  p.addToDom = function() {
    if (!this.isInDom) {
      this.isInDom = true;
      this.duration = this.domEle.duration;
      if (!contentDiv) {
        contentDiv = document.getElementById("testCanvas");
        if (contentDiv && contentDiv.parentElement) {
          contentDiv = contentDiv.parentElement;
        }
      }
      if (!contentDiv) {
        TQ.AssertExt.invalidLogic(false, "DOM中，需要有id为testCanvas的元素");
      } else {
        contentDiv.appendChild(this.domEle);
      }
      this.playState = Video.PLAY_SUCCEEDED;
    }
  };

  p.stop = function(res) {
    if (this.domEle) {
      this.domEle.pause();
    }
    this.playState = Video.PLAY_INTERRUPTED;
  };
  p.resume = function() {
    this.play();
  };

  p.removeFromDom = function() {
    if (this.isInDom) {
      this.isInDom = false;
      if (this.domEle && this.domEle.parentElement) {
        this.domEle.parentElement.removeChild(this.domEle);
        this.domEle.parentElement = null;
      }
    }
  };

  p.createVideoElement = function(src, onloadeddata) {
    var self = this;
    if (self.isGenerating) {
      return;
    }
    self.isGenerating = true;
    self.src = src;

    loadVideoRes(src, function(ele) {
      self.domEle = ele;
      self.addToDom();
      if (onloadeddata) {
        onloadeddata(self);
      }
    });
  };

  function loadVideoRes(src, callback) {
    var ele = document.createElement("video");
    var starTime = Date.now();

    ele.addEventListener("loadeddata", onLoadedData, false);

    function onLoadedData(evt) {
      self.isGenerating = false;
      // this.updateSize();
      console.log(evt.srcElement.id + " :" + starTime + ":" + (Date.now() - starTime) + " who fast: onloadeddata");
      if (callback) {
        callback(ele);
      }
    }

    // ele.addEventListener('loadstart', onWhoFast, false);
    ele.addEventListener("canplay", onWhoFast, false);
    ele.addEventListener("loadedmetadata", onWhoFast, false);
    ele.addEventListener("canplaythrough", onWhoFast, false);

    function onWhoFast(evt) {
      ele.removeEventListener("canplay", onWhoFast, false);
      ele.removeEventListener("loadedmetadata", onWhoFast, false);
      ele.removeEventListener("canplaythrough", onWhoFast, false);
      console.log(evt.srcElement.id + " :" + starTime + ":" + (Date.now() - starTime) +
        " who fast: " + evt.type + ", " + JSON.stringify(evt));
    }

    if (!TQUtility.isBlobUrl(src)) {
      src = TQ.RM.toFullPathFs(src);
    }
    ele.src = src;
    ele.id = src.substr(-10, 10).replace(/\/|\./g, "_") + starTime;
    ele.autoplay = true;
    ele.preload = "metadata";
    ele.style.visibility = "none";
    ele.className = "video-layer video-container";
    // ele.controls = true;
    // ele.setAttribute("controls", "false");
  }

  p.getDuration = function() {
    if (this.duration && !isNaN(this.duration)) {
      return this.duration;
    }

    if (this.domEle && !isNaN(this.domEle.duration)) {
      return this.domEle.duration;
    }
    return 0;
  };

  TQ.Video = Video;
}());

/**
 * Created by Andrewz on 1/6/19.
 * 图强动漫引擎,
 * 专利产品 领先技术
 * Video的Manager, 负责Video的preload, play, stop, 等一系列工作.
 * VideoMgr ==》                  Video ==》 domEle
 *          ==》 VideoElement ==》
 * ！！！不能直接操作Video内部的instance
 *
 * 包括正式场景中的 和 试播的
 * 是singleton
 */
TQ = TQ || {};
(function() {
  function VideoMgr() {
  }

  VideoMgr.started = false;
  VideoMgr.isSupported = false;
  VideoMgr.items = [];
  var isReseting = false;
  var isResizing = false;
  var directVideos = {};

  VideoMgr.initialize = function() {
    VideoMgr.isSupported = true;
  };

  VideoMgr.start = function() {
    if (!VideoMgr.isSupported) return;

    // ToDo: 不重复 start ??
    VideoMgr.started = true;
  };

  /*
		专门用于试播，同时只允许播放1个。 试看新的，必须关闭旧的。
	 */
  var _auditioningInstance = null;
  VideoMgr.isPlaying = function(instance) {
    if (!instance) return false;
    return (instance.playState === TQ.Video.PLAY_SUCCEEDED); // 包括paused， 不包括已经播完的
  };

  VideoMgr.play = function(id, onStarted) {
    if (!VideoMgr.isSupported) return;
    TQ.Log.info("start to play " + id);
    var inst = directVideos[id];
    if (inst) {
      if (_auditioningInstance) {
        if (VideoMgr.isPlaying(_auditioningInstance)) {
          _auditioningInstance.stop();
        }
      }
      directVideos[id] = _auditioningInstance = inst;
      inst.play();
      if (onStarted) {
        onStarted(inst);
      }
    } else {
      TQ.Video.play(id, function(inst) {
        directVideos[id] = _auditioningInstance = inst;
        if (onStarted) {
          onStarted(inst);
        }
      });
    }
  };
  VideoMgr.createInstance = VideoMgr.play;
  VideoMgr.stop = function(id) {
    TQ.Video.stop(directVideos[id]);
    delete directVideos[id];
  };

  function stopAllDirectVideo() {
    for (const id in directVideos) {
      VideoMgr.stop(id);
    }
  }

  function resetAllDirectVideo() {
    for (const id in directVideos) {
      directVideos[id].reset();
    }
  }

  VideoMgr.addItem = function(ele) {
    if (VideoMgr.items.indexOf(ele) >= 0) { // 避免同一个元素（跨场景的），重复插入
      return;
    }
    if (ele.instance && ele.instance.domEle) {
      ele.instance.addToDom();
      ele.instance.reset();
    }
    VideoMgr.items.push(ele);
  };

  VideoMgr.deleteItem = function(ele) {
    var id = VideoMgr.items.indexOf(ele);
    if (id >= 0) {
      VideoMgr.items.splice(id, 1);
    }
  };

  VideoMgr.pause = function() {
    for (var i = VideoMgr.items.length; i--;) {
      VideoMgr.items[i].pause();
    }
  };

  VideoMgr.resume = function() {
    var t = TQ.FrameCounter.t();
    for (var i = 0; i < VideoMgr.items.length; i++) {
      var ele = VideoMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      if (ele.isCrossLevel) {
        var tt = currScene.toGlobalTime(t);
        ele.resume(tt);
      } else {
        ele.resume(t);
      }
    }
  };

  VideoMgr.stopAll = function() {
    for (var i = 0; i < VideoMgr.items.length; i++) {
      var ele = VideoMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      ele.stop();
    }
    if (_auditioningInstance) {
      _auditioningInstance.stop();
    }
    stopAllDirectVideo();
  };

  VideoMgr.iosForceToResumeAll = function() {
    for (var i = 0; i < VideoMgr.items.length; i++) {
      var ele = VideoMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      if (ele.isVisible()) {
        ele.forceToReplay();
      }
    }
    stopAllDirectVideo();
  };

  VideoMgr.removeAll = function() {
    // 只删除那些不跨场景的
    for (var i = VideoMgr.items.length - 1; i >= 0; i--) {
      var ele = VideoMgr.items[i];
      if (ele.isCrossLevel && !isReseting) continue;
      ele.stop();
      ele.removeFromStage();

      VideoMgr.items.splice(i, 1);
    }
    stopAllDirectVideo();
  };

  VideoMgr.reset = function() {
    isReseting = true;
    VideoMgr.stopAll();
    for (var i = 0; i < VideoMgr.items.length; i++) {
      var ele = VideoMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      ele.reset();
    }
    if (_auditioningInstance) {
      _auditioningInstance.reset();
    }
    resetAllDirectVideo();
    isReseting = false;
  };

  VideoMgr.resize = function() {
    isResizing = true;
    for (var i = 0; i < VideoMgr.items.length; i++) {
      var ele = VideoMgr.items[i]; // 保留下来，避免正在resume的时候， 播完了， 被remove
      if (ele.instance) {
        ele.instance.resize();
      }
    }
    if (_auditioningInstance) {
      _auditioningInstance.resize();
    }
    isResizing = false;
  };

  VideoMgr.close = function() {
    if (!VideoMgr.isSupported) return;
    VideoMgr.stopAll();
    VideoMgr.removeAll();
    VideoMgr.items.splice(0); // 在退出微创意的时候，清除跨场景声音
    VideoMgr.started = false;
  };

  TQ.VideoMgr = VideoMgr;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 移动操作器
 */

window.TQ = window.TQ || {};

(function() {
  var StageBuffer = function() {
  };
  StageBuffer.isBatchMode = false; // by default, it's not batchMode, i.e. closed,
  StageBuffer.members = [];
  StageBuffer.open = function() { StageBuffer.isBatchMode = true; };
  StageBuffer.close = function() {
    StageBuffer.flush();
    StageBuffer.isBatchMode = false;
  };

  /*
    求上边界： 即: 在zIndex > z的范围中， 求最小的zIndex（在上边最靠近z）。
     */
  StageBuffer.findUpperBoundary = function(z) {
    if ((!currScene) || (!currScene.currentLevel) || (!currScene.currentLevel.elements)) {
      return null;
    }
    if (z === -1) { // group 物体， 不需要进入stage
      return null;
    }
    return TQ.MathExt.findUpperBoundary(currScene.currentLevel.elements, z);
  };

  StageBuffer.add = function(ele) {
    if (ele.isHighlighter()) { // 亮显元素， 不加入到stage中
      return;
    }

    if (StageBuffer.isBatchMode) {
      StageBuffer.members.push(ele);
    } else {
      var upperEle = StageBuffer.findUpperBoundary(ele.jsonObj.zIndex);
      ele._doAddItemToStage(upperEle);
    }
  };

  StageBuffer.flush = function() {
    assertTrue(TQ.Dictionary.MustBeBatchMode, StageBuffer.isBatchMode);
    if (StageBuffer.members.length > 0) {
      StageBuffer.members.sort(TQ.Element.compare);
      var ele = StageBuffer.members[0];
      var upperEle = StageBuffer.findUpperBoundary(ele.jsonObj.zIndex);
      for (var i = 0; i < StageBuffer.members.length; i++) {
        ele = StageBuffer.members[i];
        ele._doAddItemToStage(upperEle, true);
      }
      StageBuffer.members.splice(0);
    }
  };

  StageBuffer.isEmpty = function() {
    return StageBuffer.members.length <= 0;
  };

  TQ.StageBuffer = StageBuffer;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

(function() {
  var _rootBoneDefault = {};
  _rootBoneDefault.x = 0;
  _rootBoneDefault.y = 0;
  _rootBoneDefault.sx = 1;
  _rootBoneDefault.sy = 1;
  _rootBoneDefault.rotation = 0;
  _rootBoneDefault.alpha = 1;
  _rootBoneDefault.color = TQ.Config.color;
  _rootBoneDefault.M = TQ.Matrix2D.I();
  _rootBoneDefault.IM = TQ.Matrix2D.I(); // Inverse Matrix, 逆矩阵

  var poseDefault = {};
  function Pose() {}
  Pose.x = poseDefault.x = 0;
  Pose.y = poseDefault.y = 0;
  Pose.rotation = poseDefault.rotation = 0;
  Pose.sx = poseDefault.sx = 1;
  Pose.sy = poseDefault.sy = 1;
  Pose.visible = poseDefault.visible = 1;
  Pose.alpha = poseDefault.alpha = 1;
  Pose.color = poseDefault.color = TQ.Config.color;

  Pose.action = poseDefault.action = "idle";

  Pose.worldToObject = function(poseWorld, parentPoseWorld) {
    // 这是反变换:  世界坐标  ==> 物体坐标. 用于拍摄记录物体的操作, 不是播放.
    // 其中, 世界坐标中的参数, 必须完整.
    //   例如: 如果是平移变换, 那么只有平移变换的值是有意义的.
    //  其余参数, 如: 角度, 比例, 等等, 都是由以前的动画轨迹计算得来的, 保持不变即可.
    //   所以可以做到: 有选择地拍摄, 录制.

    // Pose 是一个公共的地方, 你不赋值, 它就是上一个elemenet留下的.
    if (parentPoseWorld == null) {
      parentPoseWorld = _rootBoneDefault;
    }
    if (parentPoseWorld.IM === undefined) {
      // 父矩阵是上一个迭代计算的, 对应拍摄的第一时刻, 没有.
      // 而且, 在播放的时候, 会生成新的M, 并清除上一个时刻的IM
      // ToDo:优化 如果正在拍摄, 可以直接利用拍摄的计算结果, 少算一次变换和矩阵.
      assertValid(TQ.Dictionary.ParentMatrixFromLastIteration, parentPoseWorld.M);
      parentPoseWorld.IM = parentPoseWorld.M.inverse();
    }
    assertValid(TQ.Dictionary.ParentMatrixFromLastIteration, parentPoseWorld.IM);
    var V = parentPoseWorld.IM.multiply($V([poseWorld.x, poseWorld.y, 1]));
    Pose.x = V.elements[0];
    Pose.y = V.elements[1];
    TQ.Assert.isTrue(!isNaN(Pose.x), "x 为 NaN！！！");
    TQ.Assert.isTrue(!isNaN(Pose.y), "y 为 NaN！！！");
    if ((V.elements[2] < 0.99) || (V.elements[2] > 1.01)) {
      assertEqualsDelta(TQ.Dictionary.INVALID_PARAMETER, 1, V.elements[2], 0.01); // 齐次分量应该近似为1
    }
  };

  Pose.tsrWorld2Object = function(ele) {
    var tsrWorld = ele.jsonObj;
    var originObj = ele.parentWorld2Object(tsrWorld);
    var parentTsrWorld = (!ele.parent || !ele.parent.jsonObj) ? _rootBoneDefault : ele.parent.jsonObj; // 获取上个函数的修改（改 null为有意义的值）

    var tsrObj = Pose;
    tsrObj.x = originObj.x;
    tsrObj.y = originObj.y;
    tsrObj.rotation = tsrWorld.rotation - parentTsrWorld.rotation;
    tsrObj.sx = tsrWorld.sx / parentTsrWorld.sx;
    tsrObj.sy = tsrWorld.sy / parentTsrWorld.sy;
    tsrObj.visible = tsrWorld.isVis;
    tsrObj.color = tsrWorld.color;
    tsrObj.alpha = tsrWorld.alpha;

    // 维护矩阵, 供子孙使用
    var M = TQ.Matrix2D.transformation(tsrObj.x, tsrObj.y, tsrObj.rotation, tsrObj.sx, tsrObj.sy);
    tsrWorld.M = parentTsrWorld.M.multiply(M);
    tsrWorld.IM = tsrWorld.M.inverse();
    assertNotNull(tsrWorld.IM); // 好习惯, 检查重要数据的出口, 确保是合格的
  };
  TQ.poseDefault = poseDefault;
  TQ.Pose = Pose;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 动画轨迹， 只是数据， 没有操作. 操作完全来自 AnimeController
 */
window.TQ = window.TQ || {};

(function() {
  function Channel(value, interpolationStyle) {
    if ((value === undefined) || (value == null)) {
      value = 0;
    }

    if (interpolationStyle === undefined) {
      interpolationStyle = TQ.Channel.LINE_INTERPOLATION;
    }

    this.initialize(value, interpolationStyle);
  }

  Channel.LINE_INTERPOLATION = 1;
  Channel.JUMP_INTERPOLATION = 0;

  var p = Channel.prototype;
  p.t = [];
  p.value = [];
  p.c = [];
  p.initialize = function(value, interpolationStyle) {
    if ((value.value === undefined) || (value.value == null)) {
      var t = (TQ.Config.insertAtT0On ? 0 : TQ.FrameCounter.tGrid());
      this.t = [t]; // 只有一帧, 不能搞出来2
      this.value = [value];
      this.c = [interpolationStyle];
    } else {
      this.t = value.t;
      this.value = value.value;
      this.c = value.c;
      if (value.sags) {
        this.sags = value.sags;
      }
    }

    this.tid1 = 0; // 这是2个临时变量，现在是fixedUp阶段，不需要恢复存盘前的 tid1、2,
    this.tid2 = 0;
  };

  p.record = function(track, t, v, interpolationMethod) {
    assertNotUndefined(TQ.Dictionary.FoundNull, this.tid1);
    assertNotNull(TQ.Dictionary.FoundNull, this.tid1);
    interpolationMethod = (interpolationMethod == null) ? TQ.Channel.LINE_INTERPOLATION : interpolationMethod;
    this.searchInterval(t, this);
    var tid1 = this.tid1;
    var tid2 = this.tid2;

    // 相等的情况, 只修改原来帧的值, 不增加新的帧
    var EPSILON = 0.025;
    var rewrite = false;
    if (this.hasSag()) {
      id = 0;
      rewrite = true;
    } else if (Math.abs(t - this.t[tid1]) < EPSILON) {
      id = tid1;
      rewrite = true;
    } else if (Math.abs(t - this.t[tid2]) < EPSILON) {
      id = tid2;
      rewrite = true;
    }

    if (rewrite) {
      this.value[id] = v;
      this.c[id] = interpolationMethod;
      return v;
    }

    // 以下添加新的帧
    var id = tid2; // 在tid2位置插入: 正好查到区间内 [t1, t, t2]
    if (t >= this.t[tid2]) { // 在末尾插入 [t1, t2, t]
      id = tid2 + 1;
    } else if (t < this.t[tid1]) { // 在前面插入 [t, t1, t2]
      id = tid1;
    }

    // 直接记录, 不优化
    this.t.splice(id, 0, t);
    this.c.splice(id, 0, interpolationMethod);
    this.value.splice(id, 0, v);
    return v;
  };

  p.searchInterval = function(t) {
    assertValid(TQ.Dictionary.INVALID_PARAMETER, this.tid1); // "有效的数组下标"
    // 处理特殊情况, 只有1帧:
    if (this.t.length <= 1) {
      assertTrue(TQ.Dictionary.INVALID_PARAMETER, this.tid1 === 0); // 只有1帧
      this.tid1 = this.tid2 = 0;
      return;
    }

    // 确定下边界: t1, 比 t小
    var tid1 = this.tid1;
    if (t < this.t[tid1]) {
      for (; t <= this.t[tid1]; tid1--) {
        if (tid1 <= 0) {
          tid1 = 0;
          break;
        }
      }
    }
    var tid2 = TQ.MathExt.range(tid1 + 1, 0, (this.t.length - 1));

    // 确定上边界: t2, 比 t大, 同时,容错, 跳过错误的轨迹数据, 在中间的
    if (t > this.t[tid2]) { //  1) 下边界太小了, 不是真正的下边界; 2) 在录制时间段之外;
      for (; t > this.t[tid2]; tid2++) {
        if (this.t[tid1] > this.t[tid2]) {
          // TQ.Log.out("data error, skip t=" + t + " t1=" + this.t[tid1] +" t2 = " + this.t[tid2] +" id1=" +tid1 + " tid2=" +tid2);
        }
        if (tid2 >= (this.t.length - 1)) {
          tid2 = this.t.length - 1;
          break;
        }
      }
    }

    tid1 = TQ.MathExt.range(tid2 - 1, 0, (this.t.length - 1));
    if (this.t[tid1] > this.t[tid2]) { // 容错, 发现错误的轨迹数据, 在末尾
      // TQ.Log.out("data error, skip t=" + t + " t1=" + this.t[tid1] +" t2 = " + this.t[tid2] +" id1=" +tid1 + " tid2=" +tid2);
      tid2 = tid1;
    }
    this.tid1 = tid1;
    this.tid2 = tid2;
  };

  p.trim = function(t1, t2) {
    if (this.hasSag()) {
      return this.trimSags(t1, t2);
    }

    var id1, id2;
    this.searchInterval(t1);
    id1 = this.tid1;
    this.searchInterval(t2);
    id2 = this.tid2;
    if ((id1 > id2) || (id2 === 0)) { // 空的channel，
      return;
    }

    if (t1 < this.t[id1]) { // 左出界
      id1--; // 减1， 确保[0]被cut
    }

    if (this.t[id2] < t2) { // 右出界
      var BIG_NUMBER = 65535;// 因为自动拍摄的数据量很大，
      id2 += BIG_NUMBER; // 大的数字， 确保都cut掉
    }
    // 要保留tid1, 也要保留tid2，中间的n=tid2- tid1 - 1不保存
    if ((id1 + 1) < this.t.length) {
      this.t.splice(id1 + 1, id2 - id1 - 1);
      this.value.splice(id1 + 1, id2 - id1 - 1);
      this.c.splice(id1 + 1, id2 - id1 - 1);
    }

    var tArray = this.t;
    var dt = t2 - t1;
    for (var i = 0; i < tArray.length; i++) {
      if (tArray[i] > t1) {
        tArray[i] -= dt;
      }
    }

    // maintain tid1,tid2
    if (this.t.length <= 1) {
      this.tid1 = this.tid2 = 0;
    }

    if (t1 < 0) {
      t1 = 0;
    }

    this.searchInterval(t1);
  };

  p.trimSags = function(t1, t2) {
    var self = this;
    var hasSag = false;
    var dt = t2 - t1;
    this.sags.forEach(function(sag) {
      if (sag) {
        if (((sag.t1 < t1) && (t1 < sag.t2)) ||
                    ((sag.t1 < t2) && (t2 < sag.t2))) {
          self.removeOneSag(sag.categoryId, sag.typeId);
        } else {
          hasSag = true;
          if (t1 < sag.t1) {
            sag.t1 -= dt;
            sag.t2 -= dt;
          }
        }
      }
    });

    if (!hasSag) {
      delete (this.sags);
    }
  };

  p.erase = function() {
    // 功能单一化， 只是擦除数组中原有的内容，比重新建立新数组要省内存，免回收
    // 只保留t0的数据，如果t0不是当前time， 则可能自动添加当前
    if (this.t) {
      this.t.splice(1);
    }
    if (this.value) {
      this.value.splice(1);
    }

    if (this.c) {
      this.c.splice(1);
    }

    if (this.hasSags) {
      this.sags.splice(1);
    }

    this.tid1 = 0; // 这是2个临时变量，现在是fixedUp阶段，不需要恢复存盘前的 tid1、2,
    this.tid2 = 0;
  };

  p.reset = function() {
    this.t = [this.t[0]]; // 只有一帧, 不能搞出来2
    this.value = [this.value[0]];
    this.c = [1];
    this.tid1 = 0;
    this.tid2 = 0;
  };

  p.removeOneSag = function(categoryId, typeId) {
    if (!this.sags || this.sags.length <= 0) {
      return;
    }

    var n = this.sags.length;
    for (let i = 0; i < n; i++) {
      var item = this.sags[i];
      if (!item) {
        continue;
      }

      if ((item.categoryId === categoryId) && (item.typeId === typeId)) {
        this.sags[i] = null;
        return this.sags[i];
      }
    }
  };

  p.calculateLastFrame = function() {
    var tMax = 0;
    var tInMax = 0;
    var tIdleMax = 0;
    var tOutMax = 0;
    if (this.sags) {
      this.sags.forEach(function(sag) {
        if (sag) {
          switch (sag.categoryId) {
            case TQ.AnimationManager.SagCategory.IN:
              tInMax = Math.max(tInMax, sag.t2);
              break;
            case TQ.AnimationManager.SagCategory.IDLE:
              if (!isNaN(sag.t2)) {
                tIdleMax = Math.max(tIdleMax, sag.t2);
              }
              break;
            case TQ.AnimationManager.SagCategory.OUT:
              if (!isNaN(sag.t2)) {
                tOutMax = Math.max(tOutMax, sag.t2);
              }
              break;
            default :
              break;
          }
        }
      });

      tMax = Math.max(Math.max(tInMax, tIdleMax), tOutMax);
      return tMax;
    }

    if (!this.t) {
      return tMax;
    }
    var num = this.t.length;
    tMax = this.t[0];
    if (num > 1) { // 数据合理性检查
      for (var i = 1; i < num; i++) {
        tMax = Math.max(tMax, this.t[i]);
      }
    }

    tMax = this.t[num - 1];
    return tMax;
  };

  p.adjustIdleSagT1 = function(newT1) {
    if (!this.sags || this.sags.length <= 0) {
      return;
    }

    var idleSag = this.sags[TQ.AnimationManager.SagCategory.IDLE];
    if (idleSag) {
      var dt = newT1 - idleSag.t1;
      idleSag.t1 = newT1;
      idleSag.t2 += dt;
    }
  };

  p.getSags = function() {
    if (!this.sags) {
      return null;
    }

    var sags = [];
    for (const item in TQ.AnimationManager.SagCategory) {
      var sagType = TQ.AnimationManager.SagCategory[item];
      const sag = this.sags[sagType];
      if (sag) {
        sags[sagType] = sag;
      }
    }

    if (sags.length > 0) {
      return sags;
    }
    return null;
  };

  p.hasSag = function() {
    return (this.sags && this.sags.length > 0);
  };

  Channel.upgradeTo3_8 = function(channel) {
    if (channel && channel.sags) {
      for (const sagType in channel.sags) {
        var oneSag = channel.sags[sagType];
        if (oneSag) {
          if (oneSag.categoryID !== undefined) {
            oneSag.categoryId = oneSag.categoryID;
            delete oneSag.categoryID;
          }
          if (oneSag.typeID !== undefined) {
            oneSag.typeId = oneSag.typeID;
            delete oneSag.typeID;
          }
        }
      }
    }
  };
  TQ.OneChannel = Channel;
  TQ.Channel = Channel;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 动画轨迹， 只是数据， 没有操作. 操作完全来自 AnimeController
 */
TQ = TQ || {};

(function() {
  function AnimeTrack(desc) {
    this.initialize(desc);
  }
  var FALSE_NUM_0 = 0; // false
  var TRUE_NUM_1 = 1;
  var DEFAULT_SAG_IDLE_LENGTH = 0; // 每个元素，最少持续5s钟（包括入场，idle和出场）
  var p = AnimeTrack.prototype;
  p.erase = function(track) {
    if (this.x) this.x.erase();
    if (this.y) this.y.erase();
    if (this.rotation) this.rotation.erase();
    if (this.sx) this.sx.erase();
    if (this.sy) this.sy.erase();
    if (this.visible) this.visible.erase();
  };

  p.initialize = function(desc) {
    assertNotNull(TQ.Dictionary.FoundNull, desc); // 应该在element已经验证了, 补全了
    assertNotNull(TQ.Dictionary.FoundNull, desc.x);
    assertNotNull(TQ.Dictionary.FoundNull, desc.y);
    assertNotNull(TQ.Dictionary.FoundNull, desc.rotation);
    assertNotNull(TQ.Dictionary.FoundNull, desc.sx);
    assertNotNull(TQ.Dictionary.FoundNull, desc.sy);
    assertNotNull(TQ.Dictionary.FoundNull, desc.alpha);
    assertNotNull(TQ.Dictionary.FoundNull, desc.color);
    if (!desc.animeTrack) {
      desc.animeTrack = {};
    }

    this.hasSag = !!desc.animeTrack.hasSag;

    if (!desc.animeTrack.x) {
      this.x = new TQ.OneChannel(desc.x);
    } else {
      this.x = new TQ.OneChannel(desc.animeTrack.x);
    }

    if (!desc.animeTrack.y) {
      this.y = new TQ.OneChannel(desc.y);
    } else {
      this.y = new TQ.OneChannel(desc.animeTrack.y);
    }

    if (!desc.animeTrack.rotation) {
      this.rotation = new TQ.OneChannel(desc.rotation);
    } else {
      this.rotation = new TQ.OneChannel(desc.animeTrack.rotation);
    }

    if (!desc.animeTrack.sx) {
      this.sx = new TQ.OneChannel(desc.sx);
    } else {
      this.sx = new TQ.OneChannel(desc.animeTrack.sx);
    }

    if (!desc.animeTrack.sy) {
      this.sy = new TQ.OneChannel(desc.sy);
    } else {
      this.sy = new TQ.OneChannel(desc.animeTrack.sy);
    }

    if (!desc.animeTrack.alpha) {
      this.alpha = new TQ.OneChannel(desc.alpha);
    } else {
      this.alpha = new TQ.OneChannel(desc.animeTrack.alpha);
    }

    if (!desc.animeTrack.colorR) {
      this.colorR = new TQ.OneChannel(TQ.Utility.getColorR(desc.color));
      this.colorG = new TQ.OneChannel(TQ.Utility.getColorG(desc.color));
      this.colorB = new TQ.OneChannel(TQ.Utility.getColorB(desc.color));
    } else {
      this.colorR = new TQ.OneChannel(desc.animeTrack.colorR);
      this.colorG = new TQ.OneChannel(desc.animeTrack.colorG);
      this.colorB = new TQ.OneChannel(desc.animeTrack.colorB);
    }

    if (!desc.animeTrack.visible) { // 即时添加的元素
      this.visible = new TQ.OneChannel(desc.isVis ? TRUE_NUM_1 : FALSE_NUM_0, TQ.Channel.JUMP_INTERPOLATION);
      if (!TQ.Config.insertAtT0On && !TQ.FrameCounter.isAtBeginning()) {
        this.visible.record(this, 0.0, FALSE_NUM_0, TQ.Channel.JUMP_INTERPOLATION);
      }
    } else { // 从文件中读入的元素
      this.visible = new TQ.OneChannel(desc.animeTrack.visible);
    }

    // action, 如果有，则建立它； 如果没有， 不补充；
    if ((desc.animeTrack) && (desc.animeTrack.action)) {
      this.action = new TQ.OneChannel(desc.animeTrack.action);
    }
  };

  p.trim = function(t1, t2) {
    var self = this;
    t1 = TQ.FrameCounter.gridSnap(t1);
    t2 = TQ.FrameCounter.gridSnap(t2);
    Object.keys(this).forEach(function(prop) {
      if (self[prop] instanceof TQ.Channel) {
        self[prop].trim(t1, t2);
      }
    });
  };

  p.getSags = function() {
    var sags = null;
    this.forEachChannel(function(channel) {
      var channelSags = channel.getSags();
      if (channelSags) {
        if (!sags) {
          sags = [];
        }
        sags.push(channelSags);
      }
    });

    return sags;
  };

  p.getInSag = function() {
    var sags = this.getSags();
    var sag = null;
    if (sags && sags.length > 0) {
      sags.some(function(channelSags) {
        return (channelSags && (sag = channelSags[TQ.AnimationManager.SagCategory.IN]));
      });
    }
    return sag;
  };

  AnimeTrack.validate = function(tracks) {
    AnimeTrack._validateOne(tracks.x);
    AnimeTrack._validateOne(tracks.y);
    AnimeTrack._validateOne(tracks.rotation);
    AnimeTrack._validateOne(tracks.sx);
    AnimeTrack._validateOne(tracks.sy);
    AnimeTrack._validateOne(tracks.visible);
    AnimeTrack._validateOne(tracks.alpha);
    AnimeTrack._validateOne(tracks.colorR);
    AnimeTrack._validateOne(tracks.colorG);
    AnimeTrack._validateOne(tracks.colorB);
  };

  p.forEachChannel = function(callback) {
    var prop;
    var channel;
    var self = this;

    for (prop in self) {
      channel = self[prop];
      if (channel instanceof TQ.OneChannel) {
        callback(channel);
      }
    }
  };

  AnimeTrack._validateOne = function(channel) {
    channel.tid1 = (channel.tid1 === undefined) ? 0 : channel.tid1;
    channel.tid2 = (channel.tid2 === undefined) ? 0 : channel.tid2;
  };

  p.calculateLastFrame = function() {
    var tMax = 0;
    this.forEachChannel(function(channel) {
      tMax = Math.max(tMax, channel.calculateLastFrame());
    });

    // /基本假设：
    // * 对于SAG，  此时的tMax只是tInSagMax， 没有包括idleSag的时间
    // * SAG和自由绘制的动画是互斥的， 每个元素只能选其一，不能混合
    // * SAG元素的idle时间是弹性的，= 场景总长度 - 本元素inSagMax， 但是， 最少 5s (防止，简单场景只有进场， 没有停留时间)
    if (this.hasSag) {
      var tIdleDuration = DEFAULT_SAG_IDLE_LENGTH / 1000;
      tMax = tMax + tIdleDuration;
    }

    return tMax;
  };

  AnimeTrack.hideToNow = function(ele, t) {
    t = TQ.FrameCounter.gridSnap(t);
    changeVisibility(ele, 0, FALSE_NUM_0, t, TRUE_NUM_1);
  };

  AnimeTrack.hide = function(ele, t) {
    t = TQ.FrameCounter.gridSnap(t);
    changeVisibility(ele, 0, FALSE_NUM_0, t, FALSE_NUM_0);
  };

  AnimeTrack.unHide = function(ele, t) {
    t = TQ.FrameCounter.gridSnap(t);
    changeVisibility(ele, 0, FALSE_NUM_0, t, TRUE_NUM_1);
  };

  function changeVisibility(ele, t1, vis1, t2, vis2) {
    var track = ele.animeTrack;
    t1 = TQ.FrameCounter.gridSnap(t1);
    t2 = TQ.FrameCounter.gridSnap(t2);
    track.visible.record(track, t1, vis1, TQ.Channel.JUMP_INTERPOLATION);
    track.visible.record(track, t2, vis2, TQ.Channel.JUMP_INTERPOLATION);
  }

  AnimeTrack.setButton = function(ele, t) {
    var lifeTime = 3 / 20; // 3 frame;
    t = TQ.FrameCounter.gridSnap(t);
    ele.animeTrack.visible.reset();
    AnimeTrack.hideToNow(ele, t);
    var track = ele.animeTrack;
    track.visible.record(track, t + lifeTime, FALSE_NUM_0, TQ.Channel.JUMP_INTERPOLATION);
  };

  p.updateSagFlag = function() {
    this.hasSag = this.x.hasSag() ||
            this.y.hasSag() ||
            this.sx.hasSag() ||
            this.sy.hasSag() ||
            this.rotation.hasSag() ||
            this.alpha.hasSag() ||
            this.visible.hasSag() ||
            this.colorR.hasSag() ||
            this.colorG.hasSag() ||
            this.colorB.hasSag();
  };

  AnimeTrack.upgradeTo3_8 = function(track) {
    if (!track.hasSag) {
      return;
    }

    TQ.Channel.upgradeTo3_8(track.y);
    TQ.Channel.upgradeTo3_8(track.sx);
    TQ.Channel.upgradeTo3_8(track.sy);
    TQ.Channel.upgradeTo3_8(track.rotation);
    TQ.Channel.upgradeTo3_8(track.alpha);
    TQ.Channel.upgradeTo3_8(track.visible);
    TQ.Channel.upgradeTo3_8(track.colorR);
    TQ.Channel.upgradeTo3_8(track.colorG);
    TQ.Channel.upgradeTo3_8(track.colorB);
  };
  TQ.AnimeTrack = AnimeTrack;
})();

/**
 * Created by Andrewz on 8/15.
 * 实现简单动画中的弹簧效果，阻尼damping，衰减attenuation
 *    Y = Y1*Y2
 *    Y1 = A * e^(-lambda * t)
 *    Y2 = cos(W * t + phi)
 *  *入口： 震荡的起始速度， 总震荡时间 (0.5秒)
 *   用2个周期T完成震荡
 */

var TQ = TQ || {};
TQ.SpringEffect = (function() {
  var PHI = -90 * Math.PI / 180;
  var defaultConfig = {
    actualSpeed: 1,
    dampingDuration: 0.4,
    numCycles: 2
  };

  return {
    defaultConfig: defaultConfig,
    cal: cal,
    getDampingT0: getDampingT0
  };

  /**
     * 入口：
     * @param sag
     *       actualSpeed: sag的速度，也是震荡的起始速度
     *       dampingDuration: 总震荡时间 (0.5秒),
     *       numCycles: 用N=4个周期T完成
     * @param deltaT: 震荡时间dt， deltaT = 0是震荡开始
     * @returns {number}: 震荡的位移（相对于目标位置）
     */
  function cal(sag, deltaT) {
    /** 主要公式
         * T = 总震荡时间/震荡周期数2
         * 最大振幅： A = 震荡的起始速度 * (1/4周期的时间)
         * 半衰减期时长0.693* Lambda(占1个周期T） :  ==> Lambda = T/0.693
         * 角速度： w = 2*PI*f = 2*PI * 1/T
         */
    var speed0 = sag.actualSpeed || defaultConfig.actualSpeed;
    var dampingDuration = sag.dampingDuration || defaultConfig.dampingDuration;
    var numCycles = sag.numCycles || defaultConfig.numCycles;
    var T = dampingDuration / numCycles;
    var A = speed0 * T / 4 / 5; var // 比 1/4周期，再缩小1/5, 幅度不能太大，
      lambda = 20 * T / 0.693; //* 增大20倍， 以快速衰减
    var w = 2 * Math.PI / T;
    var deltaY = 0;

    // 好数据：
    // A = 20;
    // lambda = 8;
    // w = 20;
    if (deltaT < dampingDuration) {
      var A1 = A * Math.pow(Math.E, -lambda * deltaT);
      deltaY = A1 * Math.cos(w * deltaT + PHI);
    }

    return deltaY;
  }

  function getDampingT0(sag) {
    var dampingDuration = (!sag || sag.dampingDuration === undefined) ? defaultConfig.dampingDuration
      : sag.dampingDuration;

    return sag.t2 - dampingDuration;
  }
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 *  解释动画轨迹的数据， 计算每一个时刻的姿态数据,
 */
window.TQ = window.TQ || {};

(function() {
  function TrackDecoder() {

  }

  /*  animeTrack(Object coordinate) ==> World coordinate
     *  插值t时刻的轨迹，并保存到时间坐标系（jsonObj）之中，供绘制
     *  animeTrack: 保存关节点的运动数据，是在父物体坐标系下， 而且是经过关节点改进的父物体坐标系）。
     *  jsonObj 是世界坐标系下的绝对运动数据，（可以直接送给绘图设备变换系统）
     *
     */
  // ToDo: 是否 参数 JSONObj可以省略？
  TrackDecoder.calculate = function(ele, t) {
    var track = ele.animeTrack;
    var tsrObj = TQ.Pose;
    // 计算本物体坐标系下的值
    tsrObj.rotation = ((track.rotation === undefined) || (track.rotation == null))
      ? TQ.poseDefault.rotation : TrackDecoder.calOneChannel(track, track.rotation, t);

    tsrObj.x = (!track.x)
      ? TQ.poseDefault.x : ensureObjectPos(ele.parent, calOneChannelExt(track, track.x, t), 0).x;
    TQ.Assert.isTrue(!isNaN(tsrObj.x), "x 为 NaN！！！");

    tsrObj.y = (!track.y)
      ? TQ.poseDefault.y : ensureObjectPos(ele.parent, 0, calOneChannelExt(track, track.y, t)).y;
    TQ.Assert.isTrue(!isNaN(tsrObj.y), "y 为 NaN！！！");

    tsrObj.sx = (!track.sx)
      ? TQ.poseDefault.sx : TrackDecoder.calOneChannel(track, track.sx, t);

    tsrObj.sy = (!track.sy)
      ? TQ.poseDefault.sy : TrackDecoder.calOneChannel(track, track.sy, t);

    tsrObj.visible = (!track.visible)
      ? TQ.poseDefault.visible : TrackDecoder.calOneChannel(track, track.visible, t);

    tsrObj.alpha = (!track.alpha)
      ? TQ.poseDefault.alpha : TrackDecoder.calOneChannel(track, track.alpha, t);

    var colorR = (!track.colorR)
      ? TQ.Utility.getColorR(TQ.poseDefault.color) : TrackDecoder.calOneChannel(track, track.colorR, t);

    var colorG = (!track.colorG)
      ? TQ.Utility.getColorG(TQ.poseDefault.color) : TrackDecoder.calOneChannel(track, track.colorG, t);

    var colorB = (!track.colorB)
      ? TQ.Utility.getColorB(TQ.poseDefault.color) : TrackDecoder.calOneChannel(track, track.colorB, t);

    tsrObj.color = TQ.Utility.RGB2Color(Math.round(colorR), Math.round(colorG), Math.round(colorB));

    TQ.Log.tsrDebugInfo("TSR in Object " + ele.jsonObj.type + ele.id, tsrObj);
  };

  TrackDecoder.calOneChannel = function(trackTBD, channel, t) {
    return calOneChannelExt(trackTBD, channel, t).value;
  };

  function calOneChannelExt(trackTBD, channel, t) {
    // ToDo: 在Sag控制的时间段，用SAG， 否则用普通的
    // * FlyIn: t < te;
    // * FlyOut: ts < t
    var floorSag = findSag(channel, t);
    var vSag;

    if (floorSag && floorSag.sag) {
      vSag = calSag(floorSag.sag, channel, t);
      if (floorSag.t1 <= t && t <= floorSag.t) {
        return { value: vSag, isSag: true };
      }
    }

    // ToDo: 没有track， 只有sag， 以sag的末尾状态保持下去
    // 在Sag结束的时候， 更新track， 以保存以sag的末尾状态保持下去
    var floorKfa = calTrack(channel, t);
    if (floorSag && floorSag.sag && (floorKfa.t2 < t) && (floorKfa.t2 < floorSag.t)) {
      return { value: vSag, isSag: true };
    }
    return { value: floorKfa.value, isSag: false };
  }

  function findSag(channel, t) {
    if (!channel.hasSag()) {
      return null;
    }

    var SagCategory = TQ.AnimationManager.SagCategory;
    var n = channel.sags.length;
    var item;
    var floorSag = {
      t: -1,
      sag: null
    };
    for (let i = 0; i < n; i++) {
      item = channel.sags[i];
      if (!item) {
        continue;
      }
      switch (item.categoryId) {
        case SagCategory.IN:
          if (t < item.t2) {
            floorSag.t1 = 0;
            floorSag.t = item.t2;
            floorSag.sag = item;
            return floorSag;
          } else {
            if (floorSag.t < item.t2) {
              floorSag.t1 = 0;
              floorSag.t = item.t2;
              floorSag.sag = item;
            }
          }
          break;
        case SagCategory.OUT:
          if (item.t1 < t) {
            floorSag.t1 = item.t1;
            floorSag.t = item.t2;
            floorSag.sag = item;
            return floorSag;
          } else {
            if (floorSag.t < item.t2) {
              floorSag.t1 = item.t1;
              floorSag.t = item.t2;
              floorSag.sag = item;
            }
          }
          break;
        default:
          if ((item.t1 <= t) && (t <= item.t2)) { // idle SAG
            floorSag.t1 = item.t1;
            floorSag.t = item.t2;
            floorSag.sag = item;
            return floorSag;
          } else {
            if ((t > item.t2) && (floorSag.t < item.t2)) {
              floorSag.t1 = item.t1;
              floorSag.t = item.t2;
              floorSag.sag = item;
            }
          }
      }
    }
    return floorSag;
  }

  function calSag(sag, channel, t) {
    if (!TQ.FrameCounter.isPlaying()) { // 编辑状态下， InSag显示其结果，idle和OutSag都显示其开始
      if (sag.categoryId === TQ.AnimationManager.SagCategory.IN) {
        t = sag.t2;
      } else {
        t = sag.t1;
      }
    }

    if (sag.categoryId === TQ.AnimationManager.SagCategory.IDLE) {
      return calIdleSag(sag, channel, t);
    }

    return calDumpSag(sag, channel, t);
  }

  function calDumpSag(sag, channel, t) {
    // 通用于各个SAG， x,y,z,   scale, rotation, alpha, etc
    var dampingT0 = TQ.SpringEffect.getDampingT0(sag);
    var deltaY = 0;
    if (t > dampingT0) { // 对于SAG结束后的状态， 保留SAG最后一刻的值
      if (t < sag.t2) {
        deltaY = TQ.SpringEffect.cal(sag, t - dampingT0);
      }
      t = dampingT0;
    } else if (t < sag.t1) {
      t = sag.t1;
    }
    return sag.value0 + (t - sag.t1) * sag.actualSpeed + deltaY;
  }

  function calVisible(sag, channel, t) {
    if (t > sag.t2) { // 确保在结束的时候， 屏幕上可见
      return 1;
    }

    var T = sag.hideT + sag.showT;
    var cycleNumber = Math.floor((t - sag.t1) / T);
    var thisCycle = t - sag.t1 - T * cycleNumber;
    if (thisCycle < sag.showT) {
      return 1;
    }
    return 0;
  }

  function calIdleSag(sag, channel, t) {
    if (TQ.FrameCounter.finished()) { // 播放结束之后， 复原
      t = 0;
    }
    if (sag.typeId === TQ.AnimationManager.SagType.TWINKLE) {
      return calVisible(sag, channel, t);
    }
    if (sag.typeId === TQ.AnimationManager.SagType.FLOAT_X) {
      return calFloatX(sag, channel, t);
    }
    if (sag.typeId === TQ.AnimationManager.SagType.ROTATE) {
      return calRotate(sag, channel, t);
    }
    return calDumpSag(sag, channel, t);
  }

  function calFloatX(sag, channel, t) {
    // 公式
    //    fx = (x0 + v*t)
    //    dl = xMax - xMin;
    //    fx2 = fx - Math.floor((fx - xMin) / dl) * dl;
    //

    var fx = sag.value0 + (t - sag.t1) * sag.actualSpeed;
    var xMin = sag.extraData.xMin;
    var dl = sag.extraData.xMax - xMin;

    return fx - Math.floor((fx - xMin) / dl) * dl;
  }

  function calRotate(sag, channel, t) {
    // 公式
    //    fx = (x0 + v*t)
    //    dl = 360;
    //    fx2 = fx - Math.floor(fx / dl) * dl;
    //

    var fx = sag.value0 + (t - sag.t1) * sag.actualSpeed;
    var dl = 360;

    return fx - Math.floor(fx / dl) * dl;
  }

  function calTrack(channel, t) {
    var floorKfa = {};
    channel.searchInterval(t);
    if (channel.tid1 === channel.tid2) {
      floorKfa.t1 = floorKfa.t2 = channel.t[channel.tid1];
      floorKfa.value = channel.value[channel.tid1];
      return floorKfa;
    }
    var t1 = channel.t[channel.tid1];
    var t2 = channel.t[channel.tid2];
    var v1 = channel.value[channel.tid1];
    var v2 = channel.value[channel.tid2];
    var v = v1; // 不插补， 脉冲替换, 适用于 正向播放， 不是倒放

    floorKfa.t1 = t1;
    floorKfa.t2 = t2;
    if (t1 > t2) { // 容错, 发现错误的轨迹数据
      TQ.Log.out("Data Error, Skip t=" + t + " t1=" + t1 + " t2 = " + t2 + " id1=" + channel.tid1 + " tid2=" + channel.tid2);
      floorKfa.value = v1;
      return floorKfa;
    }

    if (t <= t1) { // 下超界
      v = v1;
    } else if (t >= t2) { //  上超界，
      v = v2;
    } else {
      if (channel.c[channel.tid2] === TQ.Channel.LINE_INTERPOLATION) { // 0： interpolation
        v = ((t - t1) * (v1 - v2) / (t1 - t2)) + v1;
      } else {
        v = v1;
      }
    }
    floorKfa.value = v;
    return floorKfa;
  }

  function ensureObjectPos(eleParent, x, y) {
    var needToObject = false;
    if (typeof x === "object") {
      if (x.isSag) {
        needToObject = true;
      }
      x = x.value;
    }

    if (typeof y === "object") {
      if (y.isSag) {
        needToObject = true;
      }
      y = y.value;
    }

    var pos = { x: x, y: y };
    if (needToObject && eleParent) {
      pos = eleParent.world2Object(pos);
    }
    return pos;
  }

  TQ.TrackDecoder = TrackDecoder;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 *  记录每一个时刻的姿态数据,
 */
window.TQ = window.TQ || {};

(function() {
  function TrackRecorder() {

  }

  TrackRecorder.style = TQ.Channel.LINE_INTERPOLATION;
  TrackRecorder.initialize = function() {};

  // 参见: Decorder的说明
  TrackRecorder.record = function(element, t) {
    t = TQ.FrameCounter.gridSnap(t);
    var track = element.animeTrack;
    var jsonObj = element.jsonObj;
    // TQ.Pose 中已经是物体空间的值(在Update中调用的), 如果是成组的或者Bone运动,则是父物体坐标系下的值.
    // ToDo: 2 记录单个的操作, 而不是每次都记录所有的轨道

    // 记录本物体坐标系下的值
    if (!track) {
      // 第一次动画记录, 需要先初始化动画轨迹
      track = element.animeTrack = new TQ.AnimeTrack(jsonObj);
      assertNotUndefined(TQ.Dictionary.FoundNull, track);
    }

    TQ.AssertExt.invalidLogic(!!(track.x && track.y && track.sx && track.sy && track.rotation), "新case， 未赋值");
    if (element.hasFlag(TQ.Element.ROTATING)) {
      track.rotation.record(track, t, TQ.Pose.rotation, TrackRecorder.style);
    }

    if (element.hasFlag(TQ.Element.TRANSLATING)) {
      if (!element.isJoint() || TQ.InputCtrl.inSubobjectMode) {
        track.x.record(track, t, TQ.Pose.x, TrackRecorder.style);
      }
    }

    if (element.hasFlag(TQ.Element.TRANSLATING)) {
      if (!element.isJoint() || TQ.InputCtrl.inSubobjectMode) {
        track.y.record(track, t, TQ.Pose.y, TrackRecorder.style);
      }
    }

    if (element.hasFlag(TQ.Element.SCALING)) {
      if (!element.isJoint() || TQ.InputCtrl.inSubobjectMode) {
        track.sx.record(track, t, TQ.Pose.sx, TrackRecorder.style);
      }
    }

    if (element.hasFlag(TQ.Element.SCALING)) {
      if (!element.isJoint() || TQ.InputCtrl.inSubobjectMode) {
        track.sy.record(track, t, TQ.Pose.sy, TrackRecorder.style);
      }
    }

    if (element.hasFlag(TQ.Element.VISIBLE_CHANGED)) { // 允许改变关节物体各个关节的可见性
      track.visible.record(track, t, TQ.Pose.visible, TQ.Channel.JUMP_INTERPOLATION);
      element.clearFlag(TQ.Element.VISIBLE_CHANGED);
    }

    if (element.hasFlag(TQ.Element.ALPHAING)) {
      if (!element.isJoint() || TQ.InputCtrl.inSubobjectMode) {
        track.alpha.record(track, t, TQ.Pose.alpha, TrackRecorder.style);
      }
    }

    if (element.hasFlag(TQ.Element.COLOR_CHANGED)) {
      if (!element.isJoint() || TQ.InputCtrl.inSubobjectMode) {
        track.colorR.record(track, t, TQ.Utility.getColorR(TQ.Pose.color), TrackRecorder.style);
        track.colorG.record(track, t, TQ.Utility.getColorG(TQ.Pose.color), TrackRecorder.style);
        track.colorB.record(track, t, TQ.Utility.getColorB(TQ.Pose.color), TrackRecorder.style);
      }
    }

    if ((track.x.t.length > TQ.Config.MAX_KEYFRAME) ||
            (track.y.t.length > TQ.Config.MAX_KEYFRAME) ||
            (track.sx.t.length > TQ.Config.MAX_KEYFRAME) ||
            (track.sy.t.length > TQ.Config.MAX_KEYFRAME) ||
            (track.rotation.t.length > TQ.Config.MAX_KEYFRAME) ||
            (track.alpha.t.length > TQ.Config.MAX_KEYFRAME) ||
            (track.colorR.t.length > TQ.Config.MAX_KEYFRAME)) {
      TQ.MessageBox.toast(TQ.Locale.getStr("the animation of this element is out of limit!"));
    }

    element.clearFlag(TQ.Element.TRANSLATING | TQ.Element.ROTATING | TQ.Element.SCALING |
            TQ.Element.ALPHAING | TQ.Element.ZING | TQ.Element.VISIBLE_CHANGED | TQ.Element.COLOR_CHANGED);
  };

  // 参见: Decorder的说明
  TrackRecorder.recordSag = function(element, sags) {
    var track = element.animeTrack;
    TQ.AssertExt.invalidLogic(!!(track && track.x && track.y && track.sx && track.sy && track.rotation), "新case， 未赋值");
    var SagType = TQ.AnimationManager.SagType;
    var sag = sags[0];
    var sag2 = (sags.length >= 2) ? sags[1] : sag;

    switch (sag.typeId) {
      case SagType.FADE_IN:
      case SagType.FADE_OUT:
        recordOneSag(track.alpha, sag);
        break;

      case SagType.SCALE_IN:
      case SagType.SCALE_OUT:
        recordOneSag(track.sx, sag);
        recordOneSag(track.sy, sag2);
        break;

      case SagType.ROTATE:
        recordOneSag(track.rotation, sag);
        break;
      case SagType.LEFT_IN:
      case SagType.LEFT_OUT:
      case SagType.RIGHT_IN:
      case SagType.RIGHT_OUT:
      case SagType.FLOAT_X:
        recordOneSag(track.x, sag);
        break;

      case SagType.TOP_IN:
      case SagType.TOP_OUT:
      case SagType.BOTTOM_IN:
      case SagType.BOTTOM_OUT:
        recordOneSag(track.y, sag);
        break;

      case SagType.TWINKLE:
        recordOneSag(track.visible, sag);
        break;
      default:
        break;
    }

    switch (sag.categoryId) {
      case TQ.AnimationManager.SagCategory.IN:
        track.inSagType = sag.typeId;
        break;
      case TQ.AnimationManager.SagCategory.IDLE:
        track.idleSagType = sag.typeId;
        break;
      case TQ.AnimationManager.SagCategory.OUT:
      default:
        track.outSagType = sag.typeId;
    }

    track.hasSag = true;
    adjustIdleSagTime(track);
  };

  function adjustIdleSagTime(track) {
    var inSag = track.getInSag();
    var tInSagEnd = inSag ? inSag.t2 : 0;
    track.forEachChannel(function(channel) {
      channel.adjustIdleSagT1(tInSagEnd);
    });
  }

  TrackRecorder.removeSag = function(element, sag) {
    var track = element.animeTrack;
    var SagType = TQ.AnimationManager.SagType;
    var sagTypeId = sag.typeId;
    var SagCategoryId = sag.categoryId;
    switch (sagTypeId) {
      case SagType.FADE_IN:
      case SagType.FADE_OUT:
        track.alpha.removeOneSag(SagCategoryId, sagTypeId);
        break;

      case SagType.SCALE_IN:
      case SagType.SCALE_OUT:
        track.sx.removeOneSag(SagCategoryId, sagTypeId);
        track.sy.removeOneSag(SagCategoryId, sagTypeId);
        break;

      case SagType.ROTATE:
        track.rotation.removeOneSag(SagCategoryId, sagTypeId);
        break;
      case SagType.LEFT_IN:
      case SagType.LEFT_OUT:
      case SagType.RIGHT_IN:
      case SagType.RIGHT_OUT:
      case SagType.FLOAT_X:
        track.x.removeOneSag(SagCategoryId, sagTypeId);
        break;

      case SagType.TOP_IN:
      case SagType.TOP_OUT:
      case SagType.BOTTOM_IN:
      case SagType.BOTTOM_OUT:
        track.y.removeOneSag(SagCategoryId, sagTypeId);
        break;

      case SagType.TWINKLE:
        track.visible.removeOneSag(SagCategoryId, sagTypeId);
        break;
      default:
        break;
    }

    track.updateSagFlag();
  };

  TrackRecorder.recordOneChannel = function(track, channel, t, v, interpolationMethod) {
    assertDepreciated(TQ.Dictionary.isDepreciated + "， 移到了channel类中的record！");
    assertNotNull(TQ.Dictionary.FoundNull, channel);
    assertNotUndefined(TQ.Dictionary.FoundNull, channel.tid1);
    assertNotNull(TQ.Dictionary.FoundNull, channel.tid1);
    return channel.record(track, t, v, interpolationMethod);
  };

  function removeAllSags(element) {
    var track = element.animeTrack;
    track.alpha.sags = null;
    track.x.sags = null;
    track.y.sags = null;
    track.sx.sags = null;
    track.sy.sags = null;
    track.rotation.sags = null;
    track.visible.sags = null;
  }

  function getOneSag(track, sagTypeId) {
    if (!track.sags) {
      return false;
    }

    var sags = track.sags;
    var n = sags.length;
    for (let i = 0; i < n; i++) {
      var item = sags[i];
      if (!item) {
        continue;
      }

      if (item.typeId === sagTypeId) {
        return item;
      }
    }
    return false;
  }

  function recordOneSag(channel, sag) {
    // 相等的情况, 不修改原来帧的值, 只增加新的帧， 确保t只是增加的
    if (!channel.sags) {
      channel.sags = [];
    }

    channel.sags[sag.categoryId] = sag; // ToDo: 仅支持1个入场，1个出场动画，1个idle

    // track.sags.sort(compareSag);
  }

  function compareSag(sag1, sag2) {
    if (sag1.t1 > sag2.t1) {
      return 1;
    } else if (sag1.t1 < sag2.t1) {
      return -1;
    }
    return 0;
  }

  function trimOneChannel(channel, t) {
    // 处理特殊情况, 只有1帧:
    if (channel.t.length <= 1) {
      assertTrue(TQ.Dictionary.INVALID_PARAMETER, channel.tid1 === 0); // 只有1帧
      channel.tid1 = channel.tid2 = 0;
      return;
    }

    // 确定下边界: t1, 比 t小
    var tid1 = channel.t.length - 1;
    for (; t <= channel.t[tid1]; tid1--) {
      if (tid1 <= 0) {
        tid1 = 0;
        break;
      }
    }

    channel.value[tid1] = TQ.TrackDecoder.calOneChannel(null, channel, t);
    channel.t[tid1] = (TQ.Config.insertAtT0On ? 0 : t);
    channel.t = channel.t.splice(tid1, 1);
    channel.value = channel.value.splice(tid1, 1);
    channel.c = channel.c.splice(tid1, 1);
    channel.tid1 = channel.tid2 = 0;
  }

  TrackRecorder.removeAllSags = removeAllSags;
  TQ.TrackRecorder = TrackRecorder;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 *  解释动画轨迹的数据， 计算每一个时刻的姿态数据,
 */
window.TQ = window.TQ || {};

(function() {
  function ActionDecoder() {

  }

  ActionDecoder.calculate = function(track, t) {
    TQ.Pose.action = (!track.action)
      ? TQ.poseDefault.action : TQ.TrackDecoder.calOneChannel(track, track.action, t);

    if (!TQ.Pose.action) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, TQ.Pose.action);
      TQ.Pose.action = ActionDecoder._findValidName(track.action.value);
    }
    return TQ.Pose.action;
  };

  ActionDecoder._findValidName = function(names) {
    for (var i = 0; i < names.length; i++) {
      if (!names[i]) continue;
      return names[i];
    }
  };

  TQ.ActionDecoder = ActionDecoder;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 *  记录每一个时刻的姿态数据,
 */
window.TQ = window.TQ || {};

(function() {
  function ActionRecorder() {

  }
  ActionRecorder.style = TQ.Channel.LINE_INTERPOLATION;
  ActionRecorder.initialize = function() {};

  // 参见: Decorder的说明
  ActionRecorder.record = function(element, actionName, t) {
    var track = element.animeTrack;
    var jsonObj = element.jsonObj;
    t = TQ.FrameCounter.gridSnap(t);

    if (!actionName) {
      assertFalse(TQ.Dictionary.INVALID_LOGIC, !actionName);
      return;
    }

    // 记录本物体坐标系下的值
    if ((track === undefined) || (track == null)) {
      // 第一次动画记录, 需要先初始化动画轨迹
      track = element.animeTrack = new TQ.AnimeTrack(jsonObj);
      assertNotUndefined(TQ.Dictionary.FoundNull, track);
    }

    if (!track.action) {
      track.action = new TQ.OneChannel(actionName);
    } else {
      if (element.hasFlag(TQ.Element.ACTION_CHANGED)) { // 允许改变关节物体各个关节的可见性
        track.action.record(track, t, actionName, TQ.Channel.JUMP_INTERPOLATION);
        element.clearFlag(TQ.Element.ACTION_CHANGED);
      }
    }
  };

  TQ.ActionRecorder = ActionRecorder;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

// ToDo: 暂停期间 的时间，要去除， 确保， resume之后 的动作与pause时候的动作是连续播放的，
(function() {
  /**
     * Action: 动作， 表示一个动作的名称， 起始帧，结束帧，循环方式
     * 循环方式： -1： 无限循环， 0： 单帧， 1： 只播放1次， N： 播放N次。
     * @param name
     * @param startFrame
     * @param endFrame
     * @param repeatStyle
     * @param gifIconId
     * @constructor
     */
  function Action(name, startFrame, endFrame, repeatStyle, gifIconId) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, endFrame >= startFrame);
    assertFalse(TQ.Dictionary.INVALID_PARAMETER, !gifIconId);
    this.name = name;
    this.fs = startFrame; //  该动作 从 [ts, te]
    this.F = endFrame - startFrame; // 命令的时长,周长是 T
    this.n = 0; // 第一次播放，
    this.style = repeatStyle;
    this.state = Action.STOP;
    this.gifIconId = gifIconId;
    // this.initialize(jsonObj);
  }
  Action.STOP = 0;
  Action.PLAYING = 1;

  Action.STYLE_REPEAT = -1;
  Action.STYLE_1 = 1; //     只播放1次
  var p = Action.prototype;
  p.play = function(t) {
    this.tc = t; // 发布命令command的时间是 tc
    this.state = Action.PLAYING;
    this.T = this.F;
    this.ts = this.fs;
    this.tcn = this.tc + (this.n * this.T); // tcn 是周期性的tc， 第n次播放时的相对起点
    this.te = this.tcn + this.T;
  };

  p.tMapping = function(t) {
    if ((t < this.tcn) || (t > this.te)) { // 配合倒退， 重播，等, 确保 t 在区间[tcn, te]内
      if (this.style === Action.STYLE_REPEAT) { // 循环者， 修改tcn,te, n
        if (this.T > 0) {
          this.n = Math.floor((t - this.tc) / this.T);
          if (t < this.tc) {
            this.n -= 1;
          }
          this.tcn = this.tc + (this.n * this.T);
          this.te = this.tcn + this.T;
        } else {
          this.tcn = t;
          this.te = t;
        }
      } else { // 非循环者， 不修改tcn,te, n， 只限制t值在范围内
        t = TQ.MathExt.range(t, this.tcn, this.te);
      }
    }

    assertTrue(TQ.Dictionary.INVALID_PARAMETER, t >= this.tcn);
    return (this.ts + (t - this.tcn));
  };

  p.stop = function() {
    this.state = Action.STOP;
  };

  p.isPlaying = function() {
    return (this.state === Action.PLAYING);
  };

  TQ.Action = Action;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  /**
     * Animation, 是带有多个action的动作集合， Element是最多只有一个动作的元素。
     * @param jsonObj
     * @constructor
     */
  function Animation(jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string");
    this.currentAction = null;
    this.actionTable = [];
    this.fixedUp(jsonObj); // 用于从数据文件建立动画
  }

  var p = Animation.prototype;
  Animation.unitTest = function(ele) {
    ele.addAction("idle", 1, 50, TQ.Action.STYLE_REPEAT);
    ele.addAction("work", 60, 120, TQ.Action.STYLE_REPEAT);
    ele.addAction("run", 130, 150, TQ.Action.STYLE_REPEAT);
    ele.addAction("smile", 160, 180, TQ.Action.STYLE_1);
    ele.addAction("stand", 181, 200, TQ.Action.STYLE_1);
  };

  /*
    用于从数据文件建立动画
     */
  p.fixedUp = function(jsonObj) {
    if ((jsonObj != null) && (jsonObj.actionTable != null)) {
      for (var i = 0; i < jsonObj.actionTable.length; i++) {
        var actionJson = jsonObj.actionTable[i];
        var fs = Number(actionJson.fs);
        var fe = fs + Number(actionJson.F);
        if (!actionJson.gifIconId) {
          actionJson.gifIconId = TQ.Utility.getDefultActionIcon();
        }
        this.addAction(new TQ.Action(actionJson.name, fs, fe, actionJson.style, actionJson.gifIconId));
      }
    }
  };

  p.play = function(actionName) {
    this.currentAction = this._findAction(actionName);
    if (this.currentAction === TQ.ERROR) {
      TQ.MessageBubble.show(TQ.Dictionary.NAME_NOT_EXIST);
      if (actionName !== "idle") {
        this.play("idle");
      }
    } else {
      this.currentAction.play(TQ.FrameCounter.t());
    }
  };

  p.pause = function() {
    assertNotNull(TQ.Dictionary.INVALID_PARAMETER, this.currentAction);
    if (this.currentAction != null) {
      this.currentAction.stop();
    }
  };

  p.resume = function() {
    assertNotNull(TQ.Dictionary.INVALID_PARAMETER, this.currentAction);
    if (this.currentAction != null) {
      this.currentAction.resume();
    }
  };

  p.stop = function() {
    assertNotNull(TQ.Dictionary.INVALID_PARAMETER, this.currentAction);
    if (this.currentAction != null) {
      this.currentAction.stop();
      this.currentAction = null;
    }
  };

  p.addAction = function(action, forceToUpdate) {
    var id = this._findActionId(action.name);
    if (id !== TQ.ERROR) { // 避免重复同名的动作, （如果已经有同名的， 则替换之）
      if (!forceToUpdate) {
        return false;
      }
      this.actionTable[id] = action;
    } else {
      this.actionTable.push(action);
    }
    return true;
  };

  p.deleteAction = function(name) {
    var id = this._findActionId(name);
    if (id === TQ.ERROR) {
      TQ.MessageBubble.show(TQ.Dictionary.INVALID_PARAMETER + name);
    } else {
      this.actionTable.splice(id, 1);
    }
  };

  // private function
  p._findActionId = function(actionName) {
    for (var i = 0; i < this.actionTable.length; i++) {
      if (this.actionTable[i].name === actionName) {
        return i;
      }
    }

    return TQ.ERROR; // !!!不能是null, 因为它和[0]元素是一样的。
  };

  p._findAction = function(actionName) {
    var id = this._findActionId(actionName);
    if (id !== TQ.ERROR) {
      return this.actionTable[id];
    }
    return TQ.ERROR; // !!!不能是null, 因为它和[0]元素是一样的。
  };

  p.isAnimation = function() { return true; };
  p.isPlaying = function() { return ((this.currentAction != null) && (this.currentAction.isPlaying())); };
  p.hasAction = function(actionName) {
    return (this._findAction(actionName) !== TQ.ERROR);
  };

  TQ.Animation = Animation;
}());

/* Modernizr 2.6.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-cssanimations-csstransitions-touch-shiv-cssclasses-prefixed-teststyles-testprop-testallprops-prefixes-domprefixes-load
 */
window.Modernizr = (function(a, b, c) { function z(a) { j.cssText = a; } function A(a, b) { return z(m.join(a + ";") + (b || "")); } function B(a, b) { return typeof a === b; } function C(a, b) { return !!~("" + a).indexOf(b); } function D(a, b) { for (var d in a) { var e = a[d]; if (!C(e, "-") && j[e] !== c) return b == "pfx" ? e : !0; } return !1; } function E(a, b, d) { for (var e in a) { var f = b[a[e]]; if (f !== c) return d === !1 ? a[e] : B(f, "function") ? f.bind(d || b) : f; } return !1; } function F(a, b, c) { var d = a.charAt(0).toUpperCase() + a.slice(1); var e = (a + " " + o.join(d + " ") + d).split(" "); return B(b, "string") || B(b, "undefined") ? D(e, b) : (e = (a + " " + p.join(d + " ") + d).split(" "), E(e, b, c)); } var d = "2.6.2"; var e = {}; var f = !0; var g = b.documentElement; var h = "modernizr"; var i = b.createElement(h); var j = i.style; var k; var l = {}.toString; var m = " -webkit- -moz- -o- -ms- ".split(" "); var n = "Webkit Moz O ms"; var o = n.split(" "); var p = n.toLowerCase().split(" "); var q = {}; var r = {}; var s = {}; var t = []; var u = t.slice; var v; var w = function(a, c, d, e) { var f; var i; var j; var k; var l = b.createElement("div"); var m = b.body; var n = m || b.createElement("body"); if (parseInt(d, 10)) while (d--)j = b.createElement("div"), j.id = e ? e[d] : h + (d + 1), l.appendChild(j); return f = ["&#173;", "<style id=\"s", h, "\">", a, "</style>"].join(""), l.id = h, (m ? l : n).innerHTML += f, n.appendChild(l), m || (n.style.background = "", n.style.overflow = "hidden", k = g.style.overflow, g.style.overflow = "hidden", g.appendChild(n)), i = c(l, a), m ? l.parentNode.removeChild(l) : (n.parentNode.removeChild(n), g.style.overflow = k), !!i; }; var x = {}.hasOwnProperty; var y; !B(x, "undefined") && !B(x.call, "undefined") ? y = function(a, b) { return x.call(a, b); } : y = function(a, b) { return b in a && B(a.constructor.prototype[b], "undefined"); }, Function.prototype.bind || (Function.prototype.bind = function(b) { var c = this; if (typeof c !== "function") throw new TypeError(); var d = u.call(arguments, 1); var e = function() { if (this instanceof e) { var a = function() {}; a.prototype = c.prototype; var f = new a(); var g = c.apply(f, d.concat(u.call(arguments))); return Object(g) === g ? g : f; } return c.apply(b, d.concat(u.call(arguments))); }; return e; }), q.touch = function() { var c; return "ontouchstart" in a || a.DocumentTouch && b instanceof DocumentTouch ? c = !0 : w(["@media (", m.join("touch-enabled),("), h, ")", "{#modernizr{top:9px;position:absolute}}"].join(""), function(a) { c = a.offsetTop === 9; }), c; }, q.cssanimations = function() { return F("animationName"); }, q.csstransitions = function() { return F("transition"); }; for (var G in q)y(q, G) && (v = G.toLowerCase(), e[v] = q[G](), t.push((e[v] ? "" : "no-") + v)); return e.addTest = function(a, b) { if (typeof a === "object") for (var d in a)y(a, d) && e.addTest(d, a[d]); else { a = a.toLowerCase(); if (e[a] !== c) return e; b = typeof b === "function" ? b() : b, typeof f !== "undefined" && f && (g.className += " " + (b ? "" : "no-") + a), e[a] = b; } return e; }, z(""), i = k = null, (function(a, b) { function k(a, b) { var c = a.createElement("p"); var d = a.getElementsByTagName("head")[0] || a.documentElement; return c.innerHTML = "x<style>" + b + "</style>", d.insertBefore(c.lastChild, d.firstChild); } function l() { var a = r.elements; return typeof a === "string" ? a.split(" ") : a; } function m(a) { var b = i[a[g]]; return b || (b = {}, h++, a[g] = h, i[h] = b), b; } function n(a, c, f) { c || (c = b); if (j) return c.createElement(a); f || (f = m(c)); var g; return f.cache[a] ? g = f.cache[a].cloneNode() : e.test(a) ? g = (f.cache[a] = f.createElem(a)).cloneNode() : g = f.createElem(a), g.canHaveChildren && !d.test(a) ? f.frag.appendChild(g) : g; } function o(a, c) { a || (a = b); if (j) return a.createDocumentFragment(); c = c || m(a); var d = c.frag.cloneNode(); var e = 0; var f = l(); var g = f.length; for (;e < g; e++)d.createElement(f[e]); return d; } function p(a, b) { b.cache || (b.cache = {}, b.createElem = a.createElement, b.createFrag = a.createDocumentFragment, b.frag = b.createFrag()), a.createElement = function(c) { return r.shivMethods ? n(c, a, b) : b.createElem(c); }, a.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + l().join().replace(/\w+/g, function(a) { return b.createElem(a), b.frag.createElement(a), "c(\"" + a + "\")"; }) + ");return n}")(r, b.frag); } function q(a) { a || (a = b); var c = m(a); return r.shivCSS && !f && !c.hasCSS && (c.hasCSS = !!k(a, "article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}")), j || p(a, c), a; } var c = a.html5 || {}; var d = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i; var e = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i; var f; var g = "_html5shiv"; var h = 0; var i = {}; var j; (function() { try { var a = b.createElement("a"); a.innerHTML = "<xyz></xyz>", f = "hidden" in a, j = a.childNodes.length == 1 || (function() { b.createElement("a"); var a = b.createDocumentFragment(); return typeof a.cloneNode === "undefined" || typeof a.createDocumentFragment === "undefined" || typeof a.createElement === "undefined"; }()); } catch (c) { f = !0, j = !0; } })(); var r = { elements: c.elements || "abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video", shivCSS: c.shivCSS !== !1, supportsUnknownElements: j, shivMethods: c.shivMethods !== !1, type: "default", shivDocument: q, createElement: n, createDocumentFragment: o }; a.html5 = r, q(b); }(this, b)), e._version = d, e._prefixes = m, e._domPrefixes = p, e._cssomPrefixes = o, e.testProp = function(a) { return D([a]); }, e.testAllProps = F, e.testStyles = w, e.prefixed = function(a, b, c) { return b ? F(a, b, c) : F(a, "pfx"); }, g.className = g.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (f ? " js " + t.join(" ") : ""), e; }(this, this.document)), (function(a, b, c) { function d(a) { return o.call(a) == "[object Function]"; } function e(a) { return typeof a === "string"; } function f() {} function g(a) { return !a || a == "loaded" || a == "complete" || a == "uninitialized"; } function h() { var a = p.shift(); q = 1, a ? a.t ? m(function() { (a.t == "c" ? B.injectCss : B.injectJs)(a.s, 0, a.a, a.x, a.e, 1); }, 0) : (a(), h()) : q = 0; } function i(a, c, d, e, f, i, j) { function k(b) { if (!o && g(l.readyState) && (u.r = o = 1, !q && h(), l.onload = l.onreadystatechange = null, b)) { a != "img" && m(function() { t.removeChild(l); }, 50); for (var d in y[c])y[c].hasOwnProperty(d) && y[c][d].onload(); } } var j = j || B.errorTimeout; var l = b.createElement(a); var o = 0; var r = 0; var u = { t: d, s: c, e: f, a: i, x: j }; y[c] === 1 && (r = 1, y[c] = []), a == "object" ? l.data = c : (l.src = c, l.type = a), l.width = l.height = "0", l.onerror = l.onload = l.onreadystatechange = function() { k.call(this, r); }, p.splice(e, 0, u), a != "img" && (r || y[c] === 2 ? (t.insertBefore(l, s ? null : n), m(k, j)) : y[c].push(l)); } function j(a, b, c, d, f) { return q = 0, b = b || "j", e(a) ? i(b == "c" ? v : u, a, b, this.i++, c, d, f) : (p.splice(this.i++, 0, a), p.length == 1 && h()), this; } function k() { var a = B; return a.loader = { load: j, i: 0 }, a; } var l = b.documentElement; var m = a.setTimeout; var n = b.getElementsByTagName("script")[0]; var o = {}.toString; var p = []; var q = 0; var r = "MozAppearance" in l.style; var s = r && !!b.createRange().compareNode; var t = s ? l : n.parentNode; var l = a.opera && o.call(a.opera) == "[object Opera]"; var l = !!b.attachEvent && !l; var u = r ? "object" : l ? "script" : "img"; var v = l ? "script" : u; var w = Array.isArray || function(a) { return o.call(a) == "[object Array]"; }; var x = []; var y = {}; var z = { timeout: function(a, b) { return b.length && (a.timeout = b[0]), a; } }; var A; var B; B = function(a) { function b(a) { var a = a.split("!"); var b = x.length; var c = a.pop(); var d = a.length; var c = { url: c, origUrl: c, prefixes: a }; var e; var f; var g; for (f = 0; f < d; f++)g = a[f].split("="), (e = z[g.shift()]) && (c = e(c, g)); for (f = 0; f < b; f++)c = x[f](c); return c; } function g(a, e, f, g, h) { var i = b(a); var j = i.autoCallback; i.url.split(".").pop().split("?").shift(), i.bypass || (e && (e = d(e) ? e : e[a] || e[g] || e[a.split("/").pop().split("?")[0]]), i.instead ? i.instead(a, e, f, g, h) : (y[i.url] ? i.noexec = !0 : y[i.url] = 1, f.load(i.url, i.forceCSS || !i.forceJS && i.url.split(".").pop().split("?").shift() == "css" ? "c" : c, i.noexec, i.attrs, i.timeout), (d(e) || d(j)) && f.load(function() { k(), e && e(i.origUrl, h, g), j && j(i.origUrl, h, g), y[i.url] = 2; }))); } function h(a, b) { function c(a, c) { if (a) { if (e(a))c || (j = function() { var a = [].slice.call(arguments); k.apply(this, a), l(); }), g(a, j, b, 0, h); else if (Object(a) === a) for (n in m = (function() { var b = 0; var c; for (c in a)a.hasOwnProperty(c) && b++; return b; }()), a)a.hasOwnProperty(n) && (!c && !--m && (d(j) ? j = function() { var a = [].slice.call(arguments); k.apply(this, a), l(); } : j[n] = (function(a) { return function() { var b = [].slice.call(arguments); a && a.apply(this, b), l(); }; }(k[n]))), g(a[n], j, b, n, h)); } else !c && l(); } var h = !!a.test; var i = a.load || a.both; var j = a.callback || f; var k = j; var l = a.complete || f; var m; var n; c(h ? a.yep : a.nope, !!i), i && c(i); } var i; var j; var l = this.yepnope.loader; if (e(a))g(a, 0, l, 0); else if (w(a)) for (i = 0; i < a.length; i++)j = a[i], e(j) ? g(j, 0, l, 0) : w(j) ? B(j) : Object(j) === j && h(j, l); else Object(a) === a && h(a, l); }, B.addPrefix = function(a, b) { z[a] = b; }, B.addFilter = function(a) { x.push(a); }, B.errorTimeout = 1e4, b.readyState == null && b.addEventListener && (b.readyState = "loading", b.addEventListener("DOMContentLoaded", A = function() { b.removeEventListener("DOMContentLoaded", A, 0), b.readyState = "complete"; }, 0)), a.yepnope = k(), a.yepnope.executeStack = h, a.yepnope.injectJs = function(a, c, d, e, i, j) { var k = b.createElement("script"); var l; var o; var e = e || B.errorTimeout; k.src = a; for (o in d)k.setAttribute(o, d[o]); c = j ? h : c || f, k.onreadystatechange = k.onload = function() { !l && g(k.readyState) && (l = 1, c(), k.onload = k.onreadystatechange = null); }, m(function() { l || (l = 1, c(1)); }, e), i ? k.onload() : n.parentNode.insertBefore(k, n); }, a.yepnope.injectCss = function(a, c, d, e, g, i) { var e = b.createElement("link"); var j; var c = i ? h : c || f; e.href = a, e.rel = "stylesheet", e.type = "text/css"; for (j in d)e.setAttribute(j, d[j]); g || (n.parentNode.insertBefore(e, n), m(c, 0)); }; }(this, document)), Modernizr.load = function() { yepnope.apply(window, [].slice.call(arguments, 0)); };

/**
 * Created by Andrewz on 8/22/17.
 */
var TQ = TQ || {};
TQ.PageTransitionEffect = (function() {
  var isAnimating = false;
  var watchDogMaxTime = 2000; // 超过2000ms，还没有结束动画， 则迫使结束
  var watchDogTask = -1;
  var outPageEnd = false;
  var inPageEnd = false;
  var animEndEventNames = {
    "WebkitAnimation": "webkitAnimationEnd",
    "OAnimation": "oAnimationEnd",
    "msAnimation": "MSAnimationEnd",
    "animation": "animationend"
  };
    // animation end event name
  var animEndEventName = animEndEventNames[Modernizr.prefixed("animation")];
  // support css animations
  var support = Modernizr.cssanimations;
  var defaultEffectName = "rotateFoldLeft";
  var editorService;
  var effectsList = {
    "rotateFoldLeft": {
      outClass: "pt-page-rotateFoldLeft", // 左翻
      inClass: "pt-page-moveFromRightFade"
    },
    "rotateFoldRight": {
      outClass: "pt-page-rotateFoldRight", // 右翻
      inClass: "pt-page-moveFromLeftFade"
    },
    "rotateFoldTop pt-page-ontop": {
      outClass: "pt-page-rotateFoldTop pt-page-ontop", // 上翻
      inClass: "pt-page-moveFromBottomFade"
    },
    "rotateFoldBottom": {
      outClass: "pt-page-rotateFoldBottom", // 下翻
      inClass: "pt-page-moveFromTopFade"
    }
  };

  var state = {
    page1Image: null,
    page1On: false
  };

  return {
    state: state,
    doTransition: doTransition,
    getEffect: getEffect,
    init: init,
    isBusy: isBusy
  };

  function init() {
  }

  function doTransition(transition, callback) {
    var outPage = transition.outPage;
    var inPage = transition.inPage;
    editorService = angular.element(document.body).injector().get("EditorService");
    TQ.Log.debugInfo("page transition start...");
    isAnimating = true;
    watchDogTask = TQ.WatchDog.start(function() {
      if (isAnimating) { // 此变量是易变的， 所以，必须显式地clear dog
        onOutPageAnimeEnd();
        onInPageAnimeEnd();
      }
    }, watchDogMaxTime);

    state.page1On = true;
    outPage.on(animEndEventName, onOutPageAnimeEnd);

    function onOutPageAnimeEnd() {
      outPage.off(animEndEventName);
      outPageEnd = true;
      state.page1On = false;
      state.page1Image = null;
      if (inPageEnd) {
        onEndAnimation(transition, callback);
      }
    }

    attachEffect(outPage, transition.outClass);

    inPage.on(animEndEventName, onInPageAnimeEnd);
    function onInPageAnimeEnd() {
      inPage.off(animEndEventName);
      inPageEnd = true;
      if (outPageEnd) {
        onEndAnimation(transition, callback);
      }
    }

    attachEffect(inPage, transition.inClass);

    if (!support) {
      onEndAnimation(transition);
    }

    editorService.forceToRefreshUI();
  }

  function onEndAnimation(transition, callback) {
    outPageEnd = false;
    inPageEnd = false;
    isAnimating = false;
    TQ.Log.debugInfo("page transition end!");
    TQ.WatchDog.clear(watchDogTask);
    setTimeout(function() {
      detachEffect(transition.outPage, transition.outClass);
      detachEffect(transition.inPage, transition.inClass);
      callback();
      editorService.forceToRefreshUI();
    });
    TQUtility.triggerEvent(document, TQ.PageTransitionEffect.EVENT_COMPLETED);
  }

  function detachEffect(page, classes) {
    if (classes) {
      page.removeClass(classes);
    }
  }

  function attachEffect(page, effectClass) {
    if (effectClass) {
      page.addClass(effectClass);
    }
  }

  function isBusy() {
    return isAnimating;
  }

  function getEffect(name) {
    if (effectsList[name]) {
      return effectsList[name];
    }
    return effectsList[defaultEffectName];
  }
}());

TQ.PageTransitionEffect.EVENT_COMPLETED = "page transition end";

/**
 * Created by Andrewz on 8/25/17.
 */
var TQ = TQ || {};
TQ.PageTransition = (function() {
  var taskQue = [];

  function start(currentId, targetId, callback) {
    if (TQ.PageTransitionEffect.isBusy()) {
      TQ.Log.debugInfo("busy, delay " + currentId + " to " + targetId + ", total: " + taskQue.length);
      var task = [currentId, targetId, callback];
      if (isNewTask(task)) {
        addOrMergeTask(task);
      } else {
        TQ.Log.debugInfo("delay duplicated!");
      }
      return;
    }

    TQ.Log.debugInfo("do busy, delay " + currentId + " to " + targetId + ", total: " + taskQue.length);

    if (needFastPaging()) {
      callback();
      setTimeout(checkQue);
    } else {
      TQ.PageTransitionEffect.state.page1Image = TQ.ScreenShot.getDataWithBkgColor();
      if (targetId < currentId) {
        prevPage();
      } else {
        nextPage();
      }
      callback();
    }
  }

  function nextPage() {
    var outPage = getCurrentPage();
    var inPage = getTargetPage();
    var effects = TQ.PageTransitionEffect.getEffect("rotateFoldLeft");
    var transition = {
      outPage: outPage,
      outClass: effects.outClass,
      inPage: inPage,
      inClass: effects.inClass
    };
    TQ.PageTransitionEffect.doTransition(transition, checkQue);
  }

  function prevPage() {
    var outPage = getCurrentPage();
    var inPage = getTargetPage();
    var effects = TQ.PageTransitionEffect.getEffect("rotateFoldRight");
    var transition = {
      outPage: outPage,
      outClass: effects.outClass,
      inPage: inPage,
      inClass: effects.inClass
    };
    TQ.PageTransitionEffect.doTransition(transition, checkQue);
  }

  function checkQue() {
    var next = taskQue.shift();
    if (next) {
      TQ.Log.debugInfo("from delay que: " + taskQue.length + ": " + next[0] + " to " + next[1]);
      start(next[0], next[1], next[2]);
    }
  }

  function isNewTask(task) {
    var isNew = true;
    taskQue.forEach(function(item) {
      if ((item[0] === task[0]) &&
                (item[1] === task[1])) {
        isNew = false;
      }
    });
    return isNew;
  }

  function getCurrentPage() {
    return $("#id-page-effect1");
  }

  function getTargetPage() {
    return $("#testCanvas");
  }

  function needFastPaging() {
    return (taskQue.length > 1);
  }

  function addOrMergeTask(task) {
    if (taskQue.length <= 0) {
      taskQue.push(task);
    } else {
      var lastTask = taskQue[taskQue.length - 1];
      lastTask[1] = task[1];
      lastTask[2] = task[2];
    }
  }

  return {
    start: start
  };
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  /**
     * MultiView, 是带有多个view的元素集合， 模仿3D物体， 同时只能有一个元素可见。
     * @param jsonObj
     * @constructor
     */
  function MultiView(jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string");
    this.viewId = 0; // 默认显示第一个视图的元素
    this.fixedUp(jsonObj); // 用于从数据文件建立动画
  }

  var p = MultiView.prototype;

  p.fixedUp = function(jsonObj) {
    if ((jsonObj != null) && (jsonObj.viewId != null)) {
      this.viewId = jsonObj.viewId;
    }
  };

  p.setupView = function() {
    TQ.InputMap.registerAction(TQ.InputMap.LEFT_ARROW, function() {
      var ele = TQ.SelectSet.peek();
      if ((ele != null) && (ele.viewCtrl != null)) {
        ele.viewCtrl.changeView(-1);
      }
    });
    TQ.InputMap.registerAction(TQ.InputMap.RIGHT_ARROW, function() {
      var ele = TQ.SelectSet.peek();
      if ((ele != null) && (ele.viewCtrl != null)) {
        ele.viewCtrl.changeView(1);
      }
    });
  };

  p.changeView = function(adjust) {
    if (this.parent == null) return;

    this.viewId += adjust;
    var num = this.parent.children.length;
    this.viewId = TQ.MathExt.range(this.viewId, 0, num - 1);
    for (var i = 0; i < num; i++) {
      var e = this.parent.children[i];
      e.show(i === this.viewId);
    }
  };

  p.hideView = function() {
    if ((!this.parent) || (!this.parent.children)) return;

    var t = TQ.FrameCounter.t();
    var num = this.parent.children.length;
    for (var i = 0; i < num; i++) {
      var e = this.parent.children[i];
      TQ.AnimeTrack.hide(e, t);
    }
  };

  p.unHideView = function() {
    var t = TQ.FrameCounter.t();
    var num = this.parent.children.length;
    for (var i = 0; i < num; i++) {
      var e = this.parent.children[i];
      TQ.AnimeTrack.unHide(e, t);
    }
  };

  p.attachTo = function(host) {
    if (host != null) {
      this.parent = host;
      host.viewCtrl = this;
      this.setupView();
      this.hideView();
      this.changeView(0);
    }
  };

  p.detach = function(host) {
    if (host != null) {
      this.unHideView();
      this.parent = null;
      host.viewCtrl = null;
    }
  };

  p.toJSON = function() {
    return this.viewId;
  };

  p.isMultiView = function() { return true; };

  TQ.MultiView = MultiView;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

// Element其实是Image元素演化来的，
// 扩展成了基类
(function() {
  TQ.ElementType = {
    ANCHOR_MARKER: "AnchorMarker",
    BITMAP: "Bitmap",
    BITMAP_ANIMATION: "BitmapAnimation",
    VIDEO: "VIDEO",
    BUTTON: "BUTTON",
    BBOX: "BBOX",
    GROUP: "Group",
    GROUP_FILE: "GroupFile",
    JOINT_MARKER: "JointMarker",
    FULLSCREEN_EFFECT_PARTICLE: "fullscreenEffectParticle",
    POINT: "Point",
    RAIN: "RainEffect", // TBD
    SNOW: "SnowEffect", // TBD
    RECTANGLE: "Rectangle",
    CIRCLE: "Circle",
    SOUND: "SOUND",
    TEXT: "Text",
    TEXT_BUBBLE: "TextBubble"
  };
  var DescType = TQ.ElementType;

  function Element(level, desc) {
    if (level != null) { // 适用于 子类的定义, 不做任何初始化,只需要prototype
      this.level = level;
      this.children = [];
      this.decorations = null;
      this._isNewSkin = false;
      this._isHighlighting = false;
      this.animeCtrl = null;
      this.viewCtrl = null;
      this.state = (desc.state === undefined) ? 0 : desc.state;
      this.dirty = this.dirty2 = false; // dirty2是迫使记录某几个或全部数据
      if (desc.autoFit) { // 所有新加的元素都必须有此属性， 从文件中load的元素则无
        this.autoFitFlag = desc.autoFit;
        this.isNewlyAdded = true;
      } else {
        this.autoFitFlag = false;
        this.isNewlyAdded = false;
      }
      delete (desc.autoFit);
      this.initialize(desc);
    }
  }

  Element.FitFlag = {
    KEEP_SIZE: 1,
    FULL_SCREEN: 2,
    WITHIN_FRAME: 3,
    NO: 4
  };

  Element.counter = 0;
  Element.VER1 = "V1";
  Element.VER2 = "V2"; // 从2014-3-2日开始使用
  Element.VER3 = 3; // 从2016-6-1日开始使用
  Element.TOP = 99999; // zIndex of top element

  // 0x01--0x1F是固定结构部分，    需要保存到WDM文件中；之后的高位是动态的
  Element.JOINTED = 0x02; // 关节体中的所有子物体,不包括根关节自己.
  Element.ROOT_JOINT = 0x04; // 根关节自己, 版本V2开始添加
  Element.BROKEN = 0x10; // 相对运动: 子物体可以独立运动,也随父物体移动(布局用).绝对运动: 只能整体运动, 或者IK运动.

  // 以下是操作, 对应于唯一的动画track
  Element.TRANSLATING = 0x20; // 被操作之后, 马上值为真, 以便于拍摄记录
  Element.ROTATING = 0x40;
  Element.SCALING = 0x80;
  Element.ALPHAING = 0x100;
  Element.ZING = 0x200;
  Element.VISIBLE_CHANGED = 0x400;
  Element.ACTION_CHANGED = 0x800;
  Element.COLOR_CHANGED = 0x1000;

  // 元素的类别
  Element.ETYPE_BACKGROUND = 1; // 1 背景，
  Element.ETYPE_PROP = 2; // 道具
  Element.ETYPE_CHARACTER = 3; // 人物
  Element.ETYPE_TEXT = 4; // 文字
  Element.ETYPE_EFFECT = 5; // 5 特效，
  Element.ETYPE_BUTTON = 6; // 按钮
  Element.ETYPE_AUDIO = 7; // 声音
  Element.ETYPE_PART = 8; // 零件
  Element.ETYPE_CIRCLE = 9; //
  Element.ETYPE_RECTANGLE = 10; //

  // 元素的类别资源类别
  Element.TYPE_BITMAP = 2; // 图片
  Element.TYPE_COMPONENT = 3; // 元件
  Element.TYPE_BUTTON = 4; // 按钮
  Element.TYPE_SOUND = 11; // 声音

  Element.TO_RELATIVE_POSE = (Element.TRANSLATING | Element.ROTATING | Element.SCALING |
    Element.ZING | Element.ALPHAING); //  在组成Group, Joint, 显示 Pivot Marker的时候需要.
  Element.CLEAR_ANIMATATION = 0x8000; // 清除全部track, 重新记录;
  Element.IN_STAGE = 0x10000; // 加入到了Stage;
  Element.LOADED = 0x20000; //
  Element.EVENT_NEW_ELEMENT_ADDED = "new element added";

  Element.showHidenObjectFlag = false; //  个人的state由个人记录, 上级可以控制
  var p = Element.prototype;
  p = TQ.CreateJSAdapter.attach(p);
  p.loaded = false;
  p.jsonObj = null;
  p.displayObj = null;
  p.parent = null;
  p.children = []; //  注意： 缺省是空数组， 不是null， 确保每一个参数都有缺省值！！！
  p.animeTrack = {}; // 只是数组指针, 和jsonObj 共用数据, 没有重复

  // 静态函数
  Element.isValidDesc = function(desc) {
    var srcNotNull = [DescType.BITMAP, DescType.BITMAP_ANIMATION, DescType.SOUND];
    return !(!desc ||
      (!desc.src && (srcNotNull.indexOf(desc.type) >= 0)));
  };
  Element.createHitArea = function(host, rotationRelative, w, h) {
    var shape = new createjs.Shape();
    shape.rotation = rotationRelative; // 相对于它host元素的角度，0， 因为hitArea总是随host主体转动的;
    shape.graphics.beginFill("#F00").drawRect(0, 0, w, h);
    TQ.DirtyFlag.setEdited(host);
    return shape;
  };

  // 成员函数
  p.show = function(isVisible) {
    this.jsonObj.isVis = isVisible;
    if (this.displayObj) {
      if (this.jsonObj.isVis && !this.hasFlag(Element.IN_STAGE)) {
        TQ.Log.out(TQ.Dictionary.INVALID_LOGIC); // show + _doAddItemToStage 飞线, 适用于: 1) load之时不可见的元素, 2) marker初次创建时, 不可见
        TQ.StageBuffer.add(this);
      }
    } else {
      if (this.isFEeffect() || this.isSound() || this.isVideo() || this.isGrouped() || this.isGroupFile()) {
      } else {
        TQ.AssertExt.invalidLogic(this.displayObj === undefined, "没有displayObj的元素，需要重定义show接口???");
      }
    }
    // ToDo: 留给显示函数做, 不能一竿子插到底,  this.displayObj.visible = isVisible;
    this.dirty2 = true;
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
    this.setFlag(Element.VISIBLE_CHANGED);

    // show命令， 只是改变这个实体本身的可见性标志，不能直接传遍所有孩子。
    // 其孩子的实际可见性 = 父物体实际可见性 && 孩子的可见性标志 ，
    // 详细见： setTRSAVZ() 和 isVisible()
  };

  p.toggleVisibility = function() {
    if (this.isPinned()) {
      return;
    }
    this.show(!this.jsonObj.isVis);
    TQ.DirtyFlag.setElement(this);
  };

  // Add image item
  p.initialize = function(desc) {
    this.id = createjs.UID.get();
    if ((this.level.isStageReady())) {
      // 如果所需资源都在RM， 则直接init， 否则，sent到RM， 要求调入。完成后， 再init
      if ((desc.type === DescType.BITMAP) || (desc.type === DescType.BUTTON)) {
        TQ.Assert.isTrue(TQ.ResourceDesc.isReady(desc), "先准备好资源， 再创建元素");
      }
    }

    this.dirty = false;
    this.dirty2 = false; // 仅当需要在game循环之外调用element.update强制"拍摄"的时候令它为true
    this.version = desc.version;
    desc.x = (desc.x == null) ? 0 : desc.x;
    desc.y = (desc.y == null) ? 0 : desc.y;
    this.jsonObj = this.fillGap(desc);
    switch (desc.type) {
      case DescType.GROUP_FILE:
        this.loadFromFile(desc);
        break;
      case DescType.BITMAP_ANIMATION:
        this._addActorByUrl(desc, null);
        break;
      default:
        this.load(desc);
    }

    // / assertTrue("错误的元素信息: " + JSON.stringify(itemURL), false);
    return null;
  };

  p._addActorByUrl = function(desc, alias) {
    // 先读入Description文件， 再读入图像。
    var request = new XMLHttpRequest();
    console.info("Requesting " + desc.src);
    request.open("GET", desc.src);

    (function(parentObj) {
      request.onreadystatechange = function() {
        if (request.readyState === 4) {
          if (request.status === 404) {
            console.info(desc.src + " does not exist");
          } else {
            var o = JSON.parse(request.responseText);
            o.alias = (alias == null) ? "none" : alias;
            o.remote = true;
            if (!o.type) {
              o.type = "BitmapAnimation";
            }
            o.x = (o.x === undefined) ? desc.x : o.x;
            o.y = (o.y === undefined) ? desc.y : o.y;
            o.PivotX = (o.PivotX === undefined) ? TQ.Config.pivotX : o.PivotX;
            o.PivotY = (o.PivotY === undefined) ? TQ.Config.pivotY : o.PivotY;
            parentObj.load(o);
          }
        }
      };
    })(this);
    request.send();
  };

  // 补全所缺少的数据
  p.fillGap = function(desc) {
    // 所有元素， 在add之后， 都需要经过load， 从资源中调进来。
    if (desc.name) {
      desc.name = "element" + Element.counter++;
    }

    if (desc.type === undefined) {
      desc.type = "Bitmap";
    }

    if (desc.eType === undefined) {
      desc.eType = Element.type2eType(desc.type);
    }

    if (desc.state === undefined) {
      desc.state = 0;
    }

    if (desc.isVis === undefined) {
      desc.isVis = true;
    }

    if (desc.isClipPoint === undefined) {
      desc.isClipPoint = false;
    }

    if (desc.x === undefined) { // 区别： 如果 desc.x 是 0， 则不会重新被赋值
      desc.x = 0;
    }

    if (desc.y === undefined) {
      desc.y = 0;
    }

    if (desc.sx === undefined) {
      desc.sx = 1;
    }

    if (desc.sy === undefined) {
      desc.sy = 1;
    }

    if (desc.mirrorX === undefined) {
      desc.mirrorX = false;
    }

    if (desc.mirrorY === undefined) {
      desc.mirrorY = false;
    }

    if (desc.zIndex === undefined) {
      desc.zIndex = Element.TOP;
    }

    if (desc.alpha === undefined) {
      desc.alpha = 1;
    }

    if (desc.color === undefined) {
      desc.color = TQ.Config.color;
    }

    if (desc.type === DescType.TEXT) {
      desc.pivotX = (desc.pivotX === undefined) ? TQ.Config.TEXT_PIVOT_X : desc.pivotX;
      desc.pivotY = (desc.pivotY === undefined) ? TQ.Config.TEXT_PIVOT_Y : desc.pivotY;
    } else {
      desc.pivotX = (desc.pivotX === undefined) ? TQ.Config.pivotX : desc.pivotX;
      desc.pivotY = (desc.pivotY === undefined) ? TQ.Config.pivotY : desc.pivotY;
    }

    if (desc.rotation === undefined) {
      desc.rotation = 0;
    }

    // 清除M和IM, 过去的版本中,可能输出了这些数值.
    // 他们如果没有 对象化, 就会阻碍 Matrix.multiply()
    desc.IM = desc.M = null;
    return desc;
  };

  p.fillGap2 = function() {
    var desc = this.jsonObj;
    if ((desc.sx === undefined) || (desc.sy === undefined)) {
      if (this.isEditorEle()) {
        this.markerScaleOne(desc);
      } else {
        this.scaleOne(desc);
      }
    }
  };

  p.fillGapAtferAutoFit = function() {
    var desc = this.jsonObj;
    // 强制补全动画轨迹, 必须在autoFit之后。
    desc.animeTrack = new TQ.AnimeTrack(desc);
    TQ.AnimeTrack.validate(desc.animeTrack);
  };

  Element.type2eType = function(type) {
    switch (type) {
      case "Text":
        return 4;
      case "SOUND":
        return 7;
      case "Group":
        return 2;
      case "Bitmap":
        return 1;
      default:
    }
    return 1;
  };

  p.load = function(desc) {
    TQ.Assert.isTrue(!!desc, "must define desc");
    // 记录到element中
    if ((this.jsonObj.src !== undefined) && (this.jsonObj.src != null)) {
      this.jsonObj.src = Element.upgrade(this.jsonObj.src);
    }

    switch (desc.type) {
      case DescType.BITMAP_ANIMATION:
        this._loadActor();
        break;
      case DescType.JOINT_MARKER:
      case DescType.ANCHOR_MARKER:
        this._loadMarker();
        break;
      default:
        this._doLoad(desc);
        break;
    }

    if (desc.trace) {
      this.trace = TQ.Trace.build(desc.trace);
    }

    if (desc.animeCtrl != null) {
      this.animeCtrl = new TQ.Animation(desc.animeCtrl);
    }

    if (desc.viewCtrl != null) {
      this.viewCtrl = new TQ.MultiView(desc.viewCtrl);
    }

    this.setupChildren();
    return desc;
  };

  p.setupChildren = function() {
    if (this.jsonObj.children) {
      for (var i = 0; i < this.jsonObj.children.length; i++) {
        if (this.jsonObj.children[i]) {
          this.addChild(this.jsonObj.children[i]);
        }
      }
    }
  };

  p.calGeoBox = function() {
  // 自身的边界盒，在不考虑children的情况下，
  // 虚元素（Group，元件等）自身没有边界盒，
    let selfBox = (this.isVirtualObject()) ? null : new TQ.GeoBox(this);
    if (this.children) {
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i] && !this.children[i].isHighlighter()) {
          const childBox = this.children[i].calGeoBox();
          if (childBox) {
            selfBox = (!selfBox) ? childBox : selfBox.combine(childBox);
          }
        }
      }
    }
    return selfBox;
  };

  p.getTextBubble = function() {
    var bubble = null;
    if (this.children) {
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i] instanceof TQ.TextBubble) {
          bubble = this.children[i];
          break;
        }
      }
    }

    return bubble;
  };

  p.findChild = function(childDisplayObj) {
    if (this.children == null) {
      return null;
    }

    var result = null;
    for (var i = 0; i < this.children.length; i++) {
      if (this.children[i].displayObj != null) {
        if (this.children[i].displayObj.id === childDisplayObj.id) {
          return this.children[i];
        }
      }

      result = this.children[i].findChild(childDisplayObj);
      if (result != null) break;
    }

    return result;
  };

  p.addJoint = function(ele) {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, TQ.InputCtrl.inSubobjectMode); // 在零件模式下
    if (ele.state === undefined) {
      ele.state = 0;
    }

    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
    ele.setFlag(Element.JOINTED);
    this.addChild(ele);
    this.dirty2 = true;
  };

  p.neverUpdated = function() {
    return !this.jsonObj.M;
  };

  p.addChild = function(desc, isInObjectSpace) {
    if (desc.displayObj != null) { // 在group或者joint物体的时候,出现
      var child = desc; // 已经是物体了, 不用创建了. 但是,需要衔接jsonObj
      var t = TQ.FrameCounter.t();
      if (this.neverUpdated()) { // 新创建的元素，必须update以求出矩阵M
        this.dirty = true;
        this.update(t, TQ.Const.NO_RECORDING_TRUE);
      }

      if (isInObjectSpace) {
        var posWorld = this.object2World(child.jsonObj);
        child.jsonObj.x = posWorld.x;
        child.jsonObj.y = posWorld.y;
      }

      // 从世界坐标, 变换到父物体坐标系: 由Update来做
      var pos1 = {};
      pos1.t = t;
      Element.copyWorldData(pos1, child.jsonObj);
      var worldData = [];
      this.saveWorldDataAll(worldData, child);
      child.parent = this;
      child.animeTrack = null; // group元素和关节，都会丢失原来的动画轨迹!!!
      this.children.push(child);
      this.toRelative(worldData, child);
      Element.copyWorldData(child.jsonObj, pos1);

      // ToDo： 是不是可以不加入到jsonObj.children中？
      // 因为保存的时候， 总是遍历this.children的， 而且会忽视jsonObj.children
      if (!this.jsonObj.children) {
        this.jsonObj.children = [];
      }
      this.jsonObj.children.push(child.jsonObj);
      child.dirty = true;
      child.forceToRecord();
      child.update(t); // 必须强制记录， 否则，无法生成AnimeTrack

      TQ.DirtyFlag.setEdited(this);
      child.dirty2 = this.dirty2 = true; // 迫使系统更新child的位置数据位相对坐标
      child.setFlag(Element.TO_RELATIVE_POSE);
    } else if (desc instanceof TQ.Element) {
      this.addChildDirect(desc);
    } else {
      var host = this;
      child = Element.build(this.level, desc, host);
      this.addChildDirect(child);
    }

    return child;
  };

  /*
   child 必须已经是 元素， 而且， 不需要经过相对化坐标变换
   */
  p.addChildDirect = function(child) {
    child.parent = this;
    if (!this.children) {
      this.children = [];
    }
    this.children.push(child);
  };

  p.explode = function() {
    // 普通group只炸开1层，
    // 关节：炸开整条链
    var parts = [];
    TQ.Assert.isTrue(!this.hasBBox(), "必须先把BBox去除");
    if (this.children) {
      while (this.children.length > 0) {
        var child = this.removeChild(this.children[0]);
        parts.push(child);
      }
    }
    return parts;
  };

  p.findAttachment = function() {
    if (this.isBone()) {
      const num = this.children.length;
      for (let i = num - 1; i >= 0; i--) {
        if (!this.children[i].isBone()) {
          return i;
        }
      }
    }
    return -1;
  };

  p.undeleteChild = function(child) {
    this.addChildDirect(child);
    child.addItemToStage();
  };

  Element.copyWorldData = function(a, b) {
    a.x = b.x;
    a.y = b.y;
    a.sx = b.sx;
    a.sy = b.sy;
    a.rotation = b.rotation;
    a.isVis = b.isVis;
  };

  p.saveWorldDataAll = function(worldData, child) {
    // 计算当前的世界坐标，并且保存,并且记录轨道的类别
    if (!child.animeTrack) {
      return;
    }
    if (child.animeTrack.x) child.saveWorldData(worldData, child.animeTrack.x, Element.TRANSLATING);
    if (child.animeTrack.sx) child.saveWorldData(worldData, child.animeTrack.sx, Element.SCALING);
    if (child.animeTrack.rotation) child.saveWorldData(worldData, child.animeTrack.rotation, Element.ROTATING);
    if (child.animeTrack.visible) child.saveWorldData(worldData, child.animeTrack.visible, Element.VISIBLE_CHANGED);
  };

  p.readyForChild = function() {
    if (this.isDisplayabled()) {
      return (!!this.jsonObj.M);
    } else {
      return true;
    }
  };

  p.toRelative = function(worldData, child) {
    TQ.Assert.isTrue(this.readyForChild(), "新建立的物体， 至少要新1次，补齐矩阵，才能addChild！");
    // 计算相对坐标， 并且录制。
    for (var i = 0; i < worldData.length; i++) {
      var pos1 = worldData[i];
      TQ.DirtyFlag.setElement(this);
      child.dirty2 = this.dirty2 = true; // 迫使系统更新child的位置数据位相对坐标
      child.setFlag(pos1.type);
      Element.copyWorldData(child.jsonObj, pos1);
      child.update(pos1.t, TQ.Const.NO_RECORDING_FALSE);
    }
  };

  p.saveWorldData = function(worldData, track, type) {
    // ToDo: 先计算所有parent的pose，再计算它的pose
    for (var i = 0; i < track.t.length; i++) {
      var t = track.t[i];
      this.update(t, TQ.Const.NO_RECORDING_TRUE);
      var pos1 = {};
      pos1.t = t;
      pos1.type = type;
      Element.copyWorldData(pos1, this.jsonObj);
      worldData.push(pos1);
    }
  };

  p.removeChild = function(child) {
    if (!child ||
      (this.isPinned() && !child.isHighlighter())) {
      return null;
    }
    assertNotNull(TQ.Dictionary.FoundNull, this.children); // "应该有孩子"
    var id = this.children.indexOf(child);
    assertTrue(TQ.Dictionary.INVALID_LOGIC, id >= 0); // "应该能够找到孩子"
    if (id >= 0) {
      child = (this.children.splice(id, 1))[0];
      if (this.jsonObj.children) { // 注意： marker和气泡，不在jsonObj里面
        id = this.jsonObj.children.indexOf(child.jsonObj);
        if (id >= 0) {
          this.jsonObj.children.splice(id, 1);
        }
      }
      child.parent = null;
    }

    if (child.isEditable()) { // 忽略marker， point等
      // 迫使元素回到世界坐标系标示
      TQ.DirtyFlag.setElement(this);
      child.forceToRecord();
      this.forceToRecord(); // 迫使系统更新child的位置数据位相对坐标
      child.setFlag(Element.TO_RELATIVE_POSE);
      var t = TQ.FrameCounter.t();
      child.update(t);
    }
    return child;
  };

  p.atomNum = function() {
    var sum = 1;
    for (var i = 0; i < this.children.length; i++) {
      sum += this.children[i].atomNum();
    }
    return sum;
  };

  p.skinning = function(skin) {
    var hostType = this.getType();
    if (hostType === DescType.BUTTON) {
      hostType = DescType.BITMAP;
    }
    if (hostType !== skin.getType()) {
      TQ.MessageBubble.show(TQ.Dictionary.SAME_TYPE_SKIN + skin.getType(), false);
      return;
    }

    // 必须是相同的类别，才能够换皮肤
    // 暂存 Z可见性 和 新皮肤的名称,
    this.persist();
    if (this.isText()) {
      this.jsonObj.text = skin.jsonObj.text;
      this.jsonObj.fontSize = skin.jsonObj.fontSize;
      this.jsonObj.fontFace = skin.jsonObj.fontFace;
      this.jsonObj.color = skin.jsonObj.color;
    } else {
      this.jsonObj.src = skin.jsonObj.src;
    }
    this._doRemoveFromStage();
    this._isNewSkin = true;
    this._doLoad(this.jsonObj);
    skin.TBD = true;
  };

  p.changeSkin = function(newSkinImg, onChanged) {
    if (!this.isBitmap()) {
      return;
    }

    var self = this;
    if (self.isPinned()) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("the object is locked, continue?"), function() {
        self.pinIt();
        self.changeSkin(newSkinImg, onChanged);
      });
    }

    this.persist();
    var oldImgHeight = this.displayObj.image.height;
    var originalZ = this.jsonObj.zIndex;
    if ((newSkinImg instanceof Image) || TQ.Utility.isImage64(newSkinImg)) {
      this.jsonObj.src = null;
      this.jsonObj.data = newSkinImg;
    } else {
      var imgReady = TQ.RM.hasResourceReady(newSkinImg);
      if (!imgReady) {
        return TQ.RM.addItem(newSkinImg, function() {
          self.changeSkin(newSkinImg, onChanged);
        });
      }
      this.jsonObj.src = newSkinImg;
    }

    if (Element.isBackground(this.jsonObj)) {
      this.autoFitFlag = TQ.Element.FitFlag.FULL_SCREEN;
    }
    this._doRemoveFromStage();
    this.persist();
    this.jsonObj.zIndex = originalZ; // 在被从stage remove之后， z变为-1
    this._isNewSkin = true;
    this._doLoad(this.jsonObj, function() {
      var scale = oldImgHeight / self.displayObj.image.height;
      self.scale(scale);
    });
    if (onChanged) {
      onChanged(self);
    }
  };

  p.attachMarker = function() {
    this.attachDecoration([TQ.Marker.getOne()]);
  };

  p.attachDecoration = function(decs) {
    // ToDo: 处理每一个Marker
    var marker = decs[0];
    marker.host = this;
    marker.level = this.level;
    marker.reset();
    marker.createImage();
    marker._doAddItemToStage(null);
    this.dirty2 = marker.dirty2 = true;
    marker.setFlag(Element.TO_RELATIVE_POSE | Element.CLEAR_ANIMATATION); // 迫使他记录所有的track,
    var isInObjectSpace = true;
    this.addChild(marker, isInObjectSpace);
    if (!this.decorations) {
      this.decorations = decs;
    } else {
      var decorations = this.decorations;
      decs.forEach(function(item) {
        decorations.push(item);
      });
    }
    marker.show(true);
    marker.moveToTop();
    if (TQ.InputCtrl.leaveTraceOn && !!this.trace) {
      this.trace.draw();
    }
  };

  p.detachDecoration = function() {
    if (this.hasBBox()) {
      TQ.BBox.detachFrom(this);
    }

    if (!this.decorations) {
      return null;
    }
    var decorations = this.decorations;
    this.decorations = null;
    assertNotNull(TQ.Dictionary.FoundNull, decorations);
    for (var i = 0; i < decorations.length; i++) {
      var marker = decorations[i];
      marker.show(false);
      marker.displayObj.visible = false;
      marker.host = null;
      marker.level = null;
      this.removeChild(marker);
      marker.recycle();
    }

    if (TQ.InputCtrl.leaveTraceOn && !!this.trace) {
      this.trace.removeFromStage();
    }
    return decorations;
  };

  p.detachOneDecoration = function(marker) {
    if (!this.decorations) {
      return null;
    }
    assertNotNull(TQ.Dictionary.FoundNull, this.decorations);
    var id = this.decorations.indexOf(marker);
    this.decorations.splice(id, 1);
    marker.show(false);
    marker.displayObj.visible = false;
    marker.host = null;
    marker.level = null;
    this.removeChild(marker);
    if (marker.isBBox()) {
      marker.removeFromStage();
    } else {
      marker.recycle();
    }
  };

  p.getImageResource = function(item, jsonObj) {
    if (item) {
      return item.res;
    }
    return jsonObj.img;
  };

  p._doLoad = function(desc, callback) {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var resource;
    if (desc.data) {
      resource = desc.data;
      desc.data = null;
    } else {
      var jsonObj = this.jsonObj;
      assertTrue("must has image name", jsonObj.src !== "");
      var item = TQ.RM.getResource(jsonObj.src);
      TQ.Assert.isNotNull(item, "先准备好资源， 再创建元素");
      resource = this.getImageResource(item, jsonObj);
    }

    this.loaded = true;
    this.displayObj = new createjs.Bitmap(resource);
    this._afterItemLoaded(resource);
    this.setTRSAVZ();
    TQ.DirtyFlag.setElement(this);
    if (callback) {
      callback();
    }
  };

  p.autoFit = function(img) {
    if (this.autoFitFlag === Element.FitFlag.NO) {
      return;
    }

    TQ.AssertExt.invalidLogic(img != null, "未改造的元素？");
    // 保持图像长宽比例不失真
    // 自动充满整个画面 或者 保持物体的原始大小
    var sx = currScene.getDesignatedWidth() / this.getWidth();
    var sy = currScene.getDesignatedHeight() / this.getHeight();
    var desc = this.jsonObj;
    var pWorld = this.nw2World({ x: 0.5, y: 0.5 });
    if (this.autoFitFlag !== Element.FitFlag.NO) {
      desc.x = pWorld.x;
      desc.y = pWorld.y;
      desc.sx = sx;
      desc.sy = sy;
      desc.rotation = 0;
      desc.pivotX = 0.5;
      desc.pivotY = 0.5;
    }

    pWorld = desc;
    var minScale = Math.max(pWorld.sx, pWorld.sy); // 正好充满， 不留空白边， 多余的图，超出编辑
    if ((this.autoFitFlag === Element.FitFlag.KEEP_SIZE) ||
      ((this.autoFitFlag === Element.FitFlag.WITHIN_FRAME) && (minScale > 1))) { // 框大， 图小，保持原尺寸
      pWorld.sx = 1;
      pWorld.sy = 1;
    } else { // 框子小， 图大， 需要缩小
      // 保持图像长宽比例不失真
      pWorld.sx = minScale;
      pWorld.sy = minScale;
    }
  };

  p.forceToRecord = function(flag) {
    this.dirty2 = true; // 迫使系统记录这个坐标
    flag = flag || (Element.TRANSLATING | Element.ROTATING | Element.SCALING |
      Element.ALPHAING | Element.COLOR_CHANGED);
    this.setFlag(flag);
  };

  p.setTRSAVZ = function() {
    if (this.isBitmap() && !this.hasFlag(TQ.Element.IN_STAGE)) {
      // loaded， 在stageBuffer， 但是尚未正式进入stage
      return;
    }

    var jsonObj = this.jsonObj;
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // "世界坐标值jsonOb不能为空"
    if (!(this.isSound() || this.isVideo())) { // "显示对象displayObj不能为空"
      assertNotNull(TQ.Dictionary.FoundNull, this.displayObj);
    }
    if (jsonObj.isVis && !this.isVirtualObject() &&
      !this.hasFlag(Element.IN_STAGE) && !this.isVideo()) {
      // 飞线: 谁在使用这种情况?, 顶多在Show的时候检查"
      TQ.Log.warn(TQ.Dictionary.INVALID_LOGIC + ":setTRSAVZ元素loaded，在Buffer，尚未进stage：" + this.jsonObj.src);
      return;
    }

    // 可见性由父子共同决定：
    //  如果父物体为空， 该物体的可见性由自己的标志完全决定
    //  如果父物体非空：
    //      父亲实际不可见，则都不可见（一票否决制）；
    //      父亲实际可见，则孩子自己决定
    //
    //   物体的实际可见性就是 displayObj.visible,
    //          如果displayObj为空，用临时标志： visibleTemp,
    //
    var visSum = false;
    if (!this.parent) {
      visSum = jsonObj.isVis;
    } else {
      visSum = this.parent.isVisible() && jsonObj.isVis;
    }
    visSum = visSum || Element.showHidenObjectFlag;
    this.doShow(visSum);
  };

  p.doShow = function(visSum) {
    if (!this.displayObj) {
      this.visibleTemp = visSum;
    } else {
      this.displayObj.visible = visSum;
      this.toDeviceCoord(this.displayObj, this.jsonObj);
    }
  };

  p._loadActor = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var spriteSheet = this.jsonObj;
    // 这里应该再有一个callback， 因为动画的图像需要花时间调入
    var ss = new createjs.SpriteSheet(spriteSheet);
    var anima = new createjs.Sprite(ss);
    this.loaded = true;

    // Set up looping
    ss.getAnimation("run").next = "run";
    ss.getAnimation("jump").next = "run";
    anima.gotoAndPlay("jump");
    this.displayObj = anima;
    this._afterItemLoaded(null);
    this.setTRSAVZ();
  };

  p.removeFromStage = function() {
    this._doRemoveFromStage();
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      child.removeFromStage();
    }
  };

  p._doRemoveFromStage = function() {
    //! ! Pin的实质是不能被直接选中，所以，不能被直接操作（删除，缩放等等），
    // 但是，可以被间接操作（通过他的父）删除，缩放等。
    // if (this.isPinned()) {
    //  return;
    // }

    if (this.displayObj) {
      this.getContainer().removeChild(this.displayObj);
    }
    this.clearFlag(Element.IN_STAGE);
    TQ.DirtyFlag.setElement(this);
  };

  p.resetStageFlag = function() {
    this.clearFlag(Element.IN_STAGE);
    TQ.DirtyFlag.setElement(this);
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      child.resetStageFlag();
    }
  };

  p.persist = function() {
    TQ.AssertExt.invalidLogic(TQ.StageBuffer.isEmpty(), "StageBuffer中的未加入stage的元素， 无法persist！");
    // 记录当前数据到 json, 以便于存盘和再次切入该场景
    if (!this.jsonObj) {
      return;
    }
    if (!this.displayObj) {
      this.jsonObj.zIndex = -1;
    } else {
      this.jsonObj.zIndex = this.getContainer().getChildIndex(this.displayObj);
    }
    for (var i = 0; i < this.children.length; i++) {
      this.children[i].persist();
    }
  };

  p.destroy = function() {
    if (this.children != null) {
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    }

    this.destroyDisplayObj();
    // 切断联系,以方便系统收回内存资源
    this.children = null;
    this.jsonObj = null;
    this.animeTrack = null;
  };

  p.destroyDisplayObj = function() {
    // 从stage中移除当前的 皮肤,(不再显示),
    // 同时,重置回调函数,阻止用户操作; 切断指针以便于释放内容,
    this._doRemoveFromStage();
    if (this.displayObj != null) {
      this.displayObj.jsonObj = null;
      this.displayObj.onPress = null;
      this.displayObj.onMouseOver = null;
      this.displayObj.onMouseOut = null;
      this.displayObj = null;
    }
  };

  p.eraseAnimeTrack = function(withChildren) {
    if (this.isPinned()) {
      return;
    }
    this.animeTrack.erase();
    this.jsonObj.animeTrack = null;
    if (withChildren) {
      if (this.children != null) {
        for (var i = 0; i < this.children.length; i++) {
          if (!this.children[i].isHighlighter()) {
            this.children[i].eraseAnimeTrack(withChildren);
          }
        }
      }
    }

    this.forceToRecord();
    TQ.DirtyFlag.setElement(this);
  };

  p.trim = function(t1, t2) {
    if (t1 < 0) {
      t1 = 0;
    }

    if (t1 >= t2) {
      return;
    }

    if (this.animeTrack) {
      this.animeTrack.trim(t1, t2);
    }
    this.forceToRecord();
    this.updateRecord2(t1);
  };

  p.updateRecord2 = function(t) {
    this.updateRecord(t);
    if (this.children != null) {
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].updateRecord2(t);
      }
    }
  };

  p.deleteChild = function(ele) {
    // 删除Parent的时候，其中pin的子元素也应该被删除
    // if (this.isPinned()) {
    //  return;
    // }

    if (this.children == null) {
      return false;
    }

    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      if (child === ele) {
        child.removeFromStage();
        this.children.splice(i, 1);
        this.jsonObj.children.splice(i, 1);
        return true;
      }

      if (child.deleteChild(ele)) return true;
    }

    return false;
  };

  p.addItemToStage = function() {
    if (!this.level.isActive()) { // 资源加载耗时多， 整个level都已经退出了stage，(因为level切换了)
      return;
    }

    if (!this.isGroup()) {
      TQ.StageBuffer.add(this);
    }
    if (this.children != null) {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.addItemToStage();
      }
    }
  };

  p.getContainer = function() {
    if (this.isHighlighter()) {
      return TQ.SceneEditor.auxContainer;
    }

    if (TQ.Config.useCreateJSFullContainer) {
      var parent = this.parent;
      return (parent && parent.isGroup()) ? parent.displayObj : stageContainer;
    }

    return stageContainer;
  };

  p._doAddItemToStage = function(upperEle, ignoreOldZ) {
    // 只需要加入一次， 之后， 都是自动更新坐标，角度等等， 不需要反复加入
    // 他们的坐标都控制在 displayObj中，
    if (((this.displayObj == null) || this.isVirtualObject())) { // group物体的虚根
      if (TQ.Config.useCreateJSFullContainer && this.isGroup()) {
      } else {
        return;
      }
    }

    if (this.jsonObj.zIndex === -1) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false); // -1, group物体应该在isVirtualObject中处理
      this.jsonObj.zIndex === Element.TOP;
    }
    var thislevel = this.level;
    var item = this.displayObj;
    assertNotNull(TQ.Dictionary.FoundNull, this.displayObj); // 必须有显示体
    item.jsonObj = this.jsonObj; // 需要临时建立关系， 因为在NetIO时候可能破坏了。
    item.ele = this;
    var container = this.getContainer();
    // 不论是否可见， 都添加到stage中， 有visible来控制可见性， 确保层次关系是正确的
    this.setFlag(Element.IN_STAGE);
    if (!ignoreOldZ && ((item.jsonObj.zIndex === Element.TOP) || (!upperEle) || (!upperEle.displayObj))) { // 没有在我之上的， 我就是top
      container.addChild(item);
    } else {
      var z = (!upperEle) ? 0 : container.getChildIndex(upperEle.displayObj);
      if (z <= 0) { // 是 group， 或者其它不可显示的物体
        container.addChild(item);
      } else {
        assertTrue(TQ.Dictionary.INVALID_PARAMETER, z >= 0); // 第一个元素的z = 0
        assertTrue(TQ.Dictionary.INVALID_PARAMETER, z < container.getNumChildren());
        container.addChildAt(item, z); // 把upperEle 顶起来
      }
    }

    // wrapper function to provide scope for the event handlers:
    if (TQ.Config.useCreateJsTouch) {
      (function(ele) {
        var showFloatToolbar = function(evt) {
          if ((TQ.FloatToolbar !== undefined) && TQ.FloatToolbar.setPosition && TQ.FloatToolbar.show) {
            TQ.FloatToolbar.setPosition(evt.stageX, evt.stageY);
            TQ.FloatToolbar.show(this.getType());
          }
        };

        item.onPress = function(evt) {
          if (TQ.SceneEditor.isPlayMode()) {
            return;
          }
          var ele2 = TQ.SelectSet.getEditableEle(ele);
          TQ.SelectSet.add(ele2);
          var target = ele2.displayObj;
          if (target == null) return; // 防止 刚刚被删除的物体.
          var offset = { x: target.x - evt.stageX, y: target.y - evt.stageY, firstTime: true };
          // add a handler to the event object's onMouseMove callback
          // this will be active until the user releases the mouse button:
          showFloatToolbar(evt);
          TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
          evt.onMouseMove = function(ev) {
            if (TQ.SceneEditor.isPlayMode()) {
              return;
            }
            TQ.FloatToolbar.close();
            TQBase.Trsa.do(ele2, thislevel, offset, ev);
          };
          evt.onMouseUp = function(evt) {
            showFloatToolbar(evt);
            evt.onMouseUp = null;
          };

          if (TQ.displayUI && TQ.displayUI.displayMenu && TQ.displayUI.displayActionSet) {
            TQ.displayUI.displayMenu(ele2, ele2.getEType());
            TQ.displayUI.displayActionSet(ele2, ele2.getEType());
          }
        };
        item.onMouseOver = function() {
          ele.highlight(true);
          thislevel.dirty = true;
        };
        item.onMouseOut = function() {
          if (!TQ.SelectSet.isSelected(ele)) {
            ele.highlight(false);
          }
        };
      })(this);
    }

    TQ.DirtyFlag.setElement(this, true);
  };

  p.highlight = function(enable) {
    if (this.isSound() || this.isVideo() || this.isGroupFile() || this.isButton()) return;
    assertNotNull(TQ.Dictionary.FoundNull, this.displayObj);
    if (!this.displayObj) {
      TQ.Log.criticalError(TQ.Dictionary.FoundNull);
      return;
    }
    if (this._isHighlighting === enable) return;

    if (TQ.Config.hightlightOn) {
      this._isHighlighting = enable;
    } else {
      this._isHighlighting = false;
    }

    // 通过dirty flag迫使系统更新， 并且重绘，而不是直接绘制
    TQ.DirtyFlag.setElement(this);
  };

  p.createHighlighter = function() {
    this.displayObj.shadow = Element.getShadow();
    if (TQ.Config.useHighlightBox) {
      this.highter = this.createBBox(1, 1, this.getRotation(),
        this.getWidth(), this.getHeight());
      this.getContainer().addChild(this.highter);
    }
  };

  p.deleteHighlighter = function() {
    if (this.displayObj && !!this.displayObj.shadow) {
      this.displayObj.shadow = null;
    }

    if (TQ.Config.useHighlightBox) {
      if (!this.highter) {
        return;
      }

      this.getContainer().removeChild(this.highter);
      this.highter = null;
    }
  };

  p.updateHighlighter = function() {
    if (this._isHighlighting && this.createHighlighter) {
      this.deleteHighlighter();
      this.createHighlighter();
    } else {
      this.deleteHighlighter();
    }
  };

  p.getBBoxRadiusInWorld = function() {
    var w = this.getWidth();
    var h = this.getHeight();
    var boxInObjectXLen = w / 2 * (1 + Math.abs(0.5 - this.jsonObj.pivotX));
    var boxInObjectYLen = h / 2 * (1 + Math.abs(0.5 - this.jsonObj.pivotY));
    var bBoxInWorld = this.object2World({ x: boxInObjectXLen, y: boxInObjectYLen });

    return Math.sqrt(bBoxInWorld.x * bBoxInWorld.x + bBoxInWorld.y * bBoxInWorld.y);
  };

  p.createBBox = function(sx, sy, rotation, w, h) {
    var shape = new createjs.Shape();
    shape.rotation = rotation;
    var pos = this.getPositionInDc();
    var graph = shape.graphics;
    var x1 = 0;
    var y1 = 0;
    var x2 = w;
    var y2 = h;

    var pts = [
      [x1, y1],
      [x2, y1],
      [x2, y2],
      [x1, y2],
      [x1, y1]
    ];

    var m_trans = TQ.Matrix2D.translation(-x1, -y1);
    var m_rotate = TQ.Matrix2D.transformation(0, 0, rotation, sx, sy);
    var m_trans2 = TQ.Matrix2D.translation(x1, y1);
    var m_all;
    // m_all = m_trans.multiply(m_rotate);
    // m_all = m_all.multiply(m_trans2);

    m_all = m_trans2.multiply(m_rotate);
    m_all = m_all.multiply(m_trans);
    graph.clear();
    graph.beginStroke("#F00");
    graph.moveTo(pts[0][0], pts[0][1]);
    for (let i = 0; i < pts.length; i++) {
      var dp = m_all.multiply($V([pts[i][0], pts[i][1], 1])).elements;
      var x = pos.x + dp[0];
      var y = pos.y + dp[1];

      if (i === 0) {
        graph.moveTo(x, y);
      } else {
        graph.lineTo(x, y);
      }
    }

    return shape;
  };

  p.pinIt = function() {
    this.jsonObj.isPinned = !this.jsonObj.isPinned;
    TQ.DirtyFlag.setElement(this);
    if (this.isGroup()) {
      for (var i = 0; i < this.children.length; i++) {
        var ele = this.children[i];
        if (!ele.isJoint()) ele.pinIt(); // 钉住Group， 但是， 不要钉住关节物体
      }
    }
  };

  Element.getShadow = function() {
    if (!Element._shadow) {
      Element._shadow = new createjs.Shadow("#000000", 1, 1, 10);
    }
    return Element._shadow;
  };

  p._afterItemLoaded = function(resource) {
    if (!this._isNewSkin) {
      this.fillGap2();
      if (this.autoFitFlag && !this.isEditorEle() && !this.isVirtualObject()) {
        this.autoFit(resource);
      }

      if (this.isNewlyAdded) {
        this.forceToRecord();
      }

      if (this.displayObj) { // 声音元素， 没有displayObj
        this.displayObj.isClipPoint = this.jsonObj.isClipPoint;
      }
      this.fillGapAtferAutoFit();
      this.animeTrack = this.jsonObj.animeTrack;
      if (this.level.isStageReady()) {
        if (this.jsonObj.t0 !== undefined) { // 必须是在 立即插入模式
          if (!this.jsonObj.isVis) {
            TQ.AnimeTrack.hide(this, this.jsonObj.t0); // 适合于3D视图，长期隐藏
          } else {
            TQ.AnimeTrack.hideToNow(this, this.jsonObj.t0);
          }
        }
      }
    }

    if (this._isNewSkin) { // 编程哲学: 多用 是, 少用 非, 符合一般人的思维逻辑, 通顺.
      // ToDo: 替换的背景,皮肤，要不要受旧背景TRSA参数的限制？
      // if (Element.isBackground(this.jsonObj)) {
      //     if (this.autoFitFlag && !this.isEditorEle() && !this.isVirtualObject()) {
      //         this.autoFit(resource);
      //     }
      // }

      TQ.Log.out("element._afterItemLoaded"); // , 应该只在临时添加的时候, 才调用
      // assertTrue(TQ.Dictionary.INVALID_LOGIC, false); // 应该只在临时添加的时候, 才调用
      TQ.StageBuffer.add(this); // 统一进入 stage的渠道.
      if ((this.jsonObj.zIndex != null) && (this.jsonObj.zIndex >= 0)) { // 原来是group, 没有皮肤, 所以是-1;
        // this.getContainer().setChildIndex(this.displayObj, this.jsonObj.zIndex + 1); //ToDo: 为什么要加1 组合体才正确?
      }
      this._isNewSkin = false;
    } else {
      this.level.onItemLoaded(this);
    }
    this.setFlag(Element.LOADED);
  };

  Element.compare = function(e1, e2) {
    assertNotNull(e1);
    assertNotNull(e2);
    var id1 = e1.jsonObj.zIndex;
    var id2 = e2.jsonObj.zIndex;
    // 凡是出错的地方, 加一道检查,让它主动报错
    assertTrue(TQ.Dictionary.INVALID_LOGIC, id1 >= -1); // group元素, 没有显示物, 所以是-1,
    assertTrue(TQ.Dictionary.INVALID_LOGIC, id2 >= -1); // 元素的可见性顺序 >= -1
    return id1 - id2;
  };

  p.sort = function() {
    this.children.sort(TQ.Element.compare);
  };

  p.toJSON = function() {
    if (!this.jsonObj || !this.canSave()) {
      return null;
    }
    this.highlight(false);
    var data = TQ.Base.Utility.shadowCopy(this.jsonObj);
    // 备注：displayObj 本身里面有Cycle， 无法消除。所以必须让他null。
    // JQuery 调用的toJSON， 只需要这个字段即可， 一定不要在这里调用stringify！
    data.displayObj = null;
    data.animeTrack = this.animeTrack;
    data.animeCtrl = this.animeCtrl;
    data.viewCtrl = this.viewCtrl;
    data.state = (this.state & 0x1F); // 去除高位的动态的flag，不会永久存储到wdm文件中。

    // 保存为相对路径
    if (data.src) {
      data.src = TQ.RM.toRelativeWithoutCache(data.src);
    }

    data.IM = null;
    data.M = null;

    if (this.trace) {
      data.trace = this.trace;
    }

    // 输出孩子的资源
    if (this.children != null) {
      data.children = [];
      for (var i = 0; i < this.children.length; i++) {
        if (!this.children[i].isEditorEle()) {
          var childJson = this.children[i].toJSON();
          if (childJson) {
            data.children.push(childJson);
          }
        }
      }
    }

    // 如果要输出多个字段， 可以采用下面的方式： 不带字段名称， 用数组； 用{}可以自定义字段显示名称
    // [this.jsonObj, this.animeTrack];
    // {"jsonObj":this.jsonObj, "animeTrack": this.animeTrack};
    this.jsonData = data;
    return data;
  };

  p.afterToJSON = function() {
    if (!this.isEditable() || !this.canSave()) {
      return;
    }
    var data = this.jsonData;
    this.jsonData = null;
    //  只是为了输出, 才临时赋值给它, 现在收回.
    if (data) { // 对于BBox，它是null
      data.animeTrack = null;
      data.animeCtrl = null;
      data.viewCtrl = null;
      data.trace = null;
      data.children.splice(0);
    }
    if (this.children != null) {
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].afterToJSON();
      }
    }
  };

  p.isUserControlling = function() {
    // 鼠标右键按下, 就是操作 (不论是否move.
    // 注意: Mousemove事件只在鼠标移动时候发出.  不移动就不发出, 即使 鼠标一直按住该物体.
    return (TQ.InputMap.IsOperating() && TQ.SelectSet.isSelected(this));
  };

  p.attachCtrl = function(controller) {
    this.animeCtrl = controller;
    this.animeCtrl.play("idle"); // 设置缺省的 动作
  };

  p.addAction = function(name, startFrame, endFrame, repeatStyle, gifIconId, forceToUpdate) {
    if (!this.animeCtrl) {
      this.animeCtrl = new TQ.Animation(null);
    }
    var action = new TQ.Action(name, parseInt(startFrame), parseInt(endFrame), repeatStyle, parseInt(gifIconId));
    return this.animeCtrl.addAction(action, forceToUpdate);
  };

  p.deleteAction = function(name) {
    if (!this.animeCtrl) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, this.animeCtrl);
      return;
    }

    this.animeCtrl.deleteAction(name);
  };

  p.hasAction = function(actionName) {
    if (!this.animeCtrl) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, this.animeCtrl);
      return false;
    }

    return this.animeCtrl.hasAction(actionName);
  };

  p.stop = function() {
    if (this.animeCtrl) {
      this.animeCtrl.stop();
    }
    // do no thing for bitmap
  };

  p.play = function() {
  };

  p.playAction = function(name, playByUpdate) {
    if (!this._controlerInst) {
      this._controlerInst = this.getFirstAnimeCtrl();
    }
    if (!this._controlerInst) return;
    this._controlerInst.play(name);
    if (!playByUpdate) {
      this.setFlag(TQ.Element.ACTION_CHANGED);
      TQ.ActionRecorder.record(this, name, TQ.FrameCounter.t());
      if (!TQ.FrameCounter.isPlaying()) {
        $("#play").click();
      }
    }
  };

  p.getActionSet = function() {
    var controller = this.getFirstAnimeCtrl();
    if (controller != null) {
      return controller.actionTable;
    }

    return null;
  };

  // ToDo: 这里假设一个元件中, 只有一个animeCtrl. 这是一个限制, 以后需要支持多个
  p.getFirstAnimeCtrl = function() {
    if (this.animeCtrl) {
      return this.animeCtrl;
    }

    var result = null;
    if (this.children) {
      for (var i = 0; i < this.children.length; i++) {
        result = this.children[i].getFirstAnimeCtrl();
        if (!result) continue;
        break;
      }
    }

    return result;
  };

  p.updateAction = function(t) {
    if (!this.hasActionTrack()) return;

    // ToDo: 可以解除限制， 支持多套动作， 例如： 脸部动作， 肢体动作， 嘴巴动作等
    // 方法是： 每套动作， 对应一个animeTrack和一个Controller，i.e. 把下面的内容归到各个controller
    var newName = TQ.ActionDecoder.calculate(this.animeTrack, t);
    var isNewAction = false;
    if (!this.currentActionName) {
      this.currentActionName = newName;
      isNewAction = true;
    } else if (this.currentActionName !== newName) {
      this.currentActionName = newName;
      isNewAction = true;
    }

    if (isNewAction) {
      this.playAction(this.currentActionName, true);
    }
  };

  p.update = function(t, noRecording) {
    noRecording = !!noRecording;
    var justRecorded = false;
    if (!this.isLoaded()) return;

    TQ.Log.debugInfo("update: " + (noRecording ? "NR " : "") + this.jsonObj.type + this.id + ", t = " + t + "(x,y) = " + this.jsonObj.x + ", " + this.jsonObj.y);
    if (this.hasActionTrack()) { // 更新使用者的动作track，
      this.updateAction(t);
    }

    if (this.animeCtrl) { // 更新 拥有者的 时间
      if (this.animeCtrl.currentAction) {
        t = this.animeCtrl.currentAction.tMapping(t);
      }
    }

    // 如果有拍摄, 先拍摄
    var motionType = 0; // 没有变化, 使用上一个时刻的 世界坐标
    if (!noRecording && this.allowRecording() && !TQBase.LevelState.isOperatingTimerUI()) {
      if (this.dirty2 || this.isUserControlling()) {
        justRecorded = this.updateRecord(t);
        motionType += 0x02;
      }
    }

    // 播放过程:
    // 1) 生成世界坐标:
    var parentTSR = (this.parent == null) ? null : this.parent.jsonObj;
    var result = this.updateTSR(t, justRecorded, motionType);
    var tsrObj = result.tsrObj;

    // TSR 从物体坐标系到 世界坐标系
    this.updateM(parentTSR, tsrObj);
    this.tsrObject2World(tsrObj);

    // 1.3) 没有动画的物体, 也没有被操作,被移动, jsonObj 已经是世界坐标

    // 2) 从世界坐标 到 设备坐标
    this.setTRSAVZ();
    this.updateChildren(t);

    this.updateHighlighter();
    this.dirty = this.dirty2 = false;

    if (this.isNewlyAdded) {
      this.isNewlyAdded = false;
      TQUtility.triggerEvent(document, Element.EVENT_NEW_ELEMENT_ADDED, { element: this });
    }

    if (this.hookInMove) {
      this.hookInMove(this, this);
    }
  };

  p.updateRecord = function(t) {
    TQ.Log.debugInfo("update: Record, lastOperationFlag =" + TQBase.Trsa.lastOperationFlag);
    if (!this.getOperationFlags()) { // 鼠标按住, 但是 没有移动, 单独确定操作状态
      this.setFlag(TQBase.Trsa.lastOperationFlag);
      // TQ.Log.out("操作: " + TQBase.Trsa.lastOperationFlag +"last");
    }
    //  不能在此记录, 因为, Move, Rotate操作的时候, 不调用它update
    TQ.Pose.tsrWorld2Object(this);
    TQ.Assert.isTrue(!isNaN(TQ.Pose.x), "x 为 NaN！！！");
    TQ.Assert.isTrue(!isNaN(TQ.Pose.y), "y 为 NaN！！！");
    // 记录修改值
    TQ.TrackRecorder.record(this, t);
    return true;
  };

  p.updateTSR = function(t, justRecorded, motionType) {
    var tsrObj = null;
    if (this.hasAnimation()) { //  动画物体
      // 即使是 用户操作的物体, 也需要重新生成, 因为用户只操作了其中的几个轨道,
      //  而其余的轨道, 仍然需要使用原来的数据,
      // 当然, 此刻的计算,一是为此刻的显示, 二是为下一时刻的修改. 两用的.
      // 1.1A) 从动画轨迹 到物体坐标
      // 如果有动画数据, 才需要解码,生成新的 世界坐标. 否则,跳过
      // 先生成新的 物体坐标(TQ.Pose), 再转化到世界坐标系
      TQ.Log.debugInfo("update: regenerate coordinates 1: hasAnimation");
      var tt = t;
      if (justRecorded && (TQ.TrackRecorder.style === TQ.Channel.JUMP_INTERPOLATION)) {
        tt = t + 0.01; // 在脉冲运动下，迫使系统采用最新的位置
      }
      if (this.isSound() && this.isCrossLevel) { // 支持跨场景的声音
        tt = currScene.toGlobalTime(tt);
      }
      TQ.TrackDecoder.calculate(this, tt); // 计算结果在Pose中，是 物体坐标系的）
      // 1.1B): 从物体坐标 TQ.Pose. 到世界坐标
      tsrObj = TQ.Pose;
      motionType += 0x04;
    } else if (this.isMarker()) {
      TQ.Log.debugInfo("update: regenerate coordinates 2: is Marker");
      tsrObj = this.getTsrInHostObj();
    } else if ((motionType === 0) && this.dirty) {
      // 1.2) 但是, 如果父物体移动了, 它也被动地被要更新
      TQ.Log.debugInfo("update: regenerate coordinates 3: 被动更新");
      tsrObj = TQ.CreateJSAdapter.getDefaultRootTsr();
    } else {
      TQ.Log.error("unknown case");
      tsrObj = null;
    }

    tsrObj.mirrorX = this.jsonObj.mirrorX;
    tsrObj.mirrorY = this.jsonObj.mirrorY;
    return { tsrObj: tsrObj, motionType: motionType };
  };

  p.updateChildren = function(t) {
    if (this.jsonObj.isClipPoint === false) {
      assertArray(TQ.Dictionary.INVALID_LOGIC, this.children); // "children可以是空数组[], 但不能为null，或undefined"
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        var noRecordingInChild = !TQ.InputCtrl.inSubobjectMode || !(child.dirty || child.dirty2 || child.isUserControlling());
        // 传播dirty标志, 迫使child更新; dirty2的子关节不记录track
        if (this.dirty || this.dirty2) this.children[i].dirty = true;
        if (!(this.isMarker() && this.children[i].isUserControlling())) {
          TQ.Log.debugInfo("update children");
          this.children[i].update(t, noRecordingInChild); // 如果孩子被操作，则应该允许孩子记录，虽然父不记录。
          // 对孩子的传播，都是被动的，纯更新，不记录。
        }
      }
    }
  };

  // Marker 专用部分
  p.calPivot = function(ptWorld) {
    // 应该获取原始的 宽度和 高度， 在物体空间（也是原始的），来计算pivot值
    // 数据模型中的pivot永远是[0,1]规范化的， 在显示的时候转为createJS的像素格式
    var dpObject = this.world2Object(ptWorld);
    var dx = dpObject.x / this.getWidth();
    var dy = dpObject.y / this.getHeight();
    return { pivotX: this.jsonObj.pivotX + dx, pivotY: this.jsonObj.pivotY + dy };
  };

  p.movePivot = function(pivot, ptWorld, marker) {
    TQ.Log.debugInfo("movePivot: ptWorld.x = " + ptWorld.x);
    this.moveTo(ptWorld);
    this.update(TQ.FrameCounter.t()); // 必须单独更新， 否则与pivot一起更新会不准确

    this.jsonObj.pivotX = pivot.pivotX;
    this.jsonObj.pivotY = pivot.pivotY;

    this.dirty = true;
  };

  p._move_TBD_NOT_USED = function(dx, dy) {
    this.jsonObj.x += dx;
    this.jsonObj.y += dy;
    this.setFlag(Element.TRANSLATING);
  };

  p.snapIt = function() {
    if (TQ.Config.snapOn) {
      var ptWorld = this.getPositionInWorld();
      ptWorld.x = Math.round(ptWorld.x / TQ.Config.snapDX) * TQ.Config.snapDX;
      ptWorld.y = Math.round(ptWorld.y / TQ.Config.snapDY) * TQ.Config.snapDY;
      this.moveTo(ptWorld);
    }
  };

  function snapAngle(angle) {
    // 角度钳制： 如果非常靠近90度的整数倍，则取该度数
    if (TQ.Config.snapAngleOn) {
      var k = angle / 90;
      var kRound = Math.round(k);
      var toloerance = (k - kRound);
      if (Math.abs(toloerance) < 0.05) {
        angle = kRound * 90;
      }
    }

    return angle;
  }

  p.moveTo = function(ptWorld) {
    if (this.isPinned()) {
      return;
    }

    TQ.Assert.isTrue(!isNaN(ptWorld.x), "x 为 NaN！！！");
    TQ.Assert.isTrue(!isNaN(ptWorld.y), "y 为 NaN！！！");

    this.jsonObj.x = ptWorld.x;
    this.jsonObj.y = ptWorld.y;

    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
    this.setFlag(Element.TRANSLATING);
    TQ.DirtyFlag.setEdited(this);
    this.dirty2 = true;
  };

  p.onMoveMarker = function(marker, ptWorld) {
    // 默认marker是pivot的， 对于anchor marker等， 必须另外重载
    TQ.CommandMgr.directDo(new TQ.MovePivotCommand(this,
      this.calPivot(ptWorld),
      ptWorld,
      marker));
  };

  p.getScaleInNdc = function() {
    return { sx: this.jsonObj.sx, sy: this.jsonObj.sy };
  };

  p.getRotation = function() {
    return this.jsonObj.rotation;
  };

  p.rotate = function(angle) {
    this.rotateTo(this.jsonObj.rotation + (this.getRotateDirection() * angle));
  };

  p.getRotateDirection = function() {
    var direction = 1;
    if (this.jsonObj.mirrorX) {
      direction = -direction;
    }
    if (this.jsonObj.mirrorY) {
      direction = -direction;
    }
    if (this.parent) {
      return direction * this.parent.getRotateDirection();
    }
    return direction;
  };
  p.getMirrorX = function() {
    var result = this.jsonObj.mirrorX;
    if (this.parent) {
      if (result) {
        result = !this.parent.getMirrorX();
      } else {
        result = this.parent.getMirrorX();
      }
    }
    return result;
  };

  p.getMirrorY = function() {
    var result = this.jsonObj.mirrorY;
    if (this.parent) {
      if (result) {
        result = !this.parent.getMirrorY();
      } else {
        result = this.parent.getMirrorY();
      }
    }
    return result;
  };

  p.rotateTo = function(angle) {
    if (this.isPinned()) {
      return;
    }

    this.jsonObj.rotation = snapAngle(angle);
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
    this.setFlag(Element.ROTATING);
    TQ.DirtyFlag.setEdited(this);
    this.dirty2 = true;
  };

  p.scaleTo = function(scaleInWorld) {
    if (this.isPinned()) {
      return;
    }

    TQ.Assert.isTrue(!isNaN(scaleInWorld.sx), "x 为 NaN！！！");
    TQ.Assert.isTrue(!isNaN(scaleInWorld.sy), "y 为 NaN！！！");

    this.jsonObj.sx = scaleInWorld.sx;
    this.jsonObj.sy = scaleInWorld.sy;
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
    this.setFlag(Element.SCALING);
    TQ.DirtyFlag.setEdited(this);
    this.dirty2 = true;
  };

  p.mirrorX = function() {
    if (this.isPinned()) {
      return;
    }

    this.jsonObj.mirrorX = !this.jsonObj.mirrorX;
    TQ.DirtyFlag.setEdited(this);
    this.dirty2 = true;
  };

  p.mirrorY = function() {
    if (this.isPinned()) {
      return;
    }

    this.jsonObj.mirrorY = !this.jsonObj.mirrorY;
    TQ.DirtyFlag.setEdited(this);
    this.dirty2 = true;
  };

  p.scaleAndRotateTo = function(scaleAndRotate) {
    TQ.Assert.isTrue((scaleAndRotate.angle !== undefined) &&
      (scaleAndRotate.scale !== undefined), "参数取值错误");
    this.rotateTo(scaleAndRotate.angle);
    this.scaleTo(scaleAndRotate.scale);
  };

  p.scale = function(scale) {
    var scaleTo = {
      sx: scale * this.jsonObj.sx,
      sy: scale * this.jsonObj.sy
    };

    this.scaleTo(scaleTo);
  };

  p.updateDecorations = function(t) {
    if (!this.decorations) {
      return; // 例如: 本身是decoration, 没有其他decoration
    }
    for (var i = 0; i < this.decorations.length; i++) {
      var dec = this.decorations[i];
      if (!dec) continue;
      dec.update2(t);
    }
  };

  p.applyToDecorations = function() {
    if (!this.decorations) {
      return; // 例如: 本身是decoration, 没有其他decoration
    }
    for (var i = 0; i < this.decorations.length; i++) {
      var dec = this.decorations[i];
      if ((dec != null) && dec.isUserControlling()) { // 迫使Market重新计算， Marker没有动画, 永远都在pivot点
        dec.apply(this);
      }
    }
  };

  p.calculateLastFrame = function() {
    var tMax = 0;
    if (this.animeTrack) {
      tMax = Math.max(tMax, this.animeTrack.calculateLastFrame());
    }

    if (this.children) {
      for (var i = 0; i < this.children.length; i++) {
        tMax = Math.max(tMax, this.children[i].calculateLastFrame());
      }
    }

    return tMax;
  };

  // upgrade 工具：
  Element.upgrade = function(jsonStr) {
    // 资源路径的变换：2013.3.30: 合并到 yt360
    // "assets/" 为"mcAssets/"
    // "sounds/" 为"mcSound/"
    // "images/" ==》 ”mcImages";
    if (jsonStr.indexOf("images/") >= 0) {
      jsonStr = jsonStr.replace("images/", TQ.Config.IMAGES_CORE_PATH);
    }

    if (jsonStr.indexOf("assets/") >= 0) {
      jsonStr = jsonStr.replace("assets/", TQ.Config.SCENES_CORE_PATH);
    }

    if (jsonStr.indexOf("thumbs/") >= 0) {
      jsonStr.replace("thumbs/", TQ.Config.THUMBS_CORE_PATH);
    }

    // 相对路径和绝对路径的映射，统一到RM管理
    return jsonStr;
  };

  // 小函数区域: has, is, 这些函数容易理解, 放到最后, 让重要的函数, 需要经常看的函数,放到前面
  p.setText = function(htmlStr) {
    assertDepreciated(TQ.Dictionary.isDepreciated + "， 移到了text元素中！");
  };

  p.setColor = function(color) {
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_FLOATTOOLBAR);
    this.setFlag(Element.COLOR_CHANGED);
    TQ.DirtyFlag.setEdited(this);
    this.dirty2 = true;
  };

  p.hasAnimation = function() {
    return (!((this.animeTrack === undefined) || (this.animeTrack == null)));
  };

  p.is = function(type) {
    return (this.jsonObj.type === type);
  };

  Element.isBackground = function(desc) {
    return (desc && desc.eType && (desc.eType === TQ.Element.ETYPE_BACKGROUND));
  };

  p.isLoaded = function() {
    return this.loaded;
  };

  p.isComposed = function() {
    if (!this.children || this.children.length < 1) {
      return false;
    }

    var hasNonEditorElement = false;
    this.children.some(function(child) {
      return (hasNonEditorElement = !child.isEditorEle());// 找到一个true就终止循环
    });
    return hasNonEditorElement;
  };

  p.isClipPoint = function() {
    return this.jsonObj.isClipPoint;
  };

  p.isBitmap = function() {
    return (!!this.displayObj && (this.displayObj instanceof createjs.Bitmap));
  };

  p.hasGraph = function() {
    var result = this.isBitmap();
    if (!result && this.children && this.children.length > 0) {
      this.children.some(function(ele) {
        if (ele.hasGraph()) {
          result = true;
          return true;
        }
      });
    }

    return result;
  };

  p.isText = function() {
    return false;
  };
  p.isSound = function() {
    return (this.jsonObj.type === DescType.SOUND);
  };
  p.isVideo = function() {
    return (this.jsonObj.type === DescType.VIDEO);
  };
  p.isGroupFile = function() {
    return (this.jsonObj.type === DescType.GROUP_FILE);
  };
  p.isGroup = function() {
    return (this.jsonObj.type === DescType.GROUP);
  };

  p.isGrouped = function() {
    return (this.isGroup() || this.isGroupFile());
  };

  p.isButton = function() {
    return false;
  };
  p.isSelectable = function() {
    return true;
  };

  p.isDisplayabled = function() { // 可显示的简单物体，或者组合体
    return (this.isBitmap() || this.isText() || this.isButton() ||
      this.isGroup() || this.isGroupFile());
  };

  p.getTextHtml = function() {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, this.isText());
    return this.toHtmlStr();
  }; // 必须是Text
  p.getFont = function() {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, this.isText());
    return this.jsonObj.font;
  }; // 必须是Text
  p.isLeaf = function() {
    return ((this.children == null) || (this.children.length < 1));
  };
  p.isRoot = function() {
    return (this.hasFlag(Element.ROOT_JOINT));
  };
  p.isJoint = function() {
    return ((this.parent != null) && (this.hasFlag(Element.JOINTED)));
  };
  p.isBone = function() {
    return this.isJoint() || this.isRoot();
  };
  p.isFEeffect = function() {
    return false;
  };
  p.isMarker = function() {
    return false;
  };

  p.isBBox = function() {
    return false;
  };

  p.isHighlighter = function() {
    return false;
  };

  p.isHighlighting = function() {
    return this._isHighlighting;
  };

  p.isEditorEle = function() {
    // 只是给Editor用的临时元素， 比如：用于亮显选中元素转轴点的marker， 边界框BBox等等，
    // 这种元素， 不能保存到文件中， 也不出现在截图中， 在Z图层升降中，也忽略他们
    return (this.isBBox() || this.isMarker());
  };

  p.isVirtualObject = function() { // 虚拟物体包括： Group(displayObj 非空), 声音(displayObj 为空)，等
    if (!this.displayObj) {
      return this.isSound();
    }
    assertNotNull(TQ.Dictionary.FoundNull, this.displayObj); // 应该有可显示对象
    return ((this.displayObj.image == null) && (this.isGroup()));
  };
  p.isValid = function() { // 非法的物体包括: 被删除的物体
    return (this.jsonObj || this.displayObj);
  };
  p.isPinned = function() {
    return (this.jsonObj.isPinned);
  };
  p.isVisible = function() {
    if (!this.displayObj) {
      return this.visibleTemp;
    } else if (!this.displayObj.visible) {
      return this.visibleTemp;
    }
    return this.displayObj.visible;
  };

  p.isInCurrentLevel = function() {
    return (currScene && currScene.currentLevel && (currScene.currentLevel === this.level));
  };

  p.hasBroken = function() {
    return (this.hasFlag(Element.BROKEN));
  };

  p.isVer2plus = function() {
    return ((this.version === TQ.Element.VER2) ||
      ((typeof this.version === "number") && (this.version >= Element.VER3)));
  };

  p.getRoot = function() { // 任何时候, 都是root, 唯一化
    if (this.isGrouped()) {
      if (this.parent != null) return this.parent.getRoot();
    }
    return this;
  };

  p.setMinAngle = function(newValue) {
    this.jsonObj.angleMin = newValue;
  };
  p.setMaxAngle = function(newValue) {
    this.jsonObj.angleMax = newValue;
  };
  p.removeLimitation = function() {
    if (this.jsonObj.angleMax !== undefined) {
      this.jsonObj.angleMax = null;
    }
    if (this.jsonObj.angleMin !== undefined) {
      this.jsonObj.angleMin = null;
    }
  };
  p.moveZ = function(step) {
    TQ.MoveCtrl.cmdMoveLayer(this, step);
  };
  p.moveToZ = function(newZ) {
    this.moveZ(newZ - this.getZ());
  };
  p.getType = function() {
    return (this.jsonObj.type);
  };
  p.getEType = function() {
    return (this.jsonObj.eType);
  };
  p.setFlag = function(flag) {
    this.state |= flag;
  };
  p.clearFlag = function(flag) {
    this.state &= ~flag;
  };
  p.hasFlag = function(flag) {
    return this.state & flag;
  };
  p.hasActionTrack = function() {
    return (this.animeTrack && this.animeTrack.action);
  };
  p.allowRecording = function() {
    return true; // 缺省下， 所有元素都支持recording，
  };
  p.getOperationFlags = function() {
    return (this.state & 0xFFF0);
  };

  p.getAlias = function() {
    return null;
  };

  p.getResourceName = function() {
    if (this.jsonObj) {
      return this.jsonObj.resName || TQ.RM.getNameFromUrl(this.jsonObj.src);
    }
    return "";
  };

  p.getResourcePath = function() {
    if (this.jsonObj) {
      return this.jsonObj.src;
    }
    return null;
  };

  p.getMaxZ = function() {
    if (!this.isComposed()) {
      return this.getZ();
    }

    var n = this.children.length;
    var maxZ = this.getZ();
    var child;

    for (var i = 0; i < n; i++) {
      child = this.children[i];
      if (child.isEditorEle()) {
        continue;
      }
      maxZ = Math.max(maxZ, child.getMaxZ());
    }

    return maxZ;
  };

  p.getMinZ = function() {
    if (!this.isComposed()) {
      return this.getZ();
    }

    var n = this.children.length;
    var minZ = this.getZ();
    var child;

    for (var i = 0; i < n; i++) {
      child = this.children[i];
      if (child.isEditorEle()) {
        continue;
      }
      minZ = Math.min(minZ, child.getMinZ());
    }

    return minZ;
  };

  p.getZ = function() { // 如果是没有Z值的(例如:Group,等), 则返回其首个有Z值孩子的值
    // 只是被 moveLayer命令的undo使用, 没有用于物体顺序的保存
    var target = this.displayObj;
    var z = (!target) ? -1 : this.getContainer().getChildIndex(target);
    if (z >= 0) {
      return z;
    }
    if (this.children) {
      for (var i = 0; i < this.children.length; i++) {
        if (!this.children[i] || this.children[i].isHighlighter()) {
          continue;
        }
        z = this.children[i].getZ();
        if (z >= 0) {
          return z;
        }
      }
    }

    if (this._isNewSkin) {
      // 正在换皮肤..., 旧的已经从stage移除，新的尚未进来
      return this.jsonObj.zIndex;
    }
    if (this.hasGraph()) {
      assertTrue(TQ.INVALID_LOGIC + "没有可见物体的group", false);
    }
    return z;
  };

  p.getColor = function() {
    return (this.jsonObj.color === undefined) ? TQ.Config.color : this.jsonObj.color;
  };

  p.getAlpha = function() {
    return (this.jsonObj.alpha === undefined) ? 1 : this.jsonObj.alpha;
  };

  p.isEditable = function() {
    return true;
  };

  p.canSave = function() {
    return true;
  };

  p.getSags = function() {
    return (this.animeTrack) ? this.animeTrack.getSags() : null;
  };

  p.hasBBox = function() {
    return this.has(DescType.BBOX);
  };

  p.has = function(type) {
    var result = false;
    if (this.decorations) {
      this.decorations.some(function(item) {
        return (result = item.is(type));
      });
    }

    return result;
  };

  p.getBBox = function() {
    return this.getDecor(DescType.BBOX);
  };

  p.getDecor = function(type) {
    var decor = null;
    if (this.decorations) {
      this.decorations.some(function(item) {
        if (item.is(type)) {
          decor = item;
          return true;
        } else {
          return false;
        }
      });
    }

    return decor;
  };

  p.forEachChildren = function(memberFunctionName) {
    if (this.children != null) {
      this.children.forEach(function(child) {
        TQ.Assert.isTrue(!!child[memberFunctionName], "调用不存在的成员函数： " + memberFunctionName);
        if (child[memberFunctionName]) {
          child[memberFunctionName]();
        }
      });
    }
  };

  TQ.Element = Element;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};
(function() {
  /*
     * Point: 是点状元素，Element类的特殊子类. 必须附在某个host上， 但是与host的相对位置不固定
     * 没有旋转，固定大小, 位置可变。
     * 不可修改形状和大小
     */
  var POINT_RADIUS = 10;
  function Point(level, desc, host) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof desc !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.host = host;
    TQ.Element.call(this, level, desc); // 调用父类的初始化函数， 在子类构造函数中
  }

  var p = Point.prototype = Object.create(TQ.Element.prototype); // 继承父类的函数, 子类构造函数的参数，限制少

  p.constructor = Point; // 把构造函数也放到prototype中, 是的copy，clone之类的函数， 可以返回本子类的类别
  p._parent_update = p.update;

  p.update = function() {
    this.anchor.world = this.host.object2World(this.anchor.obj);
    this.jsonObj.x = this.anchor.world.x;
    this.jsonObj.y = this.anchor.world.y;
    this.setTRSAVZ();
    this.dirty = this.dirty2 = false;
  };

  p.updateLayer = function() { //  总是紧接着host的下一层
  };

  p.createImage = function() {
    // 将替换已有的image，如果有的话
    var s = this.displayObj;
    if (!s) {
      TQ.Log.criticalError(TQ.Dictionary.FoundNull);
      return;
    }

    s.graphics.clear(); // 清除老的边框
    TQ.Graphics.drawCircle(s, 0, 0, POINT_RADIUS);
  };

  p.createModal = function() {
    this.createImage();
  };

  p._doLoad = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var s = new createjs.Shape();
    this.loaded = true;
    s.x = 0;
    s.y = 0;
    this.displayObj = s;
    this.createModal();
    this._afterItemLoaded();
    this.setTRSAVZ();
  };

  p.apply = function(ele) {
    this.dirty2 = true;
  };

  p.isPoint = function() {
    return true;
  };

  p.isEditable = function() {
    return false;
  };

  p.getWidth = function() {
    return POINT_RADIUS;
  };

  p.getHeight = function() {
    return POINT_RADIUS;
  };

  p.allowRecording = function() {
    return false;
  };

  p.toJSON = function() { // 不保存
    return null;
  };

  p.recycle = function() {
    var aMarker = this;
    aMarker.removeFromStage();
  };
  p.moveToTop = p.reset = function() {
  };

  function compose(host) {
    // 除了pivot，其余都是物体坐标系下的缺省值
    var jsonObj = {
      type: TQ.ElementType.POINT,
      x: 0,
      y: 0,
      sx: 1,
      sy: 1,
      rotation: 0
    };
    jsonObj.pivotX = 0;
    jsonObj.pivotY = 0;
    return jsonObj;
  }

  Point.attachTo = function(host, anchor) {
    TQ.AssertExt.isNotNull(host);
    if (anchor) {
      var desc = compose();
      var point = TQ.Element.build(host.level, desc, host);
      point.anchor = anchor;
      host.attachDecoration([point]);
      point.update(); // 必须update以计算坐标
    }

    return point;
  };

  Point.detachFrom = function(host) {
    TQ.AssertExt.invalidLogic(host);
    if (host) {
      var pt = this;
      pt.doShow(false);
      host.removeChild(pt);
    }
  };

  TQ.Point = Point;
}());

/**
 * Created by Andrewz on 3/25/2017.
 */
TQ = TQ || {};

(function() {
  // 用法: GroupElement, 一个container， 包裹其子孙
  function GroupElement(level, jsonObj) {
    TQ.Element.call(this, level, jsonObj);
  }

  GroupElement.create = create;

  function create(level, elements) {
    TQ.Log.out("Group it");
    if (!elements || !elements.length) {
      return;
    }

    // 以第一个物体的参数为主, 建立Group元素.
    var pos = elements[0].getPositionInWorld();
    var desc = {
      x: pos.x, // elements[0].jsonObj.x,
      y: pos.y, // elements[0].jsonObj.y,
      type: TQ.ElementType.GROUP,
      eType: elements[0].jsonObj.eType, // Group的eType同其1st孩子
      autoFit: TQ.Element.FitFlag.KEEP_SIZE
    };
    var ele = TQ.Element.build(level, desc);
    var expectedZ = calZ(elements);
    stageContainer.addChildAt(ele.displayObj, expectedZ);
    ele.update(TQ.FrameCounter.t());

    for (let i = 0; i < elements.length; i++) {
      level.pickOffChild(elements[i]);
      ele.addChild(elements[i]);
      if (TQ.Config.useCreateJSFullContainer) {
        stageContainer.removeChild(elements[i].displayObj);
        ele.displayObj.addChild(elements[i].displayObj);
      }
    }

    if (TQ.Config.useCreateJSFullContainer) {
      for (let i = 0; i < elements.length; i++) {
        stageContainer.addChild(elements[i].displayObj);
        ele.displayObj.removeChild(elements[i].displayObj);
      }
    }

    return ele;
  }

  function calZ(elements) {
    var expectedZ = elements[0].getZ();
    var n = elements.length;
    for (var i = 0; i < n; i++) {
      expectedZ = Math.max(expectedZ, elements[i].getZ());
    }
    return expectedZ - n + 1;
  }

  var p = GroupElement.prototype = Object.create(TQ.Element.prototype);
  p._doLoad = function() {
    assertNotNull(TQ.Dictionary
      .FoundNull, this.jsonObj); // 合并
    // 建立空的 displayObj 以容纳设备空间的参数
    this.displayObj = new createjs.Container();
    this.loaded = true;
    this._afterItemLoaded();
    this.setTRSAVZ();
  };

  p.getWidth = function() {
    return (this.children.length < 2) ? 1 : this.children[0].getWidth();
  };

  p.getHeight = function() {
    return (this.children.length < 2) ? 1 : this.children[0].getHeight();
  };

  p.getWidthAfterScale = function() {
    const scale = (this.children.length < 2) ? 1 : this.children[0].getScale();
    return (this.getWidth() * scale.sx);
  };

  p.getHeightAfterScale = function() {
    const scale = (this.children.length < 2) ? 1 : this.children[0].getScale();
    return (this.getHeight() * scale.sy);
  };

  p._initializeComponent = function(desc) {
    // 如果从groupFile来的，
    if ((this instanceof TQ.GroupElement) && (this.isElementFile)) {
      this.setupZIndex();
    }

    TQ.StageBuffer.open();
    this.initialize(desc);
    TQ.StageBuffer.close();
    TQ.DirtyFlag.setElement(this); // 强制更新group元素的时间
    const self = this;
    currScene.currentLevel.registerHandler(function() {
      self.shrinkToStage();
    });
  };

  // 如果超出了屏幕范围，则缩小比例，以占据屏幕正中心的80%
  p.shrinkToStage = function() {
    const geoBox = this.calGeoBox();
    const scale = Math.min(currScene.getDesignatedWidth() * 0.8 / geoBox.getWidth(),
      currScene.getDesignatedHeight() * 0.8 / geoBox.getHeight());
    if (scale < 1) {
      // tips: 必须用Timeout包裹，才能正确地更新,否则，画面不改变
      setTimeout(function() {
        self.scale(scale);
      });
    }
  };

  p.loadFromFile = function(jsonFiledesc) {
    var opusDesc;
    this.children = [];
    // 调入 json文件, 取其中的 elements
    (function(pt) {
      $.ajax({
        type: "GET",
        url: jsonFiledesc.src
      }).done(function(jqResponse) {
        try {
          var opusJson = TQ.Scene.decompress(jqResponse.data);
          opusDesc = JSON.parse(TQ.Element.upgrade(opusJson));
        } catch (e) {
          displayInfo2(jqResponse);
          TQ.Log.error(jqResponse + ". " + e.toString());
          // 给一个空白文件， 确保可持续进行
          opusDesc = TQ.Scene.getEmptySceneJSON();
        }

        if (opusDesc.version !== TQ.Scene.VER_LATEST) {
          TQ.Scene.upgradeToLatest(opusDesc);
        }

        var groupEleDesc = pt._extractComponent(opusDesc, jsonFiledesc.x, jsonFiledesc.y, jsonFiledesc.zIndex);
        groupEleDesc.t0 = jsonFiledesc.t0;

        pt.isElementFile = true;
        if (!TQ.RM.isEmpty) {
          TQ.RM.onCompleteOnce(function() {
            pt._initializeComponent(groupEleDesc);
          });
        } else { // 资源都已经装入了，
          pt._initializeComponent(groupEleDesc);
        }
      });
    })(this);

    // 对元件文件, 生成了一个Group，他们也需要 一个 animeTrack
    this.animeTrack = this.jsonObj.animeTrack;
  };

  p._extractComponent = function(objJson, x, y, zMax) {
    if (!this.jsonObj) {
      this.jsonObj = {};
    }

    if (!this.jsonObj.children) {
      this.jsonObj.children = [];
    }

    // ToDo: 暂时只支持1个level的组件，（下面的多level合并逻辑，要重新考虑）
    // 选取 元件中的所有元素, 作为当前元素的子元素, 如果有多个level, 则合并到一个Level
    if (objJson.levels.length > 1) {
      objJson.levels.splice(1);
      TQ.Log.error("元件只能有1个场景");
    }

    if (objJson.levels[0].elements.length > 1) {
      TQ.Log.error("元件只能有1个根元素");
      objJson.levels[0].elements.splice(1);
    }

    var component = objJson.levels[0].elements;
    TQ.RM.addElementDescList(component);
    this.jsonObj = component[0];
    this.jsonObj.type = "Group"; // 不论是单个物体还是多个物体,总是建立虚拟物体group， 以保留其原有的动画
    this.jsonObj.x = x;
    this.jsonObj.y = y;
    this.jsonObj.zIndex = zMax;
    return this.jsonObj;
  };

  p.setupZIndex = function() {
    // 新插入的元件，元件各个子元素的zIndex要升高，使他置于top，可见
    if (!this.level.isActive()) {
      return;
    }

    var zMax = TQ.Utility.getMaxZ();
    var pool = [];
    var children = this.jsonObj.children;

    pool.push(this.jsonObj);
    if (children) {
      pool = pool.concat(getChildrenFromDesc(children));
      pool.sort(compareDesc);
      for (let i = 0; i < pool.length; i++) {
        if (pool[i]) {
          pool[i].zIndex = zMax + i;
        }
      }
    }

    function compareDesc(desc1, desc2) {
      assertNotNull(desc1);
      assertNotNull(desc2);
      var id1 = desc1.zIndex;
      var id2 = desc2.zIndex;
      // 凡是出错的地方, 加一道检查,让它主动报错
      assertTrue(TQ.Dictionary.INVALID_LOGIC, id1 >= -1); // group元素, 没有显示物, 所以是-1,
      assertTrue(TQ.Dictionary.INVALID_LOGIC, id2 >= -1); // 元素的可见性顺序 >= -1
      return id1 - id2;
    }
  };

  function getChildrenFromDesc(children) {
    var pool = [];
    for (let i = 0; i < children.length; i++) {
      pool.push(children[i]);
      if (children[i].children) {
        pool = pool.concat(getChildrenFromDesc(children[i].children));
      }
    }
    return pool;
  }

  TQ.GroupElement = GroupElement;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  var SOUND_TYPE_DUB = 0; // 实时配音， 新配音可以自动覆盖旧的,缺省值
  var SOUNT_TYPE_EFFECT = 1; // 声音特效， 声音文件，从声音库添加，不能自动覆盖，必须手动删除旧的
  // 用法: 1) 拖入, 只有声音的 resource 名称,
  //       2) 从scene中读入, 是 JSON
  //  必须是用工厂生产这个元素, 因为, 是数据决定元素的类别.
  function SoundElement(level, jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.instance = null;
    this.isFirstTimePlay = true;
    if (jsonObj.t0) { // 记录声音的插入点， 只在插入点开始播放
      this.t0 = jsonObj.t0;
    } else {
      this.t0 = 0;
    }
    TQ.Element.call(this, level, jsonObj);
    this.isCrossLevel = (jsonObj.isCrossLevel !== undefined ? jsonObj.isCrossLevel
      : (!!this.isVer2plus()));
  }

  SoundElement.srcToObj = function(src) {
    return ({ type: "SOUND", src: src, isVis: 1 });
  };
  SoundElement.setAsDub = function(desc) {
    desc.subType = SOUND_TYPE_DUB;
  };
  SoundElement.setAsEffect = function(desc) {
    desc.subType = SOUNT_TYPE_EFFECT;
  };

  var p = SoundElement.prototype = Object.create(TQ.Element.prototype);

  SoundElement.prototype.constructor = SoundElement;
  p._parent_doShow = p.doShow;
  p.doShow = function(isVisible) {
    this._parent_doShow(isVisible);
    if (isVisible) {
      this.play();
    } else {
      this.stop();
    }
  };

  SoundElement.composeResource = function(res) {
    // wav: 都可以用(似乎IE不行）, 已经被FF24.0，CM29.0， SF5.1.7都支持了！！！
    // MP3: IE, CM, SF： ==》 ogg: 火狐, opera
    var currentBrowser = createjs.BrowserDetect;
    var newRes = null;
    if (currentBrowser.isFirefox || currentBrowser.isOpera) {
      newRes = res.replace("mp3", "ogg");
    } else {
      newRes = res.replace("ogg", "mp3");
    }
    return SoundElement._composeFullPath(newRes);
  };

  // 只允许MP3和ogg, 其余的必须转变
  p._doLoad = function(desc) {
    if (!desc) {
      desc = this.jsonObj;
    }

    if (!TQ.SoundMgr.isSupported) return;

    var resource,
      resourceId;
    if (desc.data) {
      resource = desc.data;
      resourceId = desc.src;
      desc.data = null;
    } else {
      TQ.Log.info("start to play " + desc.src);
      var item = TQ.RM.getResource(desc.src);
      if (item) {
        resource = TQ.RM.getId(item);
        resourceId = item.ID;
      }
    }
    if (resource) {
      this.loaded = true;
      this.instance = new TQ.HowlerPlayer(resourceId, desc.sprite, desc.spriteMap); // 声音只用ID， 不要resouce data
      // ToDo： 需要在这里play吗？
      // this.instance.play(); //interruptValue, delay, offset, loop);
      // this.setTRSAVZ(); 声音元素， 没有平移、比例、旋转等
      this._afterItemLoaded();
      // this.level.onItemLoaded(this);
    } else {
      TQ.Assert.isTrue(false, "howler不支持的操作流程");
    }
  };

  p._parent_doAddItemToStage = p._doAddItemToStage;
  p._parent_doRemoveFromStage = p._doRemoveFromStage;
  p._doAddItemToStage = function() { // 子类中定义的同名函数, 会覆盖父类, 让所有的兄弟类, 都有使用此函数.
    // 这是sound的专用类，所以，执行到此的必然是sound，
    TQ.SoundMgr.addItem(this);
  };

  p._parent_calculateLastFrame = p.calculateLastFrame;
  p.calculateLastFrame = function() {
    if (!this.instance) return 0;
    // 由上级（level）来决定：
    // 跨场景的声音：影响作品总时间；
    // 非跨场景的声音： 只用来计算本场景的最后一帧；
    return (this.t0 + this.instance.duration / 1000); // duration 单位是ms
  };

  SoundElement._composeFullPath = function(res) {
    if (res.indexOf(TQ.Config.SOUNDS_PATH) < 0) {
      return TQ.Config.SOUNDS_PATH + res;
    }

    return res;
  };

  p._doRemoveFromStage = function() {
    if (!this.isCrossLevel) { // 支持跨场景的声音
      if (this.instance) {
        this.instance.stop();
      }
    }
  };

  p.play = function(forceToPlay, spriteName) {
    if (!this.instance) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      TQ.Log.info(TQ.Dictionary.INVALID_LOGIC + "in SoundElement.resume");
      return;
    }

    if ((!this.visibleTemp)) {
      return; //  不可见； 或者刚才调入， 尚未update生成可见性
    }

    if (!forceToPlay) {
      if ((!TQ.FrameCounter.isPlaying() || TQ.FrameCounter.isRequestedToStop())) return;
    }

    if (this.isPlaying()) {
      return;
    }

    if (this.isFirstTimePlay) {
      this.isFirstTimePlay = false;
      if (this.t0 === undefined) {
        this.t0 = TQ.FrameCounter.t(); // ToDo:这个t0计算方法有误， 需要根据编辑时插入点的位置， 来计算； 如果播放时，跳开一个位移，则不是播放时的开始位置。
      }
      return this.instance.play(spriteName);
    }

    if (this.instance && !this.instance.isPlaying()) { //  在FAILED情况下， 重新开始播放
      var t = TQ.FrameCounter.t();
      if (this.isCrossLevel) {
        t = currScene.toGlobalTime(t);
      }
      return this.resume(t, spriteName);
    }
  };

  p.forceToReplay = function() {
    if (this.instance) {
      this.instance.play();
    }
  };

  // 计算元素插入点的绝对时刻（与当前level无关， 只与元素所在level有关），
  p.toGlobalTime = function(t) {
    return (this.level.getT0() + t);
  };

  // t： 对于简单声音，只是本level中的相对时间；
  //     对于跨场景的声音，是全局时间
  p.resume = function(t, spriteName) { //
    var ts;
    if (!this.instance) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      TQ.Log.info(TQ.Dictionary.INVALID_LOGIC + "in SoundElement.resume");
      return;
    } else {
      if (this.isCrossLevel) {
        ts = this.toGlobalTime(this.t0); // VER2版本引入的跨场景的声音
      } else {
        ts = this.t0; // 兼容VER1版本中的 单一场景的声音。
      }

      if (this.isFirstTimePlay) {
        this.play(spriteName);
        return;
      }

      var offset = (t - ts) * 1000;
      var SOUND_DATA_BLOCK_SIZE = 1000;
      if ((offset >= 0) && (offset < Math.max(SOUND_DATA_BLOCK_SIZE, this.instance.duration - SOUND_DATA_BLOCK_SIZE))) {
        this.instance.resume(offset, spriteName);
      }
    }
  };

  p.pause = function() {
    var instance = this.instance;
    if (!instance) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return;
    }

    if (instance.pause) {
      instance.pause();
    } else if (instance.stop) {
      instance.stop();
    } else if (instance.setPaused) {
      instance.setPaused(true);
    } else {
      TQ.Assert.isTrue(false, "无法pause声音！！");
    }
  };

  p.isPlaying = function() {
    return (this.instance && this.instance.isPlaying());
  };

  p.isPaused = function() {
    return (this.instance && this.instance.paused);
  };

  p.isFinished = function() {
    return (this.instance && this.instance.hasCompleted());
  };

  p.stop = function() {
    if (this.instance) {
      this.instance.stop();
    }
  };

  p.getAlias = function() {
    var result = "声音";
    if (this.jsonObj && this.jsonObj.alias) {
      result = this.jsonObj.alias;
    }
    return result;
  };

  p.isDub = function() {
    // 缺省的subType是配音
    return (!this.jsonObj.subType || this.jsonObj.subType === SOUND_TYPE_DUB);
  };

  TQ.SoundElement = SoundElement;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  // 用法: 1) 拖入一个按钮可以换皮肤，可以定义新的动作
  //  必须是用工厂生产这个元素, 因为, 是数据决定元素的类别.
  //  Button的状态：
  //     不可见，
  //      可见（执行可见的action），
  //      被按下，执行（被按下的action），
  //     再次转为不可见，          初始化状态

  function ButtonElement(level, jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.level = level;
    this.children = [];
    this.instance = null;
    this._isNewSkin = false;
    this.state2 = ButtonElement.INVISIBLE;
    // 缺省的行为
    this.onVisibleAction = "if (TQ.WCY.isPlayOnly) {TQ.WCY.doStop();}" +
            "else {$('#stop').click();}";
    this.onClickAction = "if (TQ.WCY.isPlayOnly) {TQ.WCY.doPlay();}" +
            "else {$('#play').click();}";
    this.actions = [];
    if (jsonObj.t0) { // 记录声音的插入点， 只在插入点开始播放
      this.t0 = jsonObj.t0;
    } else {
      this.t0 = 0;
    }
    this.initialize(jsonObj);
  }

  ButtonElement.INVISIBLE = 0x01;
  ButtonElement.VISIBLE = 0x04;
  ButtonElement.CLICKED = 0x08; //   也可见

  var p = ButtonElement.prototype = new TQ.Element(null, null);

  p._parent_afterItemLoaded = p._afterItemLoaded;
  p._afterItemLoaded = function(desc) {
    this._parent_afterItemLoaded(desc);
    if (this.level.isStageReady()) {
      if (this.jsonObj.t0 !== undefined) { // 必须是在 立即插入模式
        TQ.AnimeTrack.setButton(this, this.jsonObj.t0);
      }
    }
    this.buildLinks();
  };

  p._parent_doShow = p.doShow;
  p.doShow = function(isVisible) {
    this._parent_doShow(isVisible);
    if (isVisible) {
      if (this.state2 === ButtonElement.INVISIBLE) { // first time
        this.state2 = ButtonElement.VISIBLE;
        if (TQ.FrameCounter.isPlaying()) {
          // 不能直接用item.onPress = ele.onClick()，因为对象的主题变了。响应的时候，对象是Bitmap，不是按钮元素
          var item = this.displayObj;
          (function(ele) {
            item.onPress = function() {
              ele.onClick();
            };
          })(this);
        }

        TQ.ButtonMgr.addItem(this);
        this.onVisible();
      }
    } else {
      if (this.state2 !== ButtonElement.INVISIBLE) {
        this.state2 = ButtonElement.INVISIBLE;
        TQ.ButtonMgr.deleteItem(this);
      }
    }
  };

  p.setButton = function(t) {
    if (TQ.FrameCounter.isPlaying()) {
      TQ.AnimeTrack.setButton(this, t);
    }
  };

  p.onVisible = function() {
    if ((this.level.state === TQBase.LevelState.EDITING) ||
            (this.level.state === TQBase.LevelState.RUNNING)) {
      var t = TQ.FrameCounter.t();
      this.setButton(t);
      eval(this.onVisibleAction);
    }
  };

  p.onClick = function() {
    if (!TQ.SceneEditor.isPlayMode()) return; // 不是播放状态, 不响应click
    if (this.state2 === ButtonElement.VISIBLE) {
      this.state2 = ButtonElement.CLICKED;
      var item = this.displayObj;
      item.onPress = null;
    }

    eval(this.onClickAction);

    for (var i = 0; i < this.actions.length; i++) {
      var act = this.actions[i];
      if ((!act) || (!act.action)) continue; // 去除空的、被删除的响应,
      act.ele.playAction(act.action, true);
    }
  };

  p.addAction = function(ele, actionName) {
    var id = this._findAction(ele, actionName);
    if (id === TQ.ERROR) {
      this.actions.push({ ele: ele, action: actionName });
    } else {
      this.actions[id] = { ele: ele, action: actionName };
    }

    return id;
  };

  p.deleteAction = function(id) {
    if (id < this.actions.length) {
      this.actions[id] = null;
    }
  };

  p.removeAll = function() {
    this.actions.splice(0);
  };

  p._findAction = function(ele, actionName) {
    for (var i = 0; i < this.actions.length; i++) {
      var action = this.actions[i];
      if (!action) { // 被删除了
        continue;
      }
      if ((actionName === action.name) && (action.ele === ele)) {
        return i;
      }
    }

    return TQ.ERROR;
  };

  p.parent_toJSON = p.toJSON;
  p.toJSON = function() {
    this.parent_toJSON();
    if (this.actions) {
      this.jsonObj.actions = [];
      for (var i = 0; i < this.actions.length; i++) {
        var act = this.actions[i];
        this.jsonObj.actions.push({ elementId: act.ele.id, name: act.name });
      }
    }

    return this.jsonObj;
  };

  p.isButton = function() { return true; };
  p.buildLinks = function() {
    this.actions = [];
    if (!this.jsonObj.actions) return;
    for (var i = 0; i < this.jsonObj.actions.length; i++) {
      var act = this.jsonObj.actions[i];
      if ((!act) || (!act.action)) continue; // 去除空的、被删除的响应,
      var ele = this.level.findByDescId(act.id);
      if (ele) {
        this.addAction(ele, act.name);
      }
    }
  };
  TQ.ButtonElement = ButtonElement;
}());

/**
 * Created by Andrewz on 3/4/2017.
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 矩形元素，
 */
TQ = TQ || {};

(function() {
  // 用法: Rectangle是一种可变大小的修饰品Decoration. 也是Element类的子类.
  function Rectangle(level, desc) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof desc !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    TQ.Element.call(this, level, desc); // 调用父类的初始化函数， 在子类构造函数中
  }

  var p = Rectangle.prototype = Object.create(TQ.Element.prototype); // 继承父类的函数, 子类构造函数的参数，限制少
  p.constructor = Rectangle; // 把构造函数也放到prototype中, 是的copy，clone之类的函数， 可以返回本子类的类别
  p.parent_fillGap = p.fillGap;
  p.fillGap = function(desc) {
    if (desc.pivotX === undefined) {
      desc.pivotX = 0.5;
      desc.pivotY = 0.5;
    }
    if (desc.width === undefined) {
      desc.width = 100;
    }
    if (desc.height === undefined) {
      desc.height = desc.width;
    }

    return this.parent_fillGap(desc);
  };

  p.createImage = function() {
    var jsonObj = this.jsonObj;
    var s = new createjs.Shape();
    var w = this.getWidth();
    var h = this.getHeight();

    s.x = jsonObj.x;
    s.y = jsonObj.y;
    s.graphics.clear(); // 清除老的边框
    TQ.Graphics.drawSolidRect(s, "#FF0000", -jsonObj.pivotX * w, -h - jsonObj.pivotY * h, w, h);
    return s;
  };

  p._doLoad = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    this.displayObj = this.createImage();
    this.loaded = true;
    this._afterItemLoaded();
    this.setTRSAVZ();
  };

  p.getWidth = function() {
    return this.jsonObj.width;
  };

  p.getHeight = function() {
    return this.jsonObj.height;
  };

  TQ.Rectangle = Rectangle;
}());

/**
 * Created by Andrewz on 2/12/19.
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 矩形元素，
 */
TQ = TQ || {};

(function() {
  // 用法: Circle是一种可变大小的简单元素. 也是Element类的子类.
  function Circle(level, desc) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof desc !== "string");
    TQ.Element.call(this, level, desc); // 调用父类的初始化函数， 在子类构造函数中
  }

  var p = Circle.prototype = Object.create(TQ.Element.prototype); // 继承父类的函数, 子类构造函数的参数，限制少
  p.constructor = Circle; // 把构造函数也放到prototype中, 使得copy，clone之类的函数， 可以返回本子类的类别
  p.parent_fillGap = p.fillGap;
  p.fillGap = function(desc) {
    if (desc.pivotX === undefined) {
      desc.pivotX = 0.5;
      desc.pivotY = 0.5;
    }
    if (desc.radius === undefined) {
      desc.radius = 10;
    }
    if (desc.width === undefined) {
      desc.width = desc.radius;
    }
    if (desc.height === undefined) {
      desc.height = desc.width;
    }

    return this.parent_fillGap(desc);
  };

  p.createImage = function() {
    var jsonObj = this.jsonObj;
    var s = new createjs.Shape();
    var x0 = jsonObj.x;
    var y0 = jsonObj.y;
    var w = this.getWidth();
    var h = this.getHeight();
    var r = jsonObj.radius;
    s.x = x0;
    s.y = y0;
    s.graphics.clear(); // 清除老的边框
    TQ.Graphics.drawSolidCircle(s, "#FF0000", jsonObj.pivotX * w, -jsonObj.pivotY * h, r);
    return s;
  };

  p._doLoad = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    this.displayObj = this.createImage();
    this.loaded = true;
    this._afterItemLoaded();
    this.setTRSAVZ();
  };

  p.getWidth = function() {
    return this.jsonObj.radius * 2;
  };

  p.getHeight = function() {
    return this.jsonObj.radius * 2;
  };

  TQ.Circle = Circle;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

(function() {
  function TextElement(level, desc) {
    desc.eType = TQ.Element.ETYPE_TEXT;
    TQ.Element.call(this, level, desc);
    if (!this.disableBubble && !this.getTextBubble()) {
      // 默认都有bubble， 除非明确取消
      var host = this;

      if (TQ.Config.textBubbleOn) {
        setTimeout(function() { // 用timeout避免超大时间片
          TQ.TextBubble.attachTo(host);
        });
      }
    }
  }

  var p = TextElement.prototype = Object.create(TQ.Element.prototype);
  TextElement.prototype.constructor = TextElement;

  p.parent_detachDecoration = p.detachDecoration;
  p.parent_attachMarker = p.attachMarker;
  p.attachMarker = function() {
    var bubble = this.getTextBubble();
    if (bubble) {
      return bubble.attachAnchorMarker();
    } else {
      this.parent_attachMarker();
    }
  };

  p.detachDecoration = function() {
    var bubble = this.getTextBubble();
    if (bubble) {
      bubble.detachAnchorMarker();
    }
    return this.parent_detachDecoration();
  };

  p.getColor = function() {
    return this.jsonObj.color;
  };

  p.getText = function() {
    return this.jsonObj.text;
  };

  p.getFontSize = function() {
    return this.jsonObj.fontSize;
  };

  p.isText = function() {
    return true;
  };

  p.parent_setColor = p.setColor;
  p.setColor = function(fontColor) {
    this.parent_setColor(fontColor);
    this.setProperty({ fontColor: fontColor });
  };

  p.setSize = function(fontSize) {
    this.setProperty({ fontSize: fontSize });
  };

  p.setFont = function(fontFace) {
    this.setProperty({ fontFace: fontFace });
  };

  p.setText = function(str, fontFamily, fontSize, fontColor) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, this.isText()); // 应该是Text元素
    // 此处不用再检验, 因为他不直接对用户, 只要那些直接对用户的函数, 把好关就行.
    // 但是一定要断言, 确信: 外围站岗的尽责了.
    if (this.displayObj != null) {
      var txtObj = this.displayObj;
      if (str) {
        txtObj.text = this.jsonObj.text = str;
      }
    }

    this.setProperty({ text: str, fontFace: fontFamily, fontSize: fontSize, fontColor: fontColor });
  };

  p.setProperty = function(option) {
    if (this.displayObj != null) {
      var txtObj = this.displayObj;
      if (option.text) {
        txtObj.text = this.jsonObj.text = option.text;
      }

      var color;
      if (option.fontColor !== undefined) {
        color = option.fontColor;
      } else if (option.color !== undefined) {
        color = option.color;
      }

      if (color !== undefined) {
        TQ.State.color = txtObj.color = this.jsonObj.color = color;
        this.forceToRecord(TQ.Element.COLOR_CHANGED);
      }

      if (option.fontSize) {
        TQ.State.fontSize = this.jsonObj.fontSize = option.fontSize;
      }

      if (option.fontFace) {
        TQ.State.fontFace = this.jsonObj.fontFace = option.fontFace;
      }

      if (option.toggleBold) {
        this.jsonObj.bold = !this.jsonObj.bold;
      }

      if (option.toggleItalic) {
        this.jsonObj.italic = !this.jsonObj.italic;
      }
      txtObj.font = TQ.Utility.toCssFont(this.jsonObj);

      // hitArea 不会根据str内容来更新， 所以：
      txtObj.hitArea = TQ.Element.createHitArea(this, 0, getMeasuredWidthModified(txtObj), this.getHeight());

      TQ.DirtyFlag.setElement(this);
    }
  };

  p._doLoad = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var jsonObj = this.jsonObj;
    var txtObj = this.displayObj = new createjs.Text(jsonObj.text, TQ.Utility.toCssFont(jsonObj), jsonObj.color);
    this.loaded = true;
    if (jsonObj.textAlign == null) {
      txtObj.textAlign = jsonObj.textAlign;
    } else {
      txtObj.textAlign = "left";
    }

    // alert("final size: \n original= " + txtObj.getMeasuredWidth() + ', \n modified =  ' + getMeasuredWidthModified(txtObj));
    // hitArea 会随宿主物体的变换而变换， 所以，可以重用
    txtObj.hitArea = TQ.Element.createHitArea(this, 0, getMeasuredWidthModified(txtObj), this.getHeight());
    this._afterItemLoaded();
    if (this.hasFlag(TQ.Element.IN_STAGE)) {
      this.setTRSAVZ();
    }
  };

  p.hasBubble = function() {
    return !!this.getTextBubble();
  };

  // p.addBubble = function() {
  //    var bubble;
  //    if (!this.jsonObj.bubble) {
  //        bubble = new TQ.TextBubble(this);
  //    } else {
  //        bubble = new TQ.TextBubble(this.jsobObj.bubble);
  //    }
  //
  //    this.addChildDirect(bubble);
  // };

  p.parent_hightlight = p.highlight;
  p.highlight = function(enable) {
    this.parent_hightlight(enable);
    var bubble = this.getTextBubble();
    if (!bubble) {
      return;
    }

    bubble.highlight(enable);
  };

  p.parent_fillGap = p.fillGap;
  p.parent_autoFit = p.autoFit;
  p.fillGap = function(desc) {
    if (desc.font) {
      _upgradeFont(desc);
    }
    if (!desc.fontFace) desc.fontFace = TQ.Config.fontFace;
    if (!desc.fontSize) desc.fontSize = TQ.Config.fontSize;
    if (!desc.color) desc.color = TQ.Config.color;
    return this.parent_fillGap(desc);
  };
  p.parent_onMoveMarker = p.onMoveMarker;
  p.onMoveMarker = function(marker, ptWorld) { // keep anchor's position in world
    var bubble = this.getTextBubble();
    if (!bubble) { // 没有bubble的时候，可以修改text的pivot
      this.parent_onMoveMarker(marker, ptWorld);
    }
  };

  p.autoFit = function() {
    TQ.Assert(this.autoFitFlag === TQ.Element.FitFlag.KEEP_SIZE, "text只能是keepSize!");
    TQ.Assert(this.jsonObj.fontSize !== undefined, "必须先定义fontSize！");
    var desc = this.jsonObj;
    this.fontScaleOne(desc);
    desc.rotation = 0;
  };

  // 样例： <font color="#f74107" size="6" face="隶书">用克隆键</font>
  p.toHtmlStr = function() {
    return "<font color=\"" + this.jsonObj.color + "\" size=\"" +
            ((this.jsonObj.fontSize - 6) / 5) + "\" face=\"" +
            this.jsonObj.fontFace + "\">" +
            this.jsonObj.text + "</font>";
  };

  p.parent_update = p.update;
  p.update = function(t, noRecording) {
    this.parent_update(t, noRecording);
  };

  Element.parseHtmlStr = function(jsonObj, htmlStr) {
    jsonObj.text = TQ.Utility.extractTag("font", htmlStr, jsonObj.text);
    var oldSize = jsonObj.fontSize;
    jsonObj.fontSize = TQ.Utility.extractAttr("font", "size", htmlStr, jsonObj.fontSize);
    if (oldSize !== jsonObj.fontSize) {
      jsonObj.fontSize = jsonObj.fontSize * 5 + 6;
    }
    jsonObj.fontFace = TQ.Utility.extractAttr("font", "face", htmlStr, jsonObj.fontFace);
    jsonObj.color = TQ.Utility.extractAttr("font", "color", htmlStr, jsonObj.color);
  };

  // private:
  function _upgradeFont(desc) { // R308引入，
    var str = desc.font.replace("px", "");
    var arr = str.split(" ");
    if (arr.length >= 1) {
      if (!desc.fontFace) desc.fontFace = arr[1];
      if (!desc.fontSize) desc.fontSize = arr[0];
    }
    if (!desc.fontFace) desc.fontFace = TQ.Config.fontFace;
    if (!desc.fontSize) desc.fontSize = TQ.Config.fontSize;
    if (!desc.color) desc.color = TQ.Config.color;
  }

  p.getWidth = function() {
    return getMeasuredWidthModified(this.displayObj);
  };

  p.getHeight = function() {
    return getMeasuredHeightModified(this.displayObj);
  };

  function getMeasuredWidthModified(txtObj) {
    return txtObj.getMeasuredWidth() * TQ.TextElementWxAdapter.cssFontSizeFactor;
  }

  function getMeasuredHeightModified(txtObj) {
    return txtObj.getMeasuredHeight() * TQ.TextElementWxAdapter.cssFontSizeFactor;
  }

  TQ.TextElement = TextElement;
}());

/**
 * Created by Andrewz on 1/31/18.
 */
var TQ = TQ || {};
TQ.TextElementWxAdapter = (function() {
  return {
    detectFontSizeFactor: detectFontSizeFactor,
    cssFontSizeFactor: -1
  };

  function detectFontSizeFactor() {
    if (TQ.TextElementWxAdapter.cssFontSizeFactor > -1) {
      return;
    }
    var stdTextDomEle = createElement200(document.body, "div", 200);
    const cssFontSize200 = TQ.Utility.getCssSize(window.getComputedStyle(stdTextDomEle).fontSize);
    const cssFontSizeFactor = 200 / cssFontSize200;
    document.body.removeChild(stdTextDomEle);
    TQ.TextElementWxAdapter.cssFontSizeFactor = cssFontSizeFactor;
  }

  function createElement200(parent, tag, fontSize) {
    var ele = document.createElement(tag);
    ele.style.visibility = "hidden";
    ele.style.fontSize = fontSize + "px";

    if (parent) {
      parent.appendChild(ele);
    }

    return ele;
  }
}());

/**
 * Created by Andrewz on 2/25/2017.
 */
/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  // 用法: TextBubble是一种可变大小的修饰品Decoration. 也是Element类的子类.
  function TextBubble(level, desc, host) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof desc !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.host = host;
    TQ.Element.call(this, level, desc); // 调用父类的初始化函数， 在子类构造函数中
  }

  TextBubble.attachTo = function(host) {
    if (!host) {
      host = TQ.SelectSet.peekLatestEditableEle();
    }

    if (host && host.hasBubble && !host.hasBubble()) {
      var desc = compose(host);
      var bubble = host.addChild(desc);
      setTimeout(function() {
        host.detachDecoration();
        bubble.attachAnchorMarker();
      });
    }
  };

  TextBubble.detachFrom = function(host) {
    if (!host) {
      host = TQ.SelectSet.peekLatestEditableEle();
    }

    if (!host) {
      return;
    }

    if (!host.hasBubble && host.isMarker()) {
      var bubble = host.host;
      host = bubble.host;
    }

    if (!!host && host.hasBubble && host.hasBubble()) {
      bubble = host.getTextBubble();
      host.removeChild(bubble);
      bubble.doShow(false);
    }
  };

  TextBubble.RADIUS = 10;
  TextBubble.BORDER_WIDTH = 10;

  var p = TextBubble.prototype = Object.create(TQ.Element.prototype); // 继承父类的函数, 子类构造函数的参数，限制少
  p.constructor = TextBubble; // 把构造函数也放到prototype中, 是的copy，clone之类的函数， 可以返回本子类的类别
  p._parent_update = p.update;
  p.update = function(t, noRecording) {
    textPivot2Bubble(this.jsonObj, this.host);
    this._parent_update(t, noRecording);
    this.updateLayer();
    this.dirty = false;
  };

  p.parent_doShow = p.doShow;
  p.doShow = function(flag) {
    if (this.anchorMarker && !flag) {
      this.anchorMarker.doShow(flag);
    }

    this.parent_doShow(flag);
  };

  p.updateLayer = function() { //  总是紧接着host的下一层
    var hostZ = this.host.getZ();
    if (hostZ !== (this.getZ() + 1)) {
      // 新添加， 在host之后添加的， 所以在host之上
      // 后附加的，重复利用的bubble, 可能在host之下N层
      this.moveToZ(hostZ); // 正好移到host的z， 把host顶起来
    }
  };

  p.createImage = function() {
    // 将替换已有的image，如果有的话
    var s = this.displayObj;
    if (!s) {
      TQ.Log.criticalError(TQ.Dictionary.FoundNull);
      return;
    }

    s.graphics.clear(); // 清除老的边框
    TQ.Graphics.drawBubble(s, this.jsonObj.textBubble);
  };

  p.createModal = function() {
    if (!this.jsonObj.textBubble) {
      // 左下角， + pivot
      var anchorWidth = 20;
      var xc = 0;
      var yc = 0;
      var w = this.getWidth();
      var h = this.getHeight();

      var xmin = xc - w / 2; // 已经改为物体坐标， 便于使用
      var ymin = yc - h / 2;
      var xmax = xc + w / 2;
      var ymax = yc + h / 2;
      var xa = xmin + w / 2;
      var xa1 = xa + anchorWidth / 2;
      var xa3 = xa - anchorWidth / 2;
      var ya1 = ymin; // anchor在下边缘
      var ya3 = ymin;
      var ya = ya1 - 100;

      this.jsonObj.textBubble = { // 从设备坐标简单地变为 对象坐标： Y轴变负
        xmin: xmin,
        ymin: ymin,
        width: w,
        height: h,
        radiusTL: 1,
        radiusTR: 1,
        radiusBL: 1,
        radiusBR: 1,
        anchor: [{ x: xa1, y: ya1 },
          { x: xa, y: ya },
          { x: xa3, y: ya3 }
        ]
      };
    }
  };

  p.onMoveMarker = function(marker, ptWorld) {
    TQ.CommandMgr.directDo(new TQ.MoveAnchorCommand(this, ptWorld));
  };

  p.moveAnchorTo = function(ptWorld) {
    var ptObj = this.world2Object(ptWorld);
    var anchor = this.getAnchorInObject();
    anchor.x = ptObj.x;
    anchor.y = ptObj.y;
    this.createImage();
    TQ.DirtyFlag.setElement(this);
  };

  p._doLoad = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var jsonObj = this.jsonObj;
    var s = new createjs.Shape();
    this.loaded = true;
    s.x = jsonObj.x;
    s.y = jsonObj.y;
    this.displayObj = s;
    this.createModal();
    this.createImage();
    this._afterItemLoaded();
    this.setTRSAVZ();
  };

  p.apply = function(ele) {
    this.dirty2 = true;
  };

  p.isTextBubble = function() {
    return true;
  };

  p.isEditable = function() {
    return false;
  };

  p.getWidth = function() {
    return this.host.getWidth();
  };

  p.getHeight = function() {
    return this.host.getHeight();
  };

  p.allowRecording = function() {
    return false;
  };

  p.getAnchorInObject = function() {
    return this.jsonObj.textBubble.anchor[1];
  };

  p.attachAnchorMarker = function() {
    var anchorMarker = TQ.AnchorMarker.getOne();
    this.attachDecoration([anchorMarker]);
    this.anchorMarker = this.decorations[0];
    this.updateAnchorMarker();
  };

  p.updateAnchorMarker = function() {
    if (this.anchorMarker) {
      var ptObj = this.getAnchorInObject();
      var ptWorld = this.object2World(ptObj);
      this.anchorMarker.moveTo(ptWorld);
    }
  };

  p.detachAnchorMarker = function() {
    this.detachDecoration();
  };

  // private
  function compose(host) {
    // 除了pivot，其余都是物体坐标系下的缺省值
    var jsonObj = {
      type: TQ.ElementType.TEXT_BUBBLE,
      x: 0,
      y: 0,
      sx: 1,
      sy: 1,
      rotation: 0
    };
    textPivot2Bubble(jsonObj, host);
    return jsonObj;
  }

  function textPivot2Bubble(jsonObj, host) {
    var hostObj = host.jsonObj;
    jsonObj.pivotX = hostObj.pivotX - 0.5;
    jsonObj.pivotY = hostObj.pivotY - 0.5;
  }

  TQ.TextBubble = TextBubble;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  "use strict";
  function VideoElement(level, jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    if (jsonObj && (jsonObj.width === undefined) && jsonObj.data && (jsonObj.data instanceof HTMLVideoElement)) {
      TQUtility.extendWithoutObject(jsonObj, VideoElement.createDescFromResource(jsonObj.data));
    }

    this.lastX100 = -100;
    this.lastY100 = -100;
    this.lastW100 = 10000;
    this.lastH100 = 10000;
    this.instance = null;
    this.isFirstTimePlay = true;
    if (jsonObj.t0) { // 记录声音的插入点， 只在插入点开始播放
      this.t0 = jsonObj.t0;
    } else {
      this.t0 = 0;
    }
    TQ.Rectangle.call(this, level, jsonObj);
    this.isCrossLevel = false;
  }

  VideoElement.srcToObj = function(src) {
    return ({ type: "VIDEO", src: src, isVis: 1 });
  };

  VideoElement.createDescFromResource = function(domEle) {
    if (domEle) {
      var x = 0;
      var y;
      var w = TQ.Config.workingRegionWidth;
      var h;
      var xc; var yc;
      h = domEle.videoHeight * w / domEle.videoWidth;
      y = (TQ.Config.workingRegionHeight - h) / 2;
      xc = x + w / 2;
      yc = y + h / 2;

      return {
        type: TQ.ElementType.VIDEO,
        pivotX: 0.5,
        pivotY: 0.5,
        isoScale: true,
        x: xc,
        y: yc,
        width: w,
        height: h
      };
    } else {
      return {};
    }
  };

  var p = VideoElement.prototype = Object.create(TQ.Rectangle.prototype);
  p.constructor = VideoElement;
  p.getImageResource = function(item, jsonObj) {
    TQ.AssertExt.invalidLogic("ToDo");
  };
  p._parent_doShow = p.doShow;
  p.doShow = function(isVisible) {
    this._parent_doShow(isVisible);
    if (isVisible && TQ.FrameCounter.isPlaying()) {
      this.play();
    } else {
      this.stop();
    }
  };

  VideoElement.composeResource = function(res) {
    // wav: 都可以用(似乎IE不行）, 已经被FF24.0，CM29.0， SF5.1.7都支持了！！！
    // mp4: IE, CM, SF： ==》 ogg: 火狐, opera
    var currentBrowser = createjs.BrowserDetect;
    var newRes = null;
    if (currentBrowser.isFirefox || currentBrowser.isOpera) {
      newRes = res.replace("mp4", "ogg");
    } else {
      newRes = res.replace("ogg", "mp4");
    }
    return VideoElement._composeFullPath(newRes);
  };

  // 只允许mp4和ogg, 其余的必须转变
  p._doLoad = function(desc) {
    if (!desc) {
      desc = this.jsonObj;
    }

    if (!TQ.VideoMgr.isSupported) return;

    this.displayObj = this.createImage();
    var resource,
      resourceId;
    if (desc.data) {
      resource = desc.data;
      resourceId = desc.src;
      desc.data = null;
    } else {
      TQ.Log.info("start to play " + desc.src);
      var item = TQ.RM.getResource(desc.src);
      if (item) {
        resource = TQ.RM.getId(item);
        resourceId = item.ID;
      }
    }
    if (resource) {
      this.loaded = true;
      var self = this;
      TQ.VideoMgr.play(resourceId, function(inst) {
        self.instance = inst;
        inst.host = self;
      });
      // ToDo： 需要在这里play吗？
      // this.instance.play(); //interruptValue, delay, offset, loop);
      // this.setTRSAVZ(); 声音元素， 没有平移、比例、旋转等
      this._afterItemLoaded();
      // this.level.onItemLoaded(this);
    } else {
      TQ.Assert.isTrue(false, "不支持的操作流程");
      (function(pt) {
        TQ.RM.addItem(desc.src, function() {
          pt._doLoad(desc);
        });
      })(this);
    }
  };

  p._parent_doAddItemToStage = p._doAddItemToStage;
  p._parent_doRemoveFromStage = p._doRemoveFromStage;
  p._doAddItemToStage = function() { // 子类中定义的同名函数, 会覆盖父类, 让所有的兄弟类, 都有使用此函数.
    // 这是video的专用类，所以，执行到此的必然是video，
    TQ.VideoMgr.addItem(this);
    this._parent_doAddItemToStage();
  };

  p._parent_calculateLastFrame = p.calculateLastFrame;
  p.calculateLastFrame = function() {
    if (!this.instance) return 0;
    // 由上级（level）来决定：
    // 跨场景的声音：影响作品总时间；
    // 非跨场景的声音： 只用来计算本场景的最后一帧；
    return (this.t0 + this.instance.getDuration()); // duration 单位是 s ???
  };

  VideoElement._composeFullPath = function(res) {
    if (res.indexOf(TQ.Config.SOUNDS_PATH) < 0) {
      return TQ.Config.SOUNDS_PATH + res;
    }

    return res;
  };

  p._doRemoveFromStage = function() {
    this._parent_doRemoveFromStage();
    if (!this.isCrossLevel) { // 支持跨场景的声音
      this.stop();
    }
    if (this.instance) {
      this.instance.removeFromDom();
    }
  };

  p.play = function() {
    if (!this.instance) {
      // 刚刚调用opus， 尚未开始播放,（备注： Chrome新规定， 必须用户操作最后，才能开始播放）
      return;
    }

    if ((!TQ.FrameCounter.isPlaying() || TQ.FrameCounter.isRequestedToStop())) return;

    if (this.isPlaying()) {
      return;
    }

    if (this.isFirstTimePlay) {
      this.isFirstTimePlay = false;
      if (this.t0 === undefined) {
        this.t0 = TQ.FrameCounter.t(); // ToDo:这个t0计算方法有误， 需要根据编辑时插入点的位置， 来计算； 如果播放时，跳开一个位移，则不是播放时的开始位置。
      }
      return this.instance.play();
    }

    if (this.isPaused() || this.isFinished()) { //  在FAILED情况下， 重新开始播放
      var t = TQ.FrameCounter.t();
      if (this.isCrossLevel) {
        t = currScene.toGlobalTime(t);
      }
      return this.resume(t);
    }
  };

  p.reset = function() {
    if (this.instance) {
      this.instance.reset();
    }
  };

  p.forceToReplay = function() {
    if (this.instance) {
      this.instance.play();
    }
  };

  // 计算元素插入点的绝对时刻（与当前level无关， 只与元素所在level有关），
  p.toGlobalTime = function(t) {
    return (this.level.getT0() + t);
  };

  // t： 对于简单声音，只是本level中的相对时间；
  //     对于跨场景的声音，是全局时间
  p.resume = function(t) { //
    var ts;
    if (!this.instance) {
      // 刚刚调用opus， 尚未开始播放,（备注： Chrome新规定， 必须用户操作最后，才能开始播放）
      return;
    } else {
      if (this.isCrossLevel) {
        ts = this.toGlobalTime(this.t0); // VER2版本引入的跨场景的声音
      } else {
        ts = this.t0; // 兼容VER1版本中的 单一场景的声音。
      }

      if (this.isFirstTimePlay) {
        this.play();
        return;
      }

      var offset = (t - ts) * 1000;
      var SOUND_DATA_BLOCK_SIZE = 1000;
      if ((offset >= 0) && (offset < Math.max(SOUND_DATA_BLOCK_SIZE, this.instance.getDuration() - SOUND_DATA_BLOCK_SIZE))) {
        if (this.instance.playState === TQ.Video.PLAY_FINISHED) { // 不是paused， 则不能resume， 需要重新开始播放
          this.instance.currentTime = 0;
          this.instance.resume();
        } else { // 被暂停的， 可以resume
          this.instance.resume();
        }
      }
    }
  };

  p.pause = function() {
    var instance = this.instance;
    if (!instance) {
      return;
    }

    if (instance.pause) {
      instance.pause();
    } else if (instance.stop) {
      instance.stop();
    } else if (instance.setPaused) {
      instance.setPaused(true);
    } else {
      TQ.Assert.isTrue(false, "无法pause声音！！");
    }
  };

  p.isPlaying = function() {
    if (!this.instance) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return false;
    }

    var state = this.instance.playState;
    if (!state) return false;
    return !((state === TQ.Video.PLAY_FINISHED) ||
      (state === TQ.Video.PLAY_INTERRUPTED) ||
      (state === TQ.Video.PLAY_FAILED));
  };

  p.isPaused = function() {
    if (!this.instance) {
      return false;
    }

    var state = this.instance.playState;
    if (!state) return false;
    return this.instance.paused;
  };

  p.isFinished = function() {
    if (!this.instance) {
      return false;
    }

    var state = this.instance.playState;
    if (!state) return false;
    return state === TQ.Video.PLAY_FINISHED;
  };

  p.stop = function() {
    if (this.instance) {
      if (this.isPlaying() && (!this.instance.paused)) {
        this.instance.stop();
      }
    }
  };

  p.getAlias = function() {
    var result = "声音";
    if (this.jsonObj && this.jsonObj.alias) {
      result = this.jsonObj.alias;
    }
    return result;
  };

  p.parent_update = p.update;
  p.update = function(t, noRecording) {
    this.parent_update(t, noRecording);
    var w = this.getWidth() * this.getScale().sx;
    var h = this.getHeight() * this.getScale().sy;

    this.lastX100 = Math.round(this.jsonObj.x * 100);
    this.lastY100 = Math.round(this.jsonObj.y * 100);
    this.lastW100 = Math.round(w * 100);
    this.lastH100 = Math.round(h * 100);
    w = this.lastW100 / 100;
    h = this.lastH100 / 100;
    this.updateSize(this.lastX100 / 100, this.lastY100 / 100, w, h, this.jsonObj.rotation);
  };

  p.updateSize = function(x, y, w, h, rotation) {
    if (!this.instance || !this.instance.domEle) {
      return;
    }

    var xLeft = x - w * this.jsonObj.pivotX;
    var yBottom = y - h * this.jsonObj.pivotY;
    var cssPos = TQ.Utility.world2css(xLeft, yBottom);
    var domEleStyle = this.instance.domEle.style;
    domEleStyle.visibility = "none";
    domEleStyle.bottom = Math.round(cssPos.y) + "px";
    domEleStyle.left = Math.round(cssPos.x) + "px";
    domEleStyle.width = w + "px";
    domEleStyle.height = h + "px";
    domEleStyle.transform = "rotate(" + (-rotation) + "deg)";
  };

  TQ.VideoElement = VideoElement;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};
(function() {
  /*
     BBox是一种特殊的修饰品Decoration. 也是Element类的子类.
     它同时含有边界盒的几何数据和图形显示信息。
     它的角度总是水平，不随host旋转。但是， 会计算新的大小和位置，确保它是boundary box
     */
  function BBox(level, desc, host) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof desc !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.host = host;
    TQ.Element.call(this, level, desc); // 调用父类的初始化函数， 在子类构造函数中
  }

  BBox.CHANGED = "bbox changed";
  var showPointOn = false;
  var p = BBox.prototype = Object.create(TQ.Element.prototype); // 继承父类的函数, 子类构造函数的参数，限制少

  p.constructor = BBox; // 把构造函数也放到prototype中, 是的copy，clone之类的函数， 可以返回本子类的类别
  p._parent_update = p.update;

  p.update = function(t, noRecording) {
    if (!this.host) { // 发生在删除， detach的时候
      return;
    }
    if (this.dirty || this.dirty2) {
      this.createModal();
    }
    this.jsonObj.x = this.jsonObj.bbox.xc;
    this.jsonObj.y = this.jsonObj.bbox.yc;
    this.jsonObj.pivotX = 0.5;
    this.jsonObj.pivotY = -0.5;
    this.setTRSAVZ();
    TQ.Log.debugInfo("BBOX: jsonObj = " + this.jsonObj.x + "," + this.jsonObj.y);
    this.dirty = this.dirty2 = false;
  };

  p.updateLayer = function() { //  总是紧接着host的下一层
    var hostZ = this.host.getZ();
    if (hostZ !== (this.getZ() + 1)) {
      // 新添加， 在host之后添加的， 所以在host之上
      // 后附加的，重复利用的bubble, 可能在host之下N层
      this.moveToZ(hostZ); // 正好移到host的z， 把host顶起来
    }
  };

  p.createImage = function() {
    // 将替换已有的image，如果有的话
    var s = this.displayObj;
    if (!s) {
      TQ.Log.criticalError(TQ.Dictionary.FoundNull);
      return;
    }

    s.graphics.clear(); // 清除老的边框
    var radius = 0;
    var bbox = this.jsonObj.bbox;
    TQ.Graphics.drawRectC(s, 0, 0, bbox.w, bbox.h, radius);
  };

  p.createModal = function() {
    var hasPoint = false;
    var boxChanged = false;
    if (this.host.has(TQ.ElementType.POINT)) {
      hasPoint = true;
    }

    var bbox = {};
    var host = this.host;
    var pivotX = host.jsonObj.pivotX;
    var pivotY = host.jsonObj.pivotY;
    var w = host.getWidth();
    var h = host.getHeight();
    var x1 = -pivotX * w;
    var y1 = -pivotY * h;
    var x2 = x1 + w;
    var y2 = y1 + h;
    var objPts = [
      { x: x1, y: y1 },
      { x: x2, y: y1 },
      { x: x2, y: y2 },
      { x: x1, y: y2 }];

    if (host.jsonObj.M) {
      TQ.Log.matrixDebugInfo("bbox", host.jsonObj.M);
    }

    objPts.forEach(function(pt) {
      if (!hasPoint && showPointOn) {
        TQ.Point.attachTo(host, { obj: pt, world: null });
      }
      pt = host.object2World(pt);
      if ((bbox.xmin === undefined) || (bbox.xmin > pt.x)) {
        bbox.xmin = pt.x;
      }
      if ((bbox.xmax === undefined) || (bbox.xmax < pt.x)) {
        bbox.xmax = pt.x;
      }
      if ((bbox.ymin === undefined) || (bbox.ymin > pt.y)) {
        bbox.ymin = pt.y;
      }
      if ((bbox.ymax === undefined) || (bbox.ymax < pt.y)) {
        bbox.ymax = pt.y;
      }
    });

    bbox.w = bbox.xmax - bbox.xmin;
    bbox.h = bbox.ymax - bbox.ymin;
    bbox.xc = (bbox.xmin + bbox.xmax) / 2;
    bbox.yc = (bbox.ymin + bbox.ymax) / 2;
    if (!this.jsonObj.bbox || !TQ.Utility.equalBoxSize(this.jsonObj.bbox, bbox)) {
      this.jsonObj.bbox = bbox;
      this.createImage();
      boxChanged = true;
    } else if (!TQ.Utility.equalBox(this.jsonObj.bbox, bbox)) {
      this.jsonObj.bbox = bbox;
      boxChanged = true;
    }

    if (boxChanged && host.getBBox()) {
      TQ.Base.Utility.triggerEvent(document, BBox.CHANGED, { element: host });
    }
  };

  p.getBBoxTopRight = function() {
    return { x: this.jsonObj.bbox.xmax, y: this.jsonObj.bbox.ymax };
  };

  p.getBBoxBottomRight = function() {
    return { x: this.jsonObj.bbox.xmax, y: this.jsonObj.bbox.ymin };
  };

  p.getBBoxTopLeft = function() {
    return { x: this.jsonObj.bbox.xmin, y: this.jsonObj.bbox.ymax };
  };

  p.getBBoxBottomLeft = function() {
    return { x: this.jsonObj.bbox.xmin, y: this.jsonObj.bbox.ymin };
  };
  p._doLoad = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var jsonObj = this.jsonObj;
    var s = new createjs.Shape();
    this.loaded = true;
    s.x = jsonObj.x;
    s.y = jsonObj.y;
    this.displayObj = s;
    this.createModal();
    this._afterItemLoaded();
    if (this.hasFlag(TQ.Element.IN_STAGE)) {
      this.setTRSAVZ();
    }
  };

  p.apply = function(ele) {
    this.dirty2 = true;
  };

  p.isBBox = function() {
    return true;
  };

  p.isHighlighter = function() {
    return true;
  };

  p.isEditable = function() {
    return false;
  };

  p.canSave = function() {
    return false;
  };

  p.getWidth = function() {
    return (this.jsonObj.bbox.w);
  };

  p.getHeight = function() {
    return (this.jsonObj.bbox.h);
  };

  p.allowRecording = function() {
    return false;
  };

  p.toJSON = function() { // 不保存
    return null;
  };

  p.recycle = p.moveToTop = p.reset = function() {
  };

  function compose(host) {
    // 除了pivot，其余都是物体坐标系下的缺省值
    var jsonObj = {
      type: TQ.ElementType.BBOX,
      eType: TQ.Element.ETYPE_PROP,
      x: 0,
      y: 0,
      sx: 1,
      sy: 1,
      rotation: 0
    };
    jsonObj.pivotX = 0;
    jsonObj.pivotY = 0;
    return jsonObj;
  }

  BBox.attachTo = function(host) {
    TQ.AssertExt.isNotNull(host);
    if (host && !host.hasBBox()) {
      var desc = compose(host);
      var bbox = TQ.Element.build(host.level, desc, host);
      host.attachDecoration([bbox]);
    }
  };

  BBox.detachFrom = function(host) {
    TQ.AssertExt.isNotNull(host);
    TQ.AssertExt.isNotNull(host.hasBBox);
    if (host && host.hasBBox()) {
      var bbox = host.getBBox();
      bbox.doShow(false);
      host.detachOneDecoration(bbox);
    }
  };

  TQ.BBox = BBox;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  //  必须是用工厂生产这个元素, 因为, 是数据决定元素的类别.
  function ParticleElement(level, jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.level = level;
    this.children = [];
    this.instance = null;
    this._isNewSkin = false;
    this.isFirstTimePlay = true;
    if (jsonObj.t0) { // 记录插入点， 只在插入点开始播放
      this.t0 = jsonObj.t0;
    } else {
      this.t0 = 0;
    }

    if (!jsonObj.subType) {
      switch (jsonObj.type) {
        case TQ.ElementType.RAIN:
          jsonObj.subType = TQ.FeParticle.RAIN;
          break;
        case TQ.ElementType.SNOW:
        default:
          jsonObj.subType = TQ.FeParticle.SNOW;
      }
      jsonObj.type = TQ.ElementType.FULLSCREEN_EFFECT_PARTICLE;
    }

    this.version = jsonObj.version;
    this.isCrossLevel = !!(this.isVer2plus());
    this.initialize(jsonObj);
  }

  var p = ParticleElement.prototype = new TQ.Element(null, null, null, null);
  p._parent_doShow = p.doShow;
  p.isSelectable = function() {
    return false;
  };

  p._doLoad = function() {
    this.isPlaying = false;
    if (!this.jsonObj.particles) {
      this.jsonObj.particles = TQ.SnowEffect.getDefaultOptions(this.jsonObj.subType);
    }
    this.effect = this.isFEeffect() ? null : TQ.SnowEffect;

    // 要复制 父类中的逻辑
    this.loaded = true;
    this._afterItemLoaded();
    this.setTRSAVZ();
    TQ.DirtyFlag.setElement(this);
  };

  p.setTRSAVZ = function() {
    var jsonObj = this.jsonObj;
    // 可见性由父子共同决定：
    //  如果父物体为空， 该物体的可见性由自己的标志完全决定
    //  如果父物体非空：
    //      父亲实际不可见，则都不可见（一票否决制）；
    //      父亲实际可见，则孩子自己决定
    //
    //   物体的实际可见性就是 displayObj.visible,
    //          如果displayObj为空，用临时标志： visibleTemp,
    //
    var visSum = false;
    if (!this.parent) {
      visSum = jsonObj.isVis;
    } else {
      visSum = this.parent.isVisible() && jsonObj.isVis;
    }
    visSum = visSum || TQ.Element.showHidenObjectFlag;
    this.doShow(visSum);
  };

  p.doShow = function(isVisible) {
    this._parent_doShow(isVisible);
    if (isVisible) {
      this.play();
    } else {
      this.stop();
    }
  };

  p.apply = function() {
    if (this.isPlaying) {
      this.stop();
    }

    this.play();
  };

  p.play = function() {
    if (this.isPlaying || !this.isVisible()) {
      return;
    }
    this.isPlaying = true;
    var paras = this.jsonObj.particles;
    if (!paras) {
      paras = null;
      console.error("缺少参数： 粒子效果");
    }
    if (this.isFEeffect()) {
      TQ.ParticleMgr.feStart(this, paras);
    } else {
      TQ.ParticleMgr.register(this);
      this.effect.start(paras);
    }
  };

  p.stop = function() {
    if (this.isPlaying) {
      this.isPlaying = false;
      if (this.isFEeffect()) {
        TQ.ParticleMgr.feStop();
      } else {
        TQ.ParticleMgr.unregister(this);
        this.effect.stop();
      }
    }
  };

  p._doAddItemToStage = function() {};
  p._doRemoveFromStage = function() {};
  p.highlight = function() {};

  p.calculateLastFrame = function() {
    if (!this.instance) return 0;
    if (this.isCrossLevel) return 0; // ToDo: 需要补改变当前的录制长度， （如：200帧的默认值），跨场景的声音， 不能用来计算本场景的最后一帧
    return (this.t0 + this.instance.duration / 1000);
  };

  // 计算元素插入点的绝对时刻（与当前level无关， 只与元素所在level有关），
  p.toGlobalTime = function(t) {
    return (this.level.getT0() + t);
  };

  p.getOps = function() {
    return this.jsonObj.particles;
  };

  p.isFEeffect = function() {
    return (this.jsonObj.type === TQ.ElementType.FULLSCREEN_EFFECT_PARTICLE);
  };

  TQ.ParticleElement = ParticleElement;
}());

/**
 * Created by admin on 9/7/2015.
 * TextInputAdapter is an adapter of CanvasInput.js in lib
 */

window.TQ = window.TQ || {};
(function() {
  function TextInputMgr() {

  }

  var option = {
    canvas: document.getElementById("testCanvas1122"),
    fontSize: 38,
    fontFamily: "Arial",
    fontColor: "#212121",
    fontWeight: "bold", // normal
    fontStyle: "italic", // normal
    x: 200,
    y: 200,
    width: 300,
    padding: 8,

    borderWidth: 1,
    borderColor: "#000",
    borderRadius: 3,
    boxShadow: "1px 1px 0px #fff",
    innerShadow: "0px 0px 5px rgba(0, 0, 0, 0.5)",
    placeHolder: "Enter message here..."
  };

  TextInputMgr.start = function() {
    var input = new CanvasInput(option);
  };

  TQ.TextInputMgr = TextInputMgr;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * Sound的Manager, 负责Sound的preload, play, stop, 等一系列工作.
 * 是singleton
 */
TQ = TQ || {};
(function() {
  function ButtonMgr() {
  }

  ButtonMgr.items = [];
  ButtonMgr.initialize = function() {
  };

  ButtonMgr.addItem = function(ele) {
    if (ButtonMgr.items.indexOf(ele) >= 0) { // 避免同一个元素（跨场景的），重复插入
      return;
    }
    ButtonMgr.items.push(ele);
  };

  ButtonMgr.deleteItem = function(ele) {
    var id = ButtonMgr.items.indexOf(ele);
    if (id >= 0) {
      ButtonMgr.items.splice(id, 1);
    }
  };

  ButtonMgr.removeAll = function() {
    for (var i = ButtonMgr.items.length - 1; i >= 0; i--) {
      var ele = ButtonMgr.items[i];
      ButtonMgr.items.splice(i, 1);
    }
  };

  ButtonMgr.close = function() {
    ButtonMgr.removeAll();
    ButtonMgr.items.splice(0);
  };

  TQ.ButtonMgr = ButtonMgr;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

(function() {
  TQ.Element.upgradeToVer2 = function(desc) {
    desc.version = (!desc.version) ? TQ.Element.VER1 : desc.version;
    if (desc.isPinned === undefined) { desc.isPinned = false; }
  };

  // 工厂, 根据数据制作
  TQ.Element.build = function(level, desc, host) {
    if (!desc) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, !desc);
      return TQ.ERROR;
    }
    // 此处已经组装好了目录
    TQ.Element.upgradeToVer2(desc);
    var DescType = TQ.ElementType;
    if (!desc.eType) {
      TQ.Log.error("未定义的元素类别eType");
    }
    switch (desc.type) {
      case DescType.ANCHOR_MARKER:
        return new TQ.AnchorMarker(level, desc);
      case DescType.SOUND:
        return new TQ.SoundElement(level, desc);
      case DescType.JOINT_MARKER:
        return new TQ.Marker(level, desc);
      case DescType.BUTTON:
        return new TQ.ButtonElement(level, desc);
      case DescType.CIRCLE:
        return new TQ.Circle(level, desc);
      case DescType.RECTANGLE:
        return new TQ.Rectangle(level, desc);
      case DescType.TEXT:
        return new TQ.TextElement(level, desc);
      case DescType.TEXT_BUBBLE:
        return new TQ.TextBubble(level, desc, host);
      case DescType.BBOX:
        return new TQ.BBox(level, desc, host);
      case DescType.POINT:
        return new TQ.Point(level, desc, host);
      case DescType.RAIN:
      case DescType.SNOW:
      case DescType.FULLSCREEN_EFFECT_PARTICLE:
        return new TQ.ParticleElement(level, desc);
      case DescType.BITMAP:
        break;
      case DescType.GROUP:
      case DescType.GROUP_FILE:
        return new TQ.GroupElement(level, desc);
      case DescType.VIDEO:
        return new TQ.VideoElement(level, desc);
      default :
        console.error("unknown desc.type:" + desc.type);
        break;
    }

    return new TQ.Element(level, desc);
  };

  TQ.Element.isVideo = function(filename) {
    if (!filename) {
      return false;
    }

    var videoExtension = ["mp4", "mov"];
    var ext = "";
    var index = filename.lastIndexOf(".");
    if (index >= 0) {
      ext = filename.substr(index + 1);
      if (videoExtension.indexOf(ext) >= 0) {
        return true;
      }
    }

    return false;
  };
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 移动操作器
 */

window.TQ = window.TQ || {};

(function() {
  var InputCtrl = { };
  InputCtrl.MODE_ROTATE = 1;
  InputCtrl.MODE_SCALE = 2;
  InputCtrl.mode = InputCtrl.MODE_ROTATE;
  InputCtrl.inSubobjectMode = false;
  InputCtrl.showMarkerOnly = false; // 在零件模式下， 只是显示marker， 不改变物体选择模式
  InputCtrl.vkeyMove = false;
  InputCtrl.vkeyRotate = false;
  InputCtrl.vkeyScale = false;
  InputCtrl.vkeyLift = false;
  InputCtrl.vkeyCtrl = false;
  InputCtrl.vkeyUnjoint = false;
  InputCtrl.vkeyUngroup = false;
  InputCtrl.setMultiSelect = setMultiSelect;
  InputCtrl.clearSubjectModeAndMultiSelect = clearSubjectModeAndMultiSelect;
  InputCtrl.clearVkey = function() {
    InputCtrl.vkeyMove = false;
    InputCtrl.vkeyRotate = false;
    InputCtrl.vkeyScale = false;
    InputCtrl.vkeyLift = false;
    InputCtrl.vkeyUnjoint = false;
    InputCtrl.vkeyUngroup = false;
  };

  InputCtrl.leaveTraceOn = false; // 不绘制运动轨迹
  InputCtrl.initialize = function(aStage) {
    InputCtrl.MODE_ROTATE = 1;
    InputCtrl.MODE_SCALE = 2;
    InputCtrl.mode = InputCtrl.MODE_ROTATE;
    InputCtrl.inSubobjectMode = false;
    InputCtrl.showMarkerOnly = false; // 在零件模式下， 只是显示marker， 不改变物体选择模式
    InputCtrl.vkeyMove = false;
    InputCtrl.vkeyRotate = false;
    InputCtrl.vkeyScale = false;
    InputCtrl.vkeyLift = false;
    InputCtrl.vkeyCtrl = false;
    InputCtrl.vkeyUnjoint = false;
    InputCtrl.vkeyUngroup = false;
    InputCtrl.setMultiSelect = setMultiSelect;
    InputCtrl.clearSubjectModeAndMultiSelect = clearSubjectModeAndMultiSelect;
    TQ.InputMap.registerAction(TQ.InputMap.C, function() {
      currScene.currentLevel.cloneElement(TQ.SelectSet.members);
    });
    TQ.InputMap.registerAction(TQ.InputMap.HIDE_KEY | TQ.InputMap.LEFT_ALT_FLAG, function() {
      TQ.SelectSet.show(false);
    });
    TQ.InputMap.registerAction(TQ.InputMap.HIDE_KEY, function() {
      TQ.SelectSet.show(false);
    });
    TQ.InputMap.registerAction(TQ.InputMap.SHOW_KEY, function() {
      TQ.SelectSet.show(true);
    });
    TQ.InputMap.registerAction(TQ.InputMap.SHOW_KEY | TQ.InputMap.LEFT_ALT_FLAG, function() {
      TQ.SelectSet.show(true);
    });
    TQ.InputMap.registerAction(TQ.InputMap.SHOW_ALL_HIDEN_OBJECT_KEY, function() {
      TQ.Element.showHidenObjectFlag = !TQ.Element.showHidenObjectFlag;
      TQ.DirtyFlag.requestToUpdateAll();
    });

    TQ.InputMap.registerAction(TQ.InputMap.PLAY_STOP_KEY, function() {
      TQ.WCY.doPlayStop();
    });
  };

  // 连续Z向移动， 距离越远， 移动的越多。
  // 与鼠标运动快慢， 一致。
  InputCtrl._accumulateStep = 0;
  InputCtrl._lastItemId = -1;

  $(document).mouseup(function() {
    InputCtrl._accumulateStep = 0;
  });

  InputCtrl.isSameItem = function(target) {
    return (InputCtrl._lastItemId === target.id);
  };

  InputCtrl.getDelta = function(mode, element, target, offset, ev) {
    // offset 是 hit点与图像定位点之间的偏移， 在MouseDown的时候由Element的onPress计算的
    var deltaY = TQ.Utility.deltaYinWorld(target, offset, ev);
    var deltaX = (ev.stageX + offset.x) - target.x;
    var delta = deltaY + deltaX;
    var sensitivity = (mode === InputCtrl.MODE_ROTATE)
      ? TQ.Config.RotateSensitivity : TQ.Config.MouseSensitivity;
    InputCtrl.step = Math.floor(delta / sensitivity);
    var deltaStep = (InputCtrl.isSameItem(target)) ? (InputCtrl.step - InputCtrl._accumulateStep) : InputCtrl.step;
    TQ.Log.out("ID:" + InputCtrl._lastItemId + "sum" + InputCtrl._accumulateStep +
            ", step: " + InputCtrl.step + ", delta: " + deltaStep);
    if (target != null) {
      InputCtrl._lastItemId = target.id;
    }
    return deltaStep;
  };

  InputCtrl.scale = function(element, target, offset, ev) {
    var deltaStep = InputCtrl.getDelta(InputCtrl.MODE_SCALE, element, target, offset, ev);
    var coefficient = 1;
    if (deltaStep === 0) {
      return;
    } else if (deltaStep > 0) {
      coefficient = 1.1 * deltaStep;
    } else if (deltaStep < 0) {
      coefficient = 0.9 * (-deltaStep);
    }
    coefficient = TQ.MathExt.range(coefficient, 0.8, 1.2);
    if (target != null) {
      InputCtrl.doScale(element, coefficient);
      InputCtrl._accumulateStep = InputCtrl.step;
    }

    // displayInfo2("deltaStep: " + deltaStep + " Scale coefficient:" + coefficient);
  };

  /*
    比例变换， 给指定的元素element，放大coefficient倍（ 相对于当前的大小），
     */
  InputCtrl.doScale = function(element, coefficient) {
    assertNotNull(TQ.Dictionary.FoundNull, element);
    if (!element) return;
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, (coefficient > 0)); // 比例变换系数应该是正值
    var MIN_SCALE = 0.1; var MAX_SCALE = 2;
    coefficient = InputCtrl.limitScale(element.jsonObj.sx, MIN_SCALE, MAX_SCALE, coefficient);
    coefficient = InputCtrl.limitScale(element.jsonObj.sy, MIN_SCALE, MAX_SCALE, coefficient);
    TQ.CommandMgr.scale(element, { sx: element.jsonObj.sx * coefficient,
      sy: element.jsonObj.sy * coefficient });
  };
  /*
    镜像变换: 关于X轴镜像，（上下对称）
     */
  InputCtrl.mirrorX = function(element) {
    assertNotNull(TQ.Dictionary.FoundNull, element);
    if (!element) return;
    var coefficientX = -1;
    TQ.CommandMgr.scale(element,
      { sx: element.jsonObj.sx * coefficientX,
        sy: element.jsonObj.sy });
  };

  /*
     镜像变换: 关于Y轴镜像，（左右对称）
     */
  InputCtrl.mirrorY = function(element) {
    assertNotNull(TQ.Dictionary.FoundNull, element);
    if (!element) return;
    var coefficientY = -1;
    TQ.CommandMgr.scale(element,
      { sx: element.jsonObj.sx,
        sy: element.jsonObj.sy * coefficientY });
  };

  InputCtrl.limitScale = function(currentScale, minAbsScale, maxAbsScale, coefficient) {
    var newScale = currentScale * coefficient;
    if (Math.abs(newScale) > maxAbsScale) {
      coefficient = maxAbsScale / currentScale;
    } else if (Math.abs(newScale) < minAbsScale) {
      coefficient = minAbsScale / currentScale;
    }
    return coefficient;
  };

  InputCtrl.setSubobjectMode = function() {
    InputCtrl.inSubobjectMode = true;
    InputCtrl.showMarkerOnly = true;

    // Todo: 让按钮与状态同步
    // var btns = $("#subElementMode");
    // btns[0].checked = true;
    // btns.button("refresh");
  };

  function setMultiSelect() {
    InputCtrl.vkeyCtrl = true; // 设置多选
    InputCtrl.showMarkerOnly = true;

    // Todo: 让按钮与状态同步
    // var btns = $("#subElementMode");
    // btns[0].checked = true;
    // btns.button("refresh");
  }

  function clearSubjectModeAndMultiSelect() {
    InputCtrl.inSubobjectMode = false;
    InputCtrl.showMarkerOnly = false;
    InputCtrl.vkeyCtrl = false; // 取消多选
    /*        if (TQ.InputCtrl.inSubobjectMode) {
         $("#subElementMode").click();
         }

         if (Menu.tb3Dfy) {
         $("#tb3Dfy").click();
         }
         */
  }

  TQ.InputCtrl = InputCtrl;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 移动操作器
 */

window.TQ = window.TQ || {};

TQ.MoveCtrl = (function() {
  var TO_TOP = 99999;
  var TO_BOTTOM = -99999;
  var _stage = null;
  var _queue = [];
  var _direction;
  var _accumulateStep = 0; // 连续Z向移动， 距离越远， 移动的越多。与鼠标运动快慢， 一致。
  var _lastItemId = -1;

  var _self = {
    initialize: initialize,
    cmdMoveLayer: cmdMoveLayer,
    onMoveDownLayer: onMoveDownLayer,
    onMoveUpLayer: onMoveUpLayer,
    onMoveToTop: onMoveToTop,
    onMoveToBottom: onMoveToBottom,
    moveZ: moveZ
  };

  function initialize() {
    _queue.splice(0);
    _direction = 1;
    $(document).mouseup(function() {
      _accumulateStep = 0;
    });
  }

  function isSameItem(target) {
    return (_lastItemId === target.id);
  }

  function moveZ(ele, offset, ev) {
    TQ.AssertExt.depreciated(false, "ToDo: 是不是被cmdMoveLayer彻底代替了？");
    var target = ele.displayObj;
    // offset 是 hit点与图像定位点之间的偏移， 在MouseDown的时候由Element的onPress计算的
    var deltaY = TQ.Utility.deltaYinWorld(target, offset, ev);
    var step = Math.floor(deltaY / TQ.Config.MouseSensitivity);
    var deltaStep = (isSameItem(target)) ? (step - _accumulateStep) : step;
    if (deltaStep !== 0) {
      _accumulateStep = step;
      _doMoveZ(ele, deltaStep);
      TQ.Log.out("ID:" + _lastItemId + "sum" + _accumulateStep +
                ", step: " + step + ", delta: " + deltaStep);
      TQ.DirtyFlag.setElement(ele, true);
    }
  }

  // 移动层次，step >= 1： 向上移动1层； step <-1： 向下移动1层
  function moveLayer(ele, step) {
    if (!_stage) {
      _stage = TQ.Graphics.getStage();
    }

    var oldZ = (step > 0) ? ele.getMaxZ() : ele.getMinZ(); // 防止，目标z落在自身
    if ((oldZ <= 0) && (step <= 0)) { // 已经是最底层， 不能再move了
      TQ.MessageBox.toast(TQ.Locale.getStr("already in lowest layer!"));
    } else {
      step = zAdjustForGroup(oldZ, step); // 防止目标z录入复合体内
      if (step === 0) {
        TQ.MessageBox.toast(TQ.Locale.getStr("couldn't move any more！"));
      } else {
        TQ.CommandMgr.addCommand(new TQ.GenCommand(TQ.GenCommand.CHANGE_LAYER, ele, step, oldZ));
      }
    }
  }

  function zAdjustForGroup(oldZ, step) {
    var maxZ;
    var newZ = oldZ + step;
    if (newZ < 0) {
      newZ = 0;
    } else {
      if (newZ > (maxZ = (_stage.getNumChildren() - 1))) {
        newZ = maxZ;
      }
    }

    var ele = TQ.Graphics.findEditableElementBelowZ(newZ, newZ - oldZ);
    if (!ele) {
      step = 0;
    } else {
      newZ = (step > 0) ? ele.getMaxZ() : ele.getMinZ();
      step = newZ - oldZ;
    }
    return step;
  }

  // 下面的函数只被command所调用, 不会被其它函数调用
  function cmdMoveLayer(ele, step) {
    if (!_stage) {
      _stage = TQ.Graphics.getStage();
    }

    assertNotNull(TQ.Dictionary.FoundNull, ele);
    if (!ele) return;
    _openQueue(step);
    _doMoveZ(ele, step);
    _flush();
    TQ.DirtyFlag.setElement(ele, true);
  }

  function onMoveUpLayer(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_FLOATTOOLBAR);
    var ele = TQ.SelectSet.peekLatestEditableEle();
    if (ele) {
      moveLayer(ele, 1);
    }
  }

  function onMoveDownLayer(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_FLOATTOOLBAR);
    var ele = TQ.SelectSet.peekLatestEditableEle();
    if (ele) {
      moveLayer(ele, -1);
    }
  }

  function onMoveToTop(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_FLOATTOOLBAR);
    var ele = TQ.SelectSet.peekLatestEditableEle();
    if (ele) {
      moveLayer(ele, TO_TOP);
    }
  }

  function onMoveToBottom(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_FLOATTOOLBAR);
    var ele = TQ.SelectSet.peekLatestEditableEle();
    if (ele) {
      moveLayer(ele, TO_BOTTOM);
    }
  }

  function _doMoveZ(ele, step) {
    var target = ele.displayObj;
    // move up the selected object toward more visible
    if (target != null) {
      _moveZOne(ele);
      _lastItemId = target.id;
      if (ele.children) {
        for (var i = 0; i < ele.children.length; i++) {
          var child = ele.children[i];
          if (!child.isEditorEle()) {
            _doMoveZ(child, step);
          }
        }
      }
    }
  }

  function _moveZOne(ele) {
    if (!_stage) {
      _stage = TQ.Graphics.getStage();
    }

    if (!ele.displayObj) return;
    var id = _stage.getChildIndex(ele.displayObj);
    if (id >= 0) {
      _queue.push({ "id": id, "ele": ele });
    }
  }

  function _openQueue(step) {
    _direction = step;
    _queue.splice(0);
  }

  function _flush() {
    if (!_stage) {
      _stage = TQ.Graphics.getStage();
    }

    var lastEditableEle = null;
    var num = _queue.length;
    if (num > 0) {
      if (_direction < 0) {
        _queue.sort(function(a, b) { return a.id - b.id; });
      } else {
        _queue.sort(function(a, b) { return b.id - a.id; });
      }
      var step = _direction;
      // 上移一层但是已经到顶，或者下移一层但是已经到底， 就不再操作）
      if ((step === 1) && ((_stage.getNumChildren() - 1) === _queue[0].id)) { return; }
      if ((step === -1) && (_queue[0].id === 0)) { return; }
      // 到底、到顶操作：确保各个子元素的移动距离是一样的， 不能都奔到最顶最低
      if (step === TO_TOP) {
        step = (_stage.getNumChildren() - 1) - _queue[0].id;
      } else if (step === TO_BOTTOM) {
        step = -_queue[0].id;
      }
      if (step === 0) return;
      for (var i = 0; i < num; i++) {
        var item = _queue.shift();
        _doMoveZOne(item.ele, step);
        if (item.ele) {
          lastEditableEle = item.ele;
        }
      }
    }

    // 在IOS上， 迫使系统再次刷新,
    setTimeout(function() {
      TQ.DirtyFlag.setElement(lastEditableEle);
    });
  }

  function _doMoveZOne(ele, step) {
    if (!_stage) {
      _stage = TQ.Graphics.getStage();
    }

    var target = ele.displayObj;
    if (!target) return;
    var id = _stage.getChildIndex(target);
    if (id >= 0) {
      var newId = TQ.MathExt.range(id + step, 0, _stage.getNumChildren() - 1);
      if (id !== newId) {
        if ((step > 1) || (step < -1)) { // move to Top, or Bottom
          _stage.setChildIndex(ele.displayObj, newId);
        } else {
          _stage.swapChildrenAt(id, newId);
        }
      }
    }
    TQ.DirtyFlag.setElementOnly(ele); // 必须配合setAll,或者setLevel
  }

  return _self;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 把A物体连接到B物体上,
 */

window.TQ = window.TQ || {};

(function() {
  var SkinningCtrl = { };
  SkinningCtrl.hasNew = false;
  SkinningCtrl._scene = null;
  SkinningCtrl._hostObj = null;
  SkinningCtrl.isWorking = false;
  SkinningCtrl.initialize = function(aStage, scene) {
    SkinningCtrl._scene = scene;
  };

  SkinningCtrl.oldSubjectMode = null;
  SkinningCtrl.start = function() {
    SkinningCtrl._hostObj = TQ.SelectSet.peek();
    if (SkinningCtrl._hostObj == null) {
      displayInfo2(TQ.Dictionary.PleaseSelectOne);
      return;
    }
    SkinningCtrl.isWorking = true;
    SkinningCtrl.oldSubjectMode = TQ.InputCtrl.inSubobjectMode;
    TQ.InputCtrl.inSubobjectMode = true;
    TQ.SelectSet.getSelectedElement();
    SkinningCtrl._hostObj = TQ.SelectSet.pop();
    // ToDo: 能够禁止再次进入吗 $("#skinning").button("disable");
    $(document).bind("mousedown", SkinningCtrl.getSkin);
  };

  SkinningCtrl.getSkin = function() {
    var skin = TQ.SelectSet.pop();
    assertNotNull(TQ.Dictionary.PleaseSelectHost, SkinningCtrl._hostObj);
    if ((skin != null) && (skin.displayObj.id !== SkinningCtrl._hostObj.displayObj.id)) {
      SkinningCtrl._scene.skinning(SkinningCtrl._hostObj, skin);
      TQ.SelectSet.empty();
      SkinningCtrl.end();
      // SkinningCtrl.hasNew = true;
    }
  };

  SkinningCtrl.end = function() {
    if (SkinningCtrl.isWorking) {
      SkinningCtrl.isWorking = false;
      if (SkinningCtrl.oldSubjectMode != null) {
        TQ.InputCtrl.inSubobjectMode = SkinningCtrl.oldSubjectMode;
      }
      $(document).unbind("mousedown", SkinningCtrl.getSkin);
      // ToDo: 可以吗?  $("#skinning").button("enable");
    }
  };

  TQ.SkinningCtrl = SkinningCtrl;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 把A物体连接到B物体上,
 */

window.TQ = window.TQ || {};

(function() {
  function IKCtrl() {

  }

  IKCtrl.initialize = initialize;

  IKCtrl.applyLimitation = applyLimitation;
  IKCtrl.do = doIK;
  IKCtrl.rotate = rotate;
  IKCtrl.setLimitation = setLimitation;

  // 任何时候, 都是IK动画, 除非是 Break it 进入子物体编辑模式. 默认就是最好的状态, 精锐尽出
  var EObj = null; // E点在对象空间的坐标值， 在拖动过程中是不变的， 但是在世界坐标下是变的
  var isSimpleRotationMode = false; // 切换IK模式 和 单一物体的简单旋转模式。

  function initialize(aStage, scene) {
  }

  function vec2Angle(S, E, A) { //  从SE 转到SA 需要转多少角度？
    var SE = TQ.Vector2D.calDirection(S, E);
    var SA = TQ.Vector2D.calDirection(S, A);
    return TQ.Utility.limitToAcuteAngle(SA.angle360From(SE));
  }

  function getEWorld(targetElement) {
    assertNotNull(TQ.Dictionary.PleaseSelectOne, EObj);
    return targetElement.object2World(EObj);
  }

  function hasAchieved(E, A) {
    var distance = Math.abs(A.x - E.x) + Math.abs(A.y - E.y);
    // TQ.Log.trace("distance = " + distance + " E: " + E.x + ",  " + E.y + "A:" + A.x +", "+ A.y);
    return (distance < 1);
  }

  function applyLimitation(child, angle) {
    if ((child.jsonObj.angleMin != null) || (child.jsonObj.angleMax != null)) {
      var angleMin = child.jsonObj.angleMin; var angleMax = child.jsonObj.angleMax;

      var parentAngle = 0;
      if (child.parent != null) {
        parentAngle = child.parent.jsonObj.rotation;
      }
      var relativeAngle = angle - parentAngle; // relative to parent;
      relativeAngle = TQ.MathExt.range(relativeAngle, angleMin, angleMax);
      angle = relativeAngle + parentAngle;
    }

    return TQ.Utility.limitToAcuteAngle(angle);
  }

  /*
    设置关节的运动范围限制，若limitation有值， 则用之， 否则，以当前的位置作为界限。
    angle： 是绝对值，会被转为相对值（因为界限是相对于父物体的，是相对值， 不是绝对值）
    type = 0: 设置 最小值；
    tyoe = 1: 其它 设置 最大值;
     */
  function setLimitation(type, angle) {
    var child = TQ.SelectSet.peek();
    if (child == null) return;
    if (angle == null) {
      angle = child.getRotation();
    }
    var parentAngle = 0;
    if (child.parent != null) {
      parentAngle = child.parent.getRotation();
    }
    var relativeAngle = angle - parentAngle; // relative to parent;

    var oldValue;
    var cmd_type;
    if (type === 0) {
      oldValue = (child.jsonObj.angleMin === undefined) ? null : child.jsonObj.angleMin;
      cmd_type = TQ.GenCommand.MIN_JOINT_ANGLE;
    } else {
      oldValue = (child.jsonObj.angleMax === undefined) ? null : child.jsonObj.angleMax;
      cmd_type = TQ.GenCommand.MAX_JOINT_ANGLE;
    }
    TQ.CommandMgr.directDo(new TQ.GenCommand(cmd_type,
      child, relativeAngle, oldValue));

    // 检查合法性
    if ((child.jsonObj.angleMin != null) && (child.jsonObj.angleMax != null)) {
      if (child.jsonObj.angleMin > child.jsonObj.angleMax) {
        TQ.MessageBubble(TQ.Dictionary.INVALID_PARAMETER);
      }
    }
  }

  function calOneBone(child, target, A, idIterations) {
    // 目的是把E点转动到A点，通过各级bone绕自身轴点S的转动实现
    // S: 转动的支点， 也是当前处理之Bone的pivot点
    // E: 终点， 物体上被鼠标点击的位置，虽然E的物体坐标不变，但其世界坐标在求解过程中是改变的。
    // A: 目的位置， 要把E点移动到A点。
    // child： 当前处理的Bone，
    // target：选中的bone，一般是最末的一个bone。
    var S = child.getPositionInWorld();
    var E = getEWorld(target);
    TQDebugger.Panel.logInfo(idIterations + ", X, " + child.id + ", EO(" +
          Math.round(EObj.x) + "," + Math.round(EObj.y) + ") <- A(" +
          Math.round(A.x) + "," + Math.round(A.y) + ") <- E(" +
          Math.round(E.x) + "," + Math.round(E.y) + ")");

    if (hasAchieved(E, A)) return true;
    var angle = child.getRotateDirection() * vec2Angle(S, E, A); // 从SE转到SA,
    var operationFlags = child.getOperationFlags(); // 必须保存， 因为 update和record会清除 此标记。
    rotate(child, angle);
    if (isSimpleRotationMode) return true; // 简单旋转， 比不牵涉其它关节，

    var parent = child.parent;
    if (child.isRoot() || !parent || parent.isPinned() ||
          (parent.isRoot() && TQ.State.fiexdRootJoint)) { // 如果固定了, 不IK
      return false; // 达到根, 迭代了一遍, 未达到目标,
    }

    assertNotNull(TQ.Dictionary.FoundNull, child.parent); // 非root关节,有parent
    child.parent.setFlag(operationFlags);
    return calOneBone(child.parent, target, A);
  }

  /*
    旋转物体（及其子物体），angle角度， (逆时针为正， 顺时针为负）
     */
  function rotate(child, angle) {
    assertNotNull(TQ.Dictionary.FoundNull, child);
    if (!child) return;

    angle = applyLimitation(child, child.jsonObj.rotation + angle);
    child.rotateTo(angle);
    child.update(TQ.FrameCounter.t()); // 更新本bone以及 所以后续Bone的 物体坐标, 世界坐标
    TQ.Log.info("IKRotate ele.id " + child.id + " @ angle = " + angle);
    TQ.DirtyFlag.setElement(child);
  }

  function doIK(element, offset, ev, isSimpleRotation) {
    TQ.Log.debugInfo("ele.id =", element.id, "offest = ", JSON.stringify(offset));
    isSimpleRotationMode = isSimpleRotation;
    var target = TQ.SelectSet.peek();
    if (target == null) {
      TQ.Log.debugInfo(TQ.Dictionary.PleaseSelectOne);
      return;
    }

    var A = element.dc2World(TQ.Utility.eventToDevice(ev));

    if (offset.firstTime) {
      EObj = determineE(element, offset, ev);
      offset.firstTime = false;
    }

    if (!EObj) {
      displayInfo2(TQ.Dictionary.PleaseSelectOne);
    }

    if (element.getRotateDirection() < 0) {
      var EWorld = getEWorld(element);
      // A = TQ.Utility.mirror(EWorld, A);
    }

    for (var i = 0; i < TQ.Config.IK_ITERATE_TIME; i++) {
      if (calOneBone(target, target, A, i)) {
        return TQ.Log.debugInfo("achieved");
      }
    }
  }

  function determineE(element, offset, ev) {
    // 求E点在element元素物体空间的坐标
    // 设备坐标 --》 世界坐标 --》 物体坐标。
    var eDevice = TQ.Utility.eventToDevice(ev);
    var eWorld = element.dc2World(eDevice);
    return element.world2Object(eWorld);
  }

  TQ.IKCtrl = IKCtrl;
})();

/**
 * Created by Andrewz on 4/5/2017.
 */
TQ = TQ || {};

(function() {
  // 用法: Marker是一种修饰品Decoration. 也是Element类的子类.
  var OP_TYPE = {
    UNKNOWN: "unknown",
    SCALE_X: "scale x",
    SCALE_Y: "scale y",
    SCALE_XY: "scale xy"
  };

  // class 中的所有私有变量，都是各个class共用的，都可以修改，如果有多个实例， 就会冲突。
  var lastOpType = OP_TYPE.UNKNOWN;

  function ScaleCalculator() {
    this.reset();
  }

  var p = ScaleCalculator.prototype;
  p.reset = function() {
    this.sx = 1;
    this.sy = 1;
    this.type = OP_TYPE.UNKNOWN;
    lastOpType = OP_TYPE.UNKNOWN; // 必须重新初始化， 否则，之前的值会保留
  };

  p.determineScale = function(ele, e) {
    var gesture = e.gesture;
    var dx = gesture.deltaX;
    var dy = gesture.deltaY;
    var scale = e.gesture.scale;
    // TQ.Log.warn("gesture: (dx, dy):" + gesture.deltaX + ', ' + gesture.deltaY + '  velocity(x, y)' + gesture.velocityX + ', ' + gesture.velocityY);

    // 变换到物体空间
    var TANGENT_8_DEGREE = 0.14054; // i.e. tan(8 degree)
    if (ele) { // 没有element，就使用当前的空间坐标系
      var dObj = ele.dDc2Object({ x: dx, y: dy });
      dx = Math.abs(dObj.x);
      dy = Math.abs(dObj.y);
    }

    var opType;
    if ((dx > dy) && (dx * TANGENT_8_DEGREE > dy)) {
      opType = OP_TYPE.SCALE_X;
    } else if ((dy > dx) && (dy * TANGENT_8_DEGREE > dx)) {
      opType = OP_TYPE.SCALE_Y;
    } else {
      opType = OP_TYPE.SCALE_XY;
    }

    if (lastOpType !== OP_TYPE.UNKNOWN) {
      if (opType !== lastOpType) {
        opType = lastOpType;
      }
    }

    lastOpType = opType;
    switch (opType) {
      case OP_TYPE.SCALE_X:
        this.sx = scale;
        // this.sy = undefined; do not refresh it; keep old value
        break;
      case OP_TYPE.SCALE_Y:
        this.sy = scale;
        break;
      case OP_TYPE.SCALE_XY:
        this.sx = scale;
        this.sy = scale;
        break;
    }

    this.type = opType;
    TQ.Log.warn("gesture: (dx, dy):" + gesture.deltaX.toFixed(2) + "," + gesture.deltaY.toFixed(2) +
      " (in Object Space:(dx, dy) =" + dx.toFixed(2) + ", " + dy.toFixed(2) +
      "  scale(x, y)" + this.sx.toFixed(2) + ", " + this.sy.toFixed(2));
  };

  TQ.ScaleCalculator = ScaleCalculator;
}());

/**
 * Created by Andrewz on 12/24/2016.
 */
var TQ = TQ || {};
(function() {
  "use strict";
  function Trsa3() {
  }

  Trsa3.isDragging = function() { return isDragging; };
  Trsa3.mCopy = mCopy;
  Trsa3.ditherStart = ditherStart;
  Trsa3.onTouchStart = onTouchOrDragStart;
  Trsa3.onMouseDown = onMouseDown;
  Trsa3.onPinchAndRotate = onPinchAndRotate;
  Trsa3.onTouchStage = onTouchStage;
  Trsa3.onTouchEnd = onTouchOrDragEnd;
  Trsa3.onMouseUp = onMouseUp;
  Trsa3.onRelease = onRelease;
  Trsa3.onDrag = onDrag;
  Trsa3.reset = reset;

  var isDithering = false;
  var startEle = null;
  var startLevel = null;
  var startOffsetInDcExt = null;
  var startTrsa = {
    needReset: true,
    ang: 0,
    scale: { sx: 1, sy: 1 }
  };
  var deltaTrsa = {
    ang: 0,
    scale: new TQ.ScaleCalculator()
  };
  var pos = { x: 0, y: 0 };
  var isDragging = false;
  var isMultiTouching = false;

  function mCopy(evt) {
    if (TQ.SelectSet.isEmpty()) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    if (TQ.Utility.isDithering) {
      return;
    }
    TQ.Utility.ditherStart();

    evt = touch2StageXY(evt);
    var results = currScene.currentLevel.cloneElement(TQ.SelectSet.members);
    results.forEach(function(ele) {
      ele.moveTo(ele.dc2World2({ x: evt.stageX, y: evt.stageY }));
    });
  }

  function isMultiTouch(e) {
    try {
      return (TQ.Utility.getTouchNumbers(e) > 1);
    } catch (err) { // in case touches not exist
    }

    return false;
  }

  function onTouchStage(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    var result = stage.hitTest(evt.stageX, evt.stageY);
    if (result) {
      TQ.Log.debugInfo("OK!");
    }
  }

  function updateStartElement(e) {
    TQ.AssertExt.invalidLogic(!!e);
    if (!e) {
      return;
    }

    TQ.SelectSet.updateByGesture(e);
    var newEle = TQ.SelectSet.peekLatestEditableEle();
    if (!newEle) {
      startEle = null;
      // console.error("No Obj touched!");
      TQ.SelectSet.empty();
      TQ.FloatToolbar.close();
      return;
    }

    if (newEle instanceof TQ.TextBubble) {
      if (newEle.host) {
        newEle = newEle.host;
      }
    }

    if (startEle === newEle) {
      return;
    }

    startEle = newEle;
    if (startEle.isMarker()) {
      // startEle.limitHostNoRotation();
    }
    // TQ.Log.debugInfo("element selected: " + startEle.getType() + ", Id=" + startEle.id);
    _showFloatToolbar(startEle.getType());
    TQ.AnimationManager.reset(startEle);
    resetStartParams(e);
    if (TQ.Utility.isMouseEvent(e)) {
      TQ.TouchManager.attachHandler("mousemove", onDrag);
    }
    // showFloatToolbar(evt);
    // TQBase.LevelState.saveOperation(TQBase.LevelState.OP_CANVAS);
  }

  function resetStartParams(e) {
    if (!startEle) {
      return;
    }

    if (TQ.Utility.isMouseEvent(e) && !e.altKey && !e.ctrlKey && !e.shiftKey) {
      return;
    }

    startTrsa.needReset = false;
    startTrsa.ang = startEle.getRotation();
    startTrsa.scale = startEle.getScaleInWorld();
    pos = startEle.getPositionInWorld();

    if (isNaN(startTrsa.scale.sx)) {
      startTrsa.scale.sx = 1;
      startTrsa.scale.sy = 1;
    }

    // setup base
    startLevel = currScene.currentLevel;

    var target = startEle.displayObj;
    if (target == null) { // 防止 刚刚被删除的物体.
      return;
    }
    var evt = touch2StageXY(e);
    target = startEle.getPositionInDc();
    startOffsetInDcExt = { x: target.x - evt.stageX, y: target.y - evt.stageY, firstTime: true };

    deltaTrsa.scale.reset();
    deltaTrsa.ang = 0;
  }

  function onTouchOrDragStart(e) { // ==mouse的onPressed，
    onKeyUp(); // 确保删除old handler
    if (e.type === "mousedown") {
      document.addEventListener("keyup", onKeyUp);
      document.addEventListener("mouseup", onKeyUp);
    }

    TQ.Log.debugInfo("touch start or mousedown" + TQ.Utility.getTouchNumbers(e));
    TQ.CommandMgr.startNewOperation();
    updateStartElement(e);
    e.stopPropagation();
    e.preventDefault();
  }

  function ditherStart() {
    isDithering = true;
    setTimeout(ditherEnd, 300);
  }

  function ditherEnd() {
    isDithering = false;
  }

  function onKeyUp() {
    if (startEle) {
      startTrsa.needReset = true;
    }
    document.removeEventListener("keyup", onKeyUp);
    document.removeEventListener("mouseup", onKeyUp);
  }

  function onTouchOrDragEnd(e) { // ==mouse的onUp，
    isDragging = false;
    if (e.type === "mouseup") {
      document.removeEventListener("keyup", onKeyUp);
      TQ.TouchManager.detachHandler("mousemove", onDrag);
    }
    if (TQ.Utility.getTouchNumbers(e) > 0) { // not real start, 不需要重新旋转物体， 但是需要refresh参数
      startTrsa.needReset = true;
      ditherStart();
    } else {
      isMultiTouching = false;
      if (startEle && startEle.snapIt) {
        startEle.snapIt();
      }
      ditherStart();
      startEle = null;
    }

    TQ.Log.debugInfo("touch end, or mouse up " + TQ.Utility.getTouchNumbers(e));
  }

  function onMouseDown(e) {
    if (isDithering) {
      return;
    }
    TQ.InputMap.updateSpecialKey(e);
    return onTouchOrDragStart(e);
  }

  function onMouseUp(e) {
    if (isDithering) {
      return;
    }
    TQ.InputMap.updateSpecialKey(e);
    return onTouchOrDragEnd(e);
  }

  function onRelease() {
    isMultiTouching = false;
    isDithering = false;
  }

  function onDrag(e) { // // ==mouse的onMove，
    if (TQ.TouchManager && !TQ.TouchManager.hasStarted()) {
      return;
    }
    if (e.type === "mousemove") {
      return;
    }

    isDragging = true;
    if (isMultiTouch(e)) {
      console.error("ignore multi touch, in move handler");
      return;
    }

    e = touch2StageXY(e);
    e.stopPropagation();
    e.preventDefault();
    if (!startEle || !isValidOp(e)) {
      TQ.Log.debugInfo(e.type + ": Drag, no selected..., " + TQ.Utility.getTouchNumbers(e));
    } else {
      TQBase.Trsa.do(startEle, startLevel, startOffsetInDcExt, e);
    }
  }

  function isValidOp(e) {
    var result = true;
    e.stopPropagation();
    e.preventDefault();
    if (isDithering) {
      return (result = false);
    }

    if (!startEle) {
      // 首次选中， 不能立即TRSA， 下一个event吧， 以避免TRSA开始时的突变
      updateStartElement(e);
      result = false;
    } else if (startTrsa.needReset) {
      resetStartParams(e);
      result = false;
    }
    return result;
  }

  function onPinchAndRotate(e) {
    if (TQ.TouchManager && !TQ.TouchManager.hasStarted()) {
      return;
    }
    if (TQ.SelectSet.isInMultiCmd()) {
      return;
    }

    if (!startEle || !isValidOp(e)) {
      TQ.Log.debugInfo("pinch..." + TQ.Utility.getTouchNumbers(e));
    } else {
      if (e.type.indexOf("rotate") >= 0) {
        /*
                 * IONIC的gesture的角度方向： 顺时针为正， 用度数单位，
                 * ** 数值可能从 正直突然变为等价的负值
                 * ** 逆时针是负！！！！
                 */
        deltaTrsa.ang = startEle.dc2World({ rotation: e.gesture.rotation }).rotation;
        TQ.Log.debugInfo("rotate: " + deltaTrsa.ang);
      } else if (e.type.indexOf("pinch") >= 0) {
        deltaTrsa.scale.determineScale(startEle, e);
        TQ.Log.debugInfo("pinch" + deltaTrsa.scale.x + "," + deltaTrsa.scale.y);
      } else {
        TQ.Log.debugInfo("not pinch, rotate: " + e.type);
      }
      var newScaleX = startTrsa.scale.sx * deltaTrsa.scale.sx;
      var newScaleY = startTrsa.scale.sy * deltaTrsa.scale.sy;
      if (!isNaN(newScaleX)) {
        if (Math.abs(newScaleX) < 0.00001) {
          console.warn("Too small");
        } else {
          if (startEle.jsonObj && startEle.jsonObj.isoScale) {
            var isoScale = (newScaleX + newScaleY) / 2;
            newScaleX = isoScale;
            newScaleY = isoScale;
          }

          TQ.CommandMgr.directScaleAndRotate(startEle, {
            sx: newScaleX,
            sy: newScaleY
          }, startTrsa.ang + deltaTrsa.ang);
          isMultiTouching = true;
        }
      }
    }
  }

  // private:
  var _showFloatToolbar = function(type) {
    if ((TQ.FloatToolbar !== undefined) && TQ.FloatToolbar.setPosition && TQ.FloatToolbar.show) {
      TQ.FloatToolbar.setPosition(0, 0);
      TQ.FloatToolbar.show(type);
    }
  };

  function touch2StageXY(e) { // 让ionic的 touch 和mouse 兼容createJs格式中部分参数
    var touches = TQ.Utility.getTouches(e);
    if (touches.length > 0) {
      var touch = touches[0];
      e.stageX = touch.pageX;
      e.stageY = touch.pageY;
    } else {
      TQ.AssertExt.invalidLogic(false, "应该有touch点");
    }

    return e;
  }

  function reset() {
    isDithering = false;
    isMultiTouching = false;
    startEle = null;
    startTrsa.needReset = true;
  }

  TQ.Trsa3 = Trsa3;
})();

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  // 用法: Marker是一种修饰品Decoration. 也是Element类的子类.
  function Marker(level, jsonObj) {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, typeof jsonObj !== "string"); // 用工厂提前转为JSON OBJ,而且, 填充好Gap
    this.level = level;
    this.children = [];
    this.decorations = null;
    this.host = null;
    this._isNewSkin = false;
    jsonObj.pivotX = (jsonObj.pivotX === undefined) ? 0 : jsonObj.pivotX; // Marker图元的原点已经在正中心了
    jsonObj.pivotY = (jsonObj.pivotY === undefined) ? 0 : jsonObj.pivotY;
    this.initialize(jsonObj);
  }

  Marker.init = function() {
    markers.splice(0);
    workingMarkers.splice(0);
  };

  Marker.RADIUS = 32; // 2个字的大小
  var GRADIENT_COLOR_S = "#00F0";
  var GRADIENT_COLOR_E = "#F00F";

  var p = Marker.prototype = Object.create(TQ.Element.prototype);
  Marker.prototype.constructor = Marker;
  p._parent_update = p.update;
  p.update2 = function(t, noRecording) {
    this._parent_update(t, noRecording);
    this.moveToTop();
  };

  p.getTsrInHostObj = function() {
    if (!this.jsonObj.tsrObj) {
      this.jsonObj.tsrObj = TQ.Base.Utility.shadowCopy(TQ.CreateJSAdapter.getDefaultRootTsr());
    }
    return this.jsonObj.tsrObj;
  };

  p.limitHostNoRotation = function() {
    if (this.host) {
      var rotation = this.host.getRotation();
      if (!TQ.Utility.equalToZero(rotation)) {
        // ToDo: 提示
        this.host.rotateTo(0);
      }
    }
  };

  p.moveToTop = function() {
    var id = stageContainer.getNumChildren();
    stageContainer.setChildIndex(this.displayObj, id - 1);
  };

  p.createImage = function() {
    var s = this.displayObj;
    if (!s) {
      TQ.Log.criticalError(TQ.Dictionary.FoundNull);
      return;
    }

    s.graphics.clear(); // 清除老的边框
    TQ.Graphics.drawCircle(s, 0, 0, Marker.RADIUS, GRADIENT_COLOR_S, GRADIENT_COLOR_E);
  };

  p._loadMarker = function() {
    assertNotNull(TQ.Dictionary.FoundNull, this.jsonObj); // 合并jsonObj
    var jsonObj = this.jsonObj;
    var s = new createjs.Shape();
    this.loaded = true;
    s.x = jsonObj.x;
    s.y = jsonObj.y;
    this.displayObj = s;
    this._afterItemLoaded();
    this.setTRSAVZ();
  };

  p.apply = function(ele) {
    this.jsonObj.x = ele.jsonObj.x;
    this.jsonObj.y = ele.jsonObj.y;
    this.dirty2 = true;
    this.setFlag(TQ.Element.TRANSLATING);
    if (TQBase.LevelState.isOperatingCanvas()) {
      this.createImage();
    }
  };

  p.isMarker = function() {
    return true;
  };

  p.getWidth = function() {
    return 2 * Marker.RADIUS;
  };

  p.getHeight = function() {
    return 2 * Marker.RADIUS;
  };

  p.reset = function() {
    this.jsonObj.x = 0;
    this.jsonObj.y = 0;
    this.jsonObj.sx = 1;
    this.jsonObj.sy = 1;
    this.jsonObj.rotation = 0;
    this.jsonObj.animeTrack = this.animeTrack = null;
    this.jsonObj.M = this.jsonObj.IM = null;
  };

  p.allowRecording = function() {
    return false;
  };

  p.noScaleRotation = function() { // marker， 任何时候都是一样的大小， 方位， 不旋转
    this.jsonObj.rotation = 0;
    this.jsonObj.sx = 1;
    this.jsonObj.sy = 1;
  };

  p.tsrObject2World = function(pose) {
    var bakIsVis = this.jsonObj.isVis;
    TQ.CreateJSAdapter.tsrObject2World.call(this, pose);
    this.jsonObj.isVis = bakIsVis;
    this.noScaleRotation();
  };

  // / singleton
  var markers = [];
  var workingMarkers = [];

  Marker.getOne = function() {
    var decs = markers.pop();
    if (decs == null) {
      decs = TQ.Element.build(currScene.currentLevel, { isVis: 0, type: TQ.ElementType.JOINT_MARKER });
    }
    workingMarkers.push(decs);
    return decs;
  };

  p.recycle = function() {
    var aMarker = this;
    var id = workingMarkers.indexOf(aMarker);
    workingMarkers.splice(id, 1);
    markers.push(aMarker);
    aMarker.removeFromStage();
  };

  p.isEditable = function() {
    return !!TQ.InputCtrl.inSubobjectMode;
  };

  p.canSave = function() {
    return false;
  };

  p.toJSON = function() { // 不保存
    return null;
  };

  TQ.Marker = Marker;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
TQ = TQ || {};

(function() {
  // 用法: AnchorMarker是一种修饰品Decoration, 特殊的Marker，只附着在气泡的anchor上.
  function AnchorMarker(level, jsonObj) {
    TQ.Marker.call(this, level, jsonObj);
  }

  AnchorMarker.init = function() {
    markers.splice(0);
    workingMarkers.splice(0);
  };

  var GRADIENT_COLOR_S = "#007";
  var GRADIENT_COLOR_E = "#00F";

  var p = AnchorMarker.prototype = Object.create(TQ.Marker.prototype);
  p.parent_getTsrInHostObj = p.getTsrInHostObj;

  p.getTsrInHostObj = function() {
    var tsrObj = this.parent_getTsrInHostObj();

    if (this.host) { // 在初次创建的时候， 可能没有host
      if (!this.host.getAnchorInObject) {
        TQ.AssertExt.invalidLogic("应该有anchor！");
      } else {
        var anchor = this.host.getAnchorInObject();
        tsrObj.x = anchor.x;
        tsrObj.y = anchor.y;
      }
    }
    return tsrObj;
  };

  p.createImage = function() {
    var s = this.displayObj;
    if (!s) {
      TQ.Log.criticalError(TQ.Dictionary.FoundNull);
      return;
    }

    s.graphics.clear(); // 清除老的边框
    TQ.Graphics.drawCircle(s, 0, 0, TQ.Marker.RADIUS, GRADIENT_COLOR_S, GRADIENT_COLOR_E);
  };

  // / singleton
  var markers = [];
  var workingMarkers = [];

  AnchorMarker.getOne = function() {
    var decs = markers.pop();
    if (!decs) {
      decs = TQ.Element.build(currScene.currentLevel, { isVis: 0, type: TQ.ElementType.ANCHOR_MARKER });
    }
    workingMarkers.push(decs);
    return decs;
  };

  p.recycle = function() {
    var aMarker = this;
    var id = workingMarkers.indexOf(aMarker);
    workingMarkers.splice(id, 1);
    markers.push(aMarker);
    aMarker.removeFromStage();
  };

  TQ.AnchorMarker = AnchorMarker;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 选择集: 所有的操作都是基于选择集的
 */

TQ = TQ || {};
(function() {
  var SelectSet = {};
  var isOn = true; // 允许暂时关闭
  // 需要多重选择的命令， 先开始，连续选择，再点1次，执行并结束
  // 需要连续选择的， 先开始， 然后选1个，执行1个，再点1次则结束
  // 需要单一选择的命令，先选择， 再执行。
  // 同时只能有1个命令在执行（不论是多选，连续选，还是单选） 互斥的操作， 避免同时嵌套使用
  var state = {
    multiCmdStarted: false,
    cmd: null
  };

  var btnEffect = {
    group: null,
    joint: null,
    limitJoint: null
  };
  var latestElement = null;
  var lastSolidElement = null; // 非null的， 可编辑的 element， 不是marker
  var selectedMarkers = []; // 选中的dec元素的集合(转轴点和夹点都是marker)(一个物体上只能选中一个)

  SelectSet.SELECTION_NEW_EVENT = "selected new element";
  SelectSet.SELECTION_EMPTY_EVENT = "selection empty";
  SelectSet.members = [];
  SelectSet.multiCmdGroupIt = multiCmdGroupIt;
  SelectSet.multiCmdJointIt = multiCmdJointIt;
  SelectSet.multiCmdLimitJoint = multiCmdLimitJoint;
  SelectSet.explode = explode;
  SelectSet.btnEffect = btnEffect;

  SelectSet.initialize = function() {
    TQ.Marker.init();
    TQ.AnchorMarker.init();
    SelectSet.members.splice(0);
    state.multiCmdStarted = false;
    state.cmd = null;
    latestElement = null;
    lastSolidElement = null;
    btnEffect.group = null;
    btnEffect.joint = null;
    btnEffect.limitJoint = null;
    TQ.InputMap.registerAction(TQ.InputMap.DELETE_KEY, function() {
      if ((!TQ.TextEditor.visible) && (!TQ.FileDialog.visible)) {
        TQ.SelectSet.delete();
      }
    });
    TQ.InputMap.registerAction(TQ.InputMap.DELETE_KEY | TQ.InputMap.LEFT_ALT_FLAG, TQ.SelectSet.eraseAnimeTrack);
    TQ.InputMap.registerAction(TQ.InputMap.EMPTY_SELECTOR, TQ.SelectSet.clear);

    var keyActionPair = {
      1: "idle",
      2: "work",
      3: "run",
      4: "smile",
      5: "stand"
    };
    TQ.InputMap.registerAction(TQ.InputMap.D1, function() { SelectSet.playAnimation(keyActionPair[1]); });
    TQ.InputMap.registerAction(TQ.InputMap.D2, function() { SelectSet.playAnimation(keyActionPair[2]); });
    TQ.InputMap.registerAction(TQ.InputMap.D3, function() { SelectSet.playAnimation(keyActionPair[3]); });
    TQ.InputMap.registerAction(TQ.InputMap.D4, function() { SelectSet.playAnimation(keyActionPair[4]); });
    TQ.InputMap.registerAction(TQ.InputMap.D5, function() { SelectSet.playAnimation(keyActionPair[5]); });
  };

  SelectSet.playAnimation = function(actionName) {
    var ele = SelectSet.peek();
    if (ele != null) {
      ele.playAction(actionName);
    }
  };

  SelectSet.turnOn = function() {
    isOn = true;
  };
  SelectSet.turnOff = function() {
    isOn = false;
  };

  SelectSet.add = function(element) {
    if (!isOn) {
      return;
    }
    assertNotNull(TQ.Dictionary.PleaseSelectOne, element);
    if ((element == null)) return;

    if (TQ.InputMap.isPresseds[TQ.InputMap.LEFT_SHIFT]) {
      while (element.isMarker()) { //  Decoration 不能记入选择集
        element = element.host;
      }
      if (SelectSet.members.indexOf(element) >= 0) {
        return SelectSet.remove(element);
      } else {
        return;
      }
    }

    latestElement = element;
    if (element.isMarker()) { //  Decoration 不能记入选择集
      selectedMarkers.splice(0); // 最多只能同时选中、操作1个marker
      selectedMarkers.push(element);
      return;
    }

    selectedMarkers.splice(0); // 换了物体， Decoration就可能不被选中了。
    if (!(TQ.InputMap.isPresseds[TQ.InputMap.LEFT_CTRL] || TQ.InputCtrl.vkeyCtrl)) {
      if (!((SelectSet.members.length === 1) && (SelectSet.members.indexOf(element) === 0))) {
        SelectSet.clear();
      }
    }
    if (SelectSet.members.indexOf(element) < 0) {
      SelectSet.members.push(element);
    }

    if (!element.isHighlighting()) {
      element.highlight(true);
      SelectSet.attachDecoration(element);

      // 对于关节物体上的子关节，在整体模式下，情况复杂一些：
      //    如果是“移动关节”： 则选中的是子关节
      //    如果是floatToolbar上的操作，缩放、旋转，等， 则是整体
      if (!TQ.InputCtrl.inSubobjectMode && element.isJoint()) {
        TQ.FloatToolbar.selectedElement = element;
      } else {
        TQ.FloatToolbar.selectedElement = element;
      }
    }

    TQ.Base.Utility.triggerEvent(document, SelectSet.SELECTION_NEW_EVENT, { element: element });
    latestElement = element;
    if (element && !element.isMarker()) {
      lastSolidElement = element;
    }
  };

  SelectSet.addElements = function(elements) {
    var nLen = elements.length;
    if (nLen === 0) return;
    SelectSet.members.splice(0);
    for (var i = 0; i < nLen; i++) {
      var element = elements[i];

      latestElement = element;
      selectedMarkers.splice(0); // 最多只能同时选中、操作1个marker
      selectedMarkers.push(element);
      SelectSet.members.push(element);

      element.highlight(true);
      SelectSet.attachDecoration(element);

      if (!TQ.InputCtrl.inSubobjectMode && element.isJoint()) {
        TQ.FloatToolbar.selectedElement = element;
      } else {
        TQ.FloatToolbar.selectedElement = element;
      }
      TQ.Base.Utility.triggerEvent(document, SelectSet.SELECTION_NEW_EVENT, { element: element });
    }
  };

  /*
     删除当前选中的所有元素
     */
  SelectSet.delete = function() {
    SelectSet.clear(true, true);
  };

  SelectSet.clear = function(withDelete, withEvent) {
    var cmd;
    if (withDelete) {
      cmd = new TQ.CompositeCommand();
    }

    for (var i = 0; i < SelectSet.members.length; i++) {
      var ele = SelectSet.members[i];
      assertNotNull(TQ.Dictionary.FoundNull, ele);
      if (ele.isValid()) ele.highlight(false); // 可能已经被前面的父物体一起删除了
      ele.detachDecoration();
      if (withDelete && ele.isValid()) {
        cmd.addCommand(new TQ.DeleteEleCommand(currScene, ele));
      }
    }
    if (withDelete && (cmd.commands.length > 0)) {
      TQ.CommandMgr.directDo(cmd);
    }

    SelectSet.members.splice(0); // 删除全部选中的物体;
    selectedMarkers.splice(0);
    latestElement = null;
    if (withDelete || withEvent) {
      TQ.DirtyFlag.setScene();
    }

    if (withEvent) {
      TQ.Base.Utility.triggerEvent(document, SelectSet.SELECTION_EMPTY_EVENT, { element: null });
    }
  };

  SelectSet.remove = function(ele) {
    assertNotNull(TQ.Dictionary.FoundNull, ele);
    for (var i = 0; i < SelectSet.members.length; i++) {
      if (ele.id === SelectSet.members[i].id) {
        if (ele.isValid()) { // 可能已经被前面的父物体一起删除了
          ele.highlight(false);
          ele.detachDecoration();
          SelectSet.members.splice(i, 1);
          latestElement = SelectSet.peekEnd();
          break;
        }
      }
    }
  };

  function groupIt() {
    var isUnGroup = TQ.InputMap.isPresseds[TQ.InputMap.LEFT_CTRL] || TQ.InputCtrl.vkeyUngroup;
    if (isUnGroup || (SelectSet.members.length >= 2)) {
      TQ.CommandMgr.directDo(new TQ.GroupCommand(SelectSet.members, isUnGroup));
      SelectSet.clear(false, true);
      return true;
    }

    return false;
  }

  function ungroup() {
    var ungroupFlag = true;
    TQ.CommandMgr.directDo(new TQ.GroupCommand(SelectSet.members, ungroupFlag));
    SelectSet.clear();
  }

  function multiCmd(cmd, options) { // 先开始， 再结束， 必须配对、紧邻，
    if (state.multiCmdStarted) {
      if (state.cmd === cmd) {
        state.multiCmdStarted = false;
        TQ.InputCtrl.clearSubjectModeAndMultiSelect();
        cmd();
        if (state.cmdAfter) {
          state.cmdAfter();
        }
      } else {
        return TQ.MessageBox.prompt(TQ.Locale.getStr("please complete the current operation"));
      }
      return;
    }

    state.multiCmdStarted = true;
    if (options && options.cmdBefore) {
      options.cmdBefore();
    }
    state.cmd = cmd;
    state.cmdAfter = (options && options.cmdAfter) ? options.cmdAfter : null;

    SelectSet.clear();
    TQ.InputCtrl.setMultiSelect();
  }

  function multiCmdGroupIt() {
    return multiCmd(groupIt, {
      cmdBefore: function() {
        // TQ.SelectSet.turnOff();
        btnEffect.group = "effect-working";
      },
      cmdAfter: function() {
        btnEffect.group = null;
        TQ.SelectSet.turnOn();
      }
    });
  }

  var oldStatue = {};
  function multiCmdJointIt() {
    return multiCmd(jointIt, {
      cmdBefore: function() {
        oldStatue.inSubobjectMode = TQ.InputCtrl.inSubobjectMode;
        oldStatue.useMarkerOn = TQ.Config.useMarkerOn;
        TQ.Config.useMarkerOn = true;
        TQ.InputCtrl.inSubobjectMode = true;
        btnEffect.joint = "effect-working";
      },
      cmdAfter: function() {
        TQ.InputCtrl.inSubobjectMode = oldStatue.inSubobjectMode;
        TQ.Config.useMarkerOn = oldStatue.useMarkerOn;
        btnEffect.joint = null;
      }
    });
  }

  function limitJoint() {
    // 虽然是空函数，但是必须有
    // 因为函数使用用来判断是否同一个命令，必须唯一
  }

  function multiCmdLimitJoint() {
    let rotation0;
    let rotation1;
    let ee;
    let isValid = false;
    let parentIsPinned = false;
    return multiCmd(limitJoint, {
      cmdBefore: function() {
        // 确保Parent 是固定的
        ee = SelectSet.peek();
        if (!!ee || ee.isJoint()) {
          rotation0 = ee.getRotation();
          ee.removeLimitation();
          isValid = true;
          if (ee.parent && ee.parent.isPinned()) {
            parentIsPinned = true;
          } else {
            ee.parent.pinIt();
          }
          btnEffect.limitJoint = "effect-working";
        } else {
          TQ.MessageBox.prompt(TQ.Locale.getStr("Please choose a joint, before click the command"));
        }
      },
      cmdAfter: function() {
        if (isValid) {
          rotation1 = ee.getRotation();
          // 确保rotation1 is 最大角
          if (rotation1 < rotation0) {
            rotation1 = [rotation0, rotation0 = rotation1][0];
          }

          TQ.IKCtrl.setLimitation(0, rotation0);
          TQ.IKCtrl.setLimitation(1, rotation1);
          // 确保Parent 是固定的
          if (!parentIsPinned) {
            ee.parent.pinIt();
          }
          btnEffect.limitJoint = null;
        }
      }
    });
  }

  function jointIt() {
    // var hasUnjointFlag = TQ.InputMap.isPresseds[TQ.InputMap.LEFT_CTRL] || TQ.InputCtrl.vkeyUnjoint;
    var hasUnjointFlag = false;
    TQ.InputCtrl.setSubobjectMode();
    TQ.CommandMgr.directDo(new TQ.JointCommand(SelectSet.members, hasUnjointFlag));
    SelectSet.clear(false, true);
  }

  function unjoint() {
    var unJointFlag = true;
    TQ.CommandMgr.directDo(new TQ.JointCommand(SelectSet.members, unJointFlag));
    SelectSet.clear(false, true);
  }

  function explode() {
    if (SelectSet.isEmpty()) {
      return;
    }

    SelectSet.members.forEach(function(ele) {
      if (ele.hasBBox()) {
        TQ.BBox.detachFrom(ele);
      }
    });

    var firstEle = SelectSet.members[0];
    if (firstEle.isBone()) {
      unjoint();
    } else {
      ungroup();
    }
  }

  SelectSet.pinIt = function() {
    for (var i = 0; i < SelectSet.members.length; i++) {
      var ele = SelectSet.members[i];
      assertNotNull(TQ.Dictionary.FoundNull, ele);
      if (ele.isValid()) {
        TQ.CommandMgr.pinIt(ele);
      }
    }
  };

  SelectSet.show = function(visible) {
    var allowIndividual = TQ.InputCtrl.inSubobjectMode || TQ.InputMap.isPresseds[TQ.InputMap.LEFT_ALT];
    TQ.CommandMgr.directDo(new TQ.HideCommand(SelectSet.members, allowIndividual));
  };

  SelectSet.doShow = function(eles, allowIndividual) {
    var isVisible = false;
    var target = null;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      if (!allowIndividual) {
        while (ele.isJoint() && (ele.parent != null)) { // find root for joints
          ele = ele.parent;
        }
      }
      isVisible = ele.isVisible();
      ele.toggleVisibility();
      target = ele;
    }
  };

  SelectSet.eraseAnimeTrack = function() {
    for (var i = 0; i < SelectSet.members.length; i++) {
      var ele = SelectSet.members[i];
      assertNotNull(TQ.Dictionary.FoundNull, ele);
      if (ele.isValid()) {
        ele.eraseAnimeTrack(true);
        ele.updateRecord2(0);
      }
    }
  };

  SelectSet.getElementUnderMouse = function() {
    TQ.Assert.isTrue(!!stage, "没有初始化stage！");
    var target = stage.selectedItem;
    var element = (target == null) ? null : currScene.findAtom(target); // 包括点击菜单, 此函数也会响应
    if (element != null) {
      element = SelectSet.getEditableEle(element);
    }

    return element;
  };

  SelectSet.getSelectedElement = function() {
    var element = SelectSet.getElementUnderMouse();
    if (element != null) {
      SelectSet.add(element);
    } else {
      if (!TQ.InputMap.isPresseds[TQ.InputMap.LEFT_CTRL]) {
        SelectSet.clear();
      }
    }

    return TQ.SelectSet.peek();
  };

  SelectSet.getEditableEle = function(ele) { // 获取Group物体在整体操作模式下的可操作对象
    // Jointed 物体： 获取当前的joint
    // Group的物体: 而且没有打散, 则操作其根
    // 3D打包的物体：操作其根
    if (TQ.InputCtrl.showMarkerOnly) { // 在创作复合物体的时候， 如果不在零件模式，也可以只要求显示Marker。
      // assertTrue(TQ.Dictionary.INVALID_LOGIC, TQ.InputCtrl.inSubobjectMode);
    }

    // BBox 总是不可编辑的
    if (ele.isBBox()) {
      if (ele.parent != null) return TQ.SelectSet.getEditableEle(ele.parent);
    }
    // marker仅仅在 移动pivot点的时候，是可以编辑的
    if (!ele.isJoint() && !ele.isMarker() && isPart(ele)) {
      if ((!TQ.InputCtrl.inSubobjectMode) || TQ.InputCtrl.showMarkerOnly) {
        if (ele.parent != null) return TQ.SelectSet.getEditableEle(ele.parent);
      }
    }
    return ele;
  };

  function isPart(ele) {
    // part 替代原来的 subobject概念
    // marker 和 joint也都是 part， 所以，在editable中要特别处理
    return (ele.isGrouped() || ele.parent);
  }

  SelectSet.isSelected = function(ele) {
    return ((SelectSet.members.indexOf(ele) >= 0) ||
      (selectedMarkers.indexOf(ele) >= 0));
  };

  SelectSet.empty = function() {
    if (SelectSet.members.length > 0) {
      SelectSet.clear(false, true);
    }
    TQ.AssertExt.invalidLogic(selectedMarkers.length === 0);
  };

  SelectSet.unHighlight = function() {
    if (SelectSet.members.length > 0) {
      for (var i = 0; i < SelectSet.members.length; i++) {
        var ele = SelectSet.members[i];
        assertNotNull(TQ.Dictionary.FoundNull, ele);
        if (ele.isValid()) ele.highlight(false); // 可能已经被前面的父物体一起删除了
        ele.detachDecoration();
      }

      // SelectSet.members.splice(0); // 删除全部选中的物体;
      selectedMarkers.splice(0);
      TQ.Base.Utility.triggerEvent(document, SelectSet.SELECTION_EMPTY_EVENT, { element: null });
    }
  };

  SelectSet.isEmpty = function() {
    return (SelectSet.members.length === 0);
  };

  SelectSet.isInMultiCmd = function() {
    return state.multiCmdStarted;
  };

  /*
    返回第一个元素，并且，从选择集中删除它
     */
  SelectSet.pop = function() {
    assertTrue(TQ.Dictionary.INVALID_PARAMETER, SelectSet.members.length > 0); // 非空集合
    var ele = SelectSet.members.pop();
    ele.detachDecoration();
    return (ele);
  };

  /*
     返回 第一个选中的元素， 但是，仍然保留它在选择集中， 不删除
     */
  SelectSet.peek = function() {
    if (SelectSet.members.length <= 0) {
      return null;
    }
    return (SelectSet.members[0]);
  };

  // 返回最后加入的元素
  SelectSet.peekEnd = function() {
    if (SelectSet.members.length <= 0) {
      return null;
    }
    return (SelectSet.members[SelectSet.members.length - 1]);
  };

  SelectSet.textSelected = function() {
    return ((SelectSet.members.length > 0) &&
      SelectSet.members[0].isText());
  };

  function peekLatest() {
    var n = SelectSet.members.length;
    if (n <= 0) {
      return null;
    }
    // 在扣除模式下，lastElement是null
    return !latestElement ? SelectSet.peekEnd() : latestElement;
  }

  SelectSet.peekEditableEle = function() {
    return peekMarker() || SelectSet.peek();
  };

  SelectSet.peekLatestEditableEle = function() {
    var ele = peekMarker() || peekLatest();
    while (ele && !ele.isEditable()) {
      ele = ele.host;
    }
    return ele;
  };

  SelectSet.getLastSolidElement = function() {
    return lastSolidElement;
  };

  SelectSet.switchToRootElement = function() {
    var rootElement = lastSolidElement;
    SelectSet.empty();
    while (rootElement && !!rootElement.parent) {
      rootElement = rootElement.parent;
    }
    SelectSet.add(rootElement);
    return rootElement;
  };

  SelectSet.updateByGesture = function(evt) {
    var selectedNothing = true;
    var touches = TQ.Utility.getTouches(evt);
    if (touches.length <= 0) {
      TQ.AssertExt.invalidLogic(touches.length <= 0, "应该有接触点");
    }
    var touchPoint = touches[0];
    var rect = TQ.SceneEditor.stage._getElementRect(TQ.SceneEditor.stage.canvas);
    var pageX = touchPoint.pageX - rect.left;
    var pageY = touchPoint.pageY - rect.top;
    var displayObjects = TQ.SceneEditor.stageContainer.getObjectsUnderPoint(pageX, pageY);

    if ((!!displayObjects) && (displayObjects.length > 0)) {
      var ele2 = selectTopOnly(displayObjects);
      if (ele2) {
        TQ.SelectSet.add(ele2);
        selectedNothing = false;
        return;
      }
    }

    if (selectedNothing) {
      SelectSet.empty();
    }
  };

  function selectTopOnly(objs) {
    var result;
    for (var i = 0; i < objs.length; i++) {
      if (!objs[i].ele) {
        continue;
      }
      if (!result) {
        result = objs[i].ele;
      } else {
        if (objs[i].ele.getZ() > result.getZ()) {
          result = objs[i].ele;
        }
      }
    }

    if (result) {
      result = TQ.SelectSet.getEditableEle(result);
    }

    return result;
  }

  function peekMarker() {
    if (selectedMarkers.length <= 0) {
      return null;
    }
    return (selectedMarkers[0]);
  }

  SelectSet.attachDecoration = function(ele) {
    if (!ele.decorations) {
      if (ele.isEditable()) {
        if (TQ.Config.useMarkerOn) {
          ele.attachMarker();
        }
        TQ.BBox.attachTo(ele);
      }
    }
  };

  // 命令：
  function GroupCommand(elements, hasUngroupFlag) {
    this.receiver = [];
    for (var i = 0; i < elements.length; i++) { // 需要复制元素， 防止原来的集合被clear清空
      this.receiver.push(elements[i]);
    }
    this.oldValue = !hasUngroupFlag;
    this.newValue = hasUngroupFlag;
  }

  TQ.inherit(GroupCommand, TQ.AbstractCommand);

  GroupCommand.prototype.do = function() {
    currScene.groupIt(this.receiver, this.newValue);
    return (this.constructor.name2 + this.receiver);
  };

  GroupCommand.prototype.undo = function() {
    if (this.oldValue) { // ungroup 需要这些元素的根（Group元素）， 而不需要这些元素本身
      assertTrue(TQ.Dictionary.INVALID_PARAMETER, this.receiver.length > 0);
      currScene.groupIt([this.receiver[0].parent], this.oldValue);
    }
    return (this.constructor.name2 + this.receiver);
  };

  GroupCommand.prototype.redo = GroupCommand.prototype.do;

  function JointCommand(elements, hasUnjointFlag) {
    this.receiver = [];
    for (var i = 0; i < elements.length; i++) {
      this.receiver.push(elements[i]);
    }
    this.oldValue = !hasUnjointFlag;
    this.newValue = hasUnjointFlag;
  }

  TQ.inherit(JointCommand, TQ.AbstractCommand);

  JointCommand.prototype.do = function() {
    currScene.joint(this.receiver, this.newValue);
    return (this.constructor.name2 + this.receiver);
  };

  JointCommand.prototype.undo = function() {
    currScene.joint(this.receiver, this.oldValue);
    return (this.constructor.name2 + this.receiver);
  };

  JointCommand.prototype.redo = JointCommand.prototype.do;

  // 命令：
  function HideCommand(elements, allowIndividual) {
    this.receiver = [];
    for (var i = 0; i < elements.length; i++) { // 需要复制元素， 防止原来的集合被clear清空
      this.receiver.push(elements[i]);
    }
    this.oldValue = allowIndividual;
    this.newValue = allowIndividual;
  }

  TQ.inherit(HideCommand, TQ.AbstractCommand);

  HideCommand.prototype.do = function() {
    SelectSet.doShow(this.receiver, this.newValue);
    return (this.constructor.name2 + this.receiver);
  };

  HideCommand.prototype.undo = function() {
    SelectSet.doShow(this.receiver, this.oldValue);
    return (this.constructor.name2 + this.receiver);
  };

  HideCommand.prototype.redo = HideCommand.prototype.do;

  GroupCommand.name2 = "GroupCommand";
  JointCommand.name2 = "JointCommand";
  HideCommand.name2 = "HideCommand";

  TQ.GroupCommand = GroupCommand;
  TQ.JointCommand = JointCommand;
  TQ.HideCommand = HideCommand;
  TQ.SelectSet = SelectSet;
}());

/*
* Filter
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

// namespace:
this.createjs = this.createjs || {};

(function() {
  /**
     * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using
     * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use
     * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}.
     *
     * <h4>Example</h4>
     *      myInstance.cache(0,0, 100, 100);
     *      myInstance.filters = [
     *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
     *          new createjs.BoxBlurFilter(5, 5, 10)
     *      ];
     *
     * <h4>EaselJS Filters</h4>
     * EaselJS comes with a number of pre-built filters. Note that individual filters are not compiled into the minified
     * version of EaselJS. To use them, you must include them manually in the HTML.
     * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>
     *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>
     *      <li>{{#crossLink "BoxBlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>
     *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>
     *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
     * </ul>
     *
     * @class Filter
     * @constructor
     **/
  var Filter = function() {
    this.initialize();
  };
  var p = Filter.prototype;

  // constructor:
  /**
	 * Initialization method.
	 * @method initialize
	 * @protected
	 **/
  p.initialize = function() { };

  // public methods:
  /**
	 * Returns a rectangle with values indicating the margins required to draw the filter.
	 * For example, a filter that will extend the drawing area 4 pixels to the left, and 7 pixels to the right
	 * (but no pixels up or down) would return a rectangle with (x=-4, y=0, width=11, height=0).
	 * @method getBounds
	 * @return {Rectangle} a rectangle object indicating the margins required to draw the filter.
	 **/
  p.getBounds = function() {
    return new createjs.Rectangle(0, 0, 0, 0);
  };

  /**
	 * Applies the filter to the specified context.
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} targetCtx Optional. The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} targetX Optional. The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} targetY Optional. The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean}
	 **/
  p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) { };

  /**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
  p.toString = function() {
    return "[Filter]";
  };

  /**
	 * Returns a clone of this Filter instance.
	 * @method clone
	 @return {Filter} A clone of the current Filter instance.
	 **/
  p.clone = function() {
    return new Filter();
  };

  createjs.Filter = Filter;
}());

/*
* ColorFilter
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

// namespace:
this.createjs = this.createjs || {};

(function() {
  /**
     * Applies color transforms.
     *
     * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters.
     * @class ColorFilter
     * @constructor
     * @extends Filter
     * @param {Number} redMultiplier
     * @param {Number} greenMultiplier
     * @param {Number} blueMultiplier
     * @param {Number} alphaMultiplier
     * @param {Number} redOffset
     * @param {Number} greenOffset
     * @param {Number} blueOffset
     * @param {Number} alphaOffset
     **/
  var ColorFilter = function(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
    this.initialize(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset);
  };
  var p = ColorFilter.prototype = new createjs.Filter();

  // public properties:
  /**
	 * Red channel multiplier.
	 * @property redMultiplier
	 * @type Number
	 **/
  p.redMultiplier = 1;

  /**
	 * Green channel multiplier.
	 * @property greenMultiplier
	 * @type Number
	 **/
  p.greenMultiplier = 1;

  /**
	 * Blue channel multiplier.
	 * @property blueMultiplier
	 * @type Number
	 **/
  p.blueMultiplier = 1;

  /**
	 * Alpha channel multiplier.
	 * @property redMultiplier
	 * @type Number
	 **/
  p.alphaMultiplier = 1;

  /**
	 * Red channel offset (added to value).
	 * @property redOffset
	 * @type Number
	 **/
  p.redOffset = 0;

  /**
	 * Green channel offset (added to value).
	 * @property greenOffset
	 * @type Number
	 **/
  p.greenOffset = 0;

  /**
	 * Blue channel offset (added to value).
	 * @property blueOffset
	 * @type Number
	 **/
  p.blueOffset = 0;

  /**
	 * Alpha channel offset (added to value).
	 * @property alphaOffset
	 * @type Number
	 **/
  p.alphaOffset = 0;

  // constructor:
  /**
	 * Initialization method.
	 * @method initialize
	 * @protected
	 **/
  p.initialize = function(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
    this.redMultiplier = redMultiplier != null ? redMultiplier : 1;
    this.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;
    this.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;
    this.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;
    this.redOffset = redOffset || 0;
    this.greenOffset = greenOffset || 0;
    this.blueOffset = blueOffset || 0;
    this.alphaOffset = alphaOffset || 0;
  };

  // public methods:
  /**
	 * Applies the filter to the specified context.
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} targetCtx Optional. The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} targetX Optional. The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} targetY Optional. The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean}
	 **/
  p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
    targetCtx = targetCtx || ctx;
    if (targetX == null) { targetX = x; }
    if (targetY == null) { targetY = y; }
    try {
      var imageData = ctx.getImageData(x, y, width, height);
    } catch (e) {
      // if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);
      return false;
    }
    var data = imageData.data;
    var l = data.length;
    for (var i = 0; i < l; i += 4) {
      data[i] = data[i] * this.redMultiplier + this.redOffset;
      data[i + 1] = data[i + 1] * this.greenMultiplier + this.greenOffset;
      data[i + 2] = data[i + 2] * this.blueMultiplier + this.blueOffset;
      data[i + 3] = data[i + 3] * this.alphaMultiplier + this.alphaOffset;
    }
    imageData.data = data;
    targetCtx.putImageData(imageData, targetX, targetY);
    return true;
  };

  /**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
  p.toString = function() {
    return "[ColorFilter]";
  };

  /**
	 * Returns a clone of this ColorFilter instance.
	 * @method clone
	 * @return {ColorFilter} A clone of the current ColorFilter instance.
	 **/
  p.clone = function() {
    return new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
  };

  createjs.ColorFilter = ColorFilter;
}());

this.createjs = this.createjs || {};

(function() {
  var BaseParticle = function(particleObject) {
    this.initialize(particleObject);
  };
  var p = BaseParticle.prototype;

  // ** PUBLIC PROPERTIES
  p.debugMode = true;
  p.originX = 0;
  p.originY = 0;
  p.velocityX = 0; // pixels per second
  p.velocityY = 0; // pixels per second
  p.linearVelocityX = 0; // pixels per second
  p.linearVelocityY = 0; // pixels per second
  p.radialVelocity = 0; // pixels per second, 角速度
  p.tangentalVelocity = 0; // pixels per second，切线速度， 切线方向随物体的旋转而改变
  p.radialAcceleration = 0; // pixels per second per second
  p.tangentalAcceleration = 0; // pixels per second per second
  p.linearAccelerationX = 0; // pixels per second per second
  p.linearAccelerationY = 0; // pixels per second per second
  p.particleBaseId = 0;

  // ** PRIVATE PROPERTIES:
  p._lastUpdateTimeMs = 0;

  // ** CONSTRUCTOR:
  p.initialize = function(particleObject) {
    this._particleObject = particleObject;
  };

  // ** PUBLIC METHODS:
  p.initializeProperties = function(id) {
    this.particleBaseId = id;
  };

  p.updateParticle = function(ctx) {
    var currentTimeMs = createjs.Ticker.getTime();

    if (!TQ.FrameCounter.isPlaying()) {
      currentTimeMs = this._lastUpdateTimeMs;
    }

    this.updatePosition(currentTimeMs);
  };

  p.updatePosition = function(currentTimeMs) {
    var diffTimeMs = currentTimeMs - this._lastUpdateTimeMs;
    var fractionTime = diffTimeMs / 1000;

    if (this._lastUpdateTimeMs <= 0) {
      this._lastUpdateTimeMs = currentTimeMs;
      return;
    }

    this.velocityX = 0;
    this.velocityY = 0;

    // Process accelerations
    this._processLinearAcceleration(fractionTime);
    this._processRadialAcceleration(fractionTime);
    this._processTangentalAcceleration(fractionTime);

    // Process velocitys
    this._processLinearVelocity(fractionTime);
    this._processRadialAndTangentalVelocity(fractionTime);

    // Update position
    this._processVelocity();
    this._lastUpdateTimeMs = currentTimeMs;
  };

  // ** PRIVATE METHODS:
  p._processLinearAcceleration = function(fractionTime) {
    var accelerationTickX = this.linearAccelerationX * fractionTime;
    var accelerationTickY = this.linearAccelerationY * fractionTime;

    this.linearVelocityX += accelerationTickX;
    this.linearVelocityY += accelerationTickY;
  };

  p._processRadialAcceleration = function(fractionTime) {
    var radialAceelerationTick = this.radialAcceleration * fractionTime;

    this.radialVelocity += radialAceelerationTick;
  };

  p._processTangentalAcceleration = function(fractionTime) {
    var tangentalAceelerationTick = this.tangentalAcceleration * fractionTime;

    this.tangentalVelocity += tangentalAceelerationTick;
  };

  p._processLinearVelocity = function(fractionTime) {
    var velocityTickY = this.linearVelocityY * fractionTime;
    var velocityTickX = this.linearVelocityX * fractionTime;

    this.velocityX += velocityTickX;
    this.velocityY += velocityTickY;
  };

  p._processRadialAndTangentalVelocity = function(fractionTime) {
    var center = this._getParticleCenter();
    var deltaY = this.originY - center.y;
    var deltaX = this.originX - center.x;
    var angle = Math.atan2(deltaY, deltaX);

    this._processRadialVelocity(fractionTime, angle);
    this._processTangentalVelocity(fractionTime, angle);
  };

  p._processRadialVelocity = function(fractionTime, angle) {
    var velocityTickX = this.radialVelocity * fractionTime * Math.cos(angle);
    var velocityTickY = this.radialVelocity * fractionTime * Math.sin(angle);

    this.velocityX += velocityTickX;
    this.velocityY += velocityTickY;
  };

  p._processTangentalVelocity = function(fractionTime, angle) {
    var velocityTickX = this.tangentalVelocity * fractionTime * Math.cos(angle - (Math.PI / 2));
    var velocityTickY = this.tangentalVelocity * fractionTime * Math.sin(angle - (Math.PI / 2));

    this.velocityX += velocityTickX;
    this.velocityY += velocityTickY;
  };

  p._processVelocity = function() {
    this._particleObject.x += this.velocityX;
    this._particleObject.y += this.velocityY;
  };

  p._getParticleCenter = function() {
    var center = {
      x: this._particleObject.x,
      y: this._particleObject.y
    };

    return center;
  };

  p._debugText = function(text) {
    if (this.debugMode) {
      TQ.Log.debugInfo(text);
    }
  };

  // ** PRIVATE EVENT HANDLERS:

  createjs.BaseParticle = BaseParticle;
}());

// NAMESPACE:
this.createjs = this.createjs || {};

(function() {
  // ** ENUMS

  /**
     * A shape particle
     * @constructor
     * @extends createjs.Bitmap
     */
  var BitmapParticle = function(image) {
    this.initialize(image);
  };
  var p = BitmapParticle.prototype = new createjs.Bitmap();

  // ** BASE METHODS
  p.Bitmap_initialise = p.initialize;
  p.Bitmap_draw = p.draw;
  p.Bitmap_updateContext = p.updateContext;

  // ** PUBLIC PROPERTIES:
  p.particleId = 0;

  // ** PRIVATE PROPERTIES:
  p._baseParticle = null;

  // ** CONSTRUCTOR:
  p.initialize = function(image) {
    this.Bitmap_initialise(image);
    this._baseParticle = new createjs.BaseParticle(this);
  };

  // ** PUBLIC METHODS:
  p.initializeProperties = function(id) {
    this.particleId = id;
    this._baseParticle.initializeProperties(id);
  };

  p.updateContext = function(ctx) {
    this._baseParticle.updateParticle();
    this.Bitmap_updateContext(ctx);
  };

  // ** PRIVATE METHODS:

  // ** PRIVATE EVENT HANDLERS:

  createjs.BitmapParticle = BitmapParticle;
}());

// NAMESPACE:
this.createjs = this.createjs || {};

(function() {
  /**
     * A shape particle
     * @constructor
     * @extends createjs.Shape
     */
  var ShapeParticle = function() {
    this.initialize();
  };
  var p = ShapeParticle.prototype = new createjs.Shape();

  // ** BASE METHODS
  p.Shape_initialise = p.initialize;
  p.Shape_draw = p.draw;
  p.Shape_updateContext = p.updateContext;

  // ** PUBLIC PROPERTIES:
  p.particleId = 0;

  // ** PRIVATE PROPERTIES:
  p._baseParticle = null;

  // ** CONSTRUCTOR:
  p.initialize = function() {
    this.Shape_initialise();
    this._baseParticle = new createjs.BaseParticle(this);
  };

  // ** PUBLIC METHODS:
  p.initializeProperties = function(id) {
    this.particleId = id;
    this._baseParticle.initializeProperties(id);
  };

  p.updateContext = function(ctx) {
    this.Shape_updateContext(ctx);
    this._baseParticle.updateParticle();
  };

  // ** PRIVATE METHODS:

  // ** PRIVATE EVENT HANDLERS:

  createjs.ShapeParticle = ShapeParticle;
}());

/**
 * @module createjs
 */
this.createjs = this.createjs || {};

(function() {
  "use strict";

  /**
     * A Particle Emitter extends DisplayObject and must be added to a Container object. An emitter will emit a stream of particles
     * adhereing to the given configuration.
     * @class ParticleEmitter
     * @constructor
     * @param {Image} [image] The image to use for each particle. If no image is provided then a simple circle will be drawn.
     **/
  var ParticleEmitter = function(image) {
    if (image != null) {
      this.image = image;
    }

    this.initialize();
  };
  var p = ParticleEmitter.prototype = new createjs.DisplayObject();
  ParticleEmitter.stopped = false;
  // #region Enums + Constants

  /**
     * Enum to represent the state of the particle emitter
     **/
  createjs.ParticleEmitterState = {
    "Created": 0,
    "Running": 1,
    "Finished": 2
  };

  /**
     * Enum to represent the type of the particle emitter
     **/
  createjs.ParticleEmitterType = {
    "Emit": 0,
    "OneShot": 1
  };

  // ** CONSTANTS:
  p.REMAIN_UNCHANGED = null;
  p.INFINITE = -1;

  // #endregion

  // ** BASE METHODS
  p.DisplayObject_initialise = p.initialize;
  p.DisplayObject_draw = p.draw;
  p.DisplayObject_updateContext = p.updateContext;

  // #region Public Properties (Emitter specific)

  /**
     * Should the emitter be removed from the parent when finished?
     *
     * @property autoRemoveOnFinished
     * @type {boolean}
     * @default false
     **/
  p.autoRemoveOnFinished = false;

  /**
     * Is debug mode active for this emitter. If so, render debug text.
     *
     * @property debugMode
     * @type {boolean}
     * @default false
     **/
  p.debugMode = false;

  /**
     * The amount of time (milliseconds) that the emitter will last. A value of -1 means that the emitter will
     * last for an infinite amount of time.
     *
     * @property duration
     * @type {number}
     * @default -1
     **/
  p.duration = p.INFINITE;

  /**
     * The type of particle emitter to create
     *
     * @property emitterType
     * @type {ParticleEmitterType}
     * @default ParticleEmitterType.Emit
     **/
  p.emitterType = createjs.ParticleEmitterType.Emit;

  /**
     * The total number of particles that can exist at any one time
     *
     * @property maxParticles
     * @type {number}
     * @default 200
     **/
  p.maxParticles = 200;

  /**
     * The rate at which particles are generated (number of particles per second)
     *
     * @property emissionRate
     * @type {number}
     * @default 1
     **/
  p.emissionRate = 1;

  /**
     * The current state of the particle emitter
     *
     * @property state
     * @type {ParticleEmitterState}
     * @default ParticleEmitterState.Created
     **/
  p.state = createjs.ParticleEmitterState.Created;

  /**
     * The image to show for each particle
     *
     * @property image
     * @type {Image}
     * @default null
     **/
  p.image = null;

  // #endregion
  // #region Public Properties (Particle generation)

  /**
     * The accelerration of each particle in the X axis.
     *
     * @property accelerationX
     * @type {decimal}
     * @default 0
     **/
  p.accelerationX = 0;

  /**
     * The accelerration of each particle in the Y axis. This can be used to simulate forces such as Gravity
     *
     * @property accelerationY
     * @type {decimal}
     * @default 0
     **/
  p.accelerationY = 0;

  /**
     * The angle (degrees) in which to fire the particle from the origin point
     *
     * @property angle
     * @type {number}
     * @default 0
     **/
  p.angle = 0;

  /**
     * The amount of degrees that the angle can vary by
     *
     * @property angleVar
     * @type {number}
     * @default 0
     **/
  p.angleVar = 0;

  /**
     * The end opacity of each particle, where 1 is opaque and 0 is transparent. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endOpacity
     * @type {number}
     * @default null
     **/
  p.endOpacity = p.REMAIN_UNCHANGED;

  /**
     * The end color of each particle [r,g,b]. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endColor
     * @type {[r,g,b]}
     * @default null
     **/
  p.endColor = p.REMAIN_UNCHANGED;

  /**
     * The variance in the end color. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endColorVar
     * @type {[r,g,b]}
     * @default null
     **/
  p.endColorVar = [0, 0, 0];

  /**
     * The end size of each particle, in pixels. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endSize
     * @type {number}
     * @default null
     **/
  p.endSize = p.REMAIN_UNCHANGED;

  /**
     * The variance in end size, in pixels. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endSizeVar
     * @type {number}
     * @default 0
     **/
  p.endSizeVar = 0.0;

  /**
     * The number of degrees to spin each particle per second when each particle is destroyed. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endSpin
     * @type {number}
     * @default null
     **/
  p.endSpin = p.REMAIN_UNCHANGED;

  /**
     * The variance in end spin. A null value signifies that
     * the value will not differ from the start value.
     *
     * @property endSpinVar
     * @type {number}
     * @default 0
     **/
  p.endSpinVar = 0;

  /**
     * The amount of time (milliseconds) that each particle will last before being destroyed
     *
     * @property life
     * @type {number}
     * @default 4000
     **/
  p.life = 4000;

  /**
     * The variance in the amount of life time (milliseconds)
     *
     * @property lifeVar
     * @type {number}
     * @default 0
     **/
  p.lifeVar = 0;

  /**
     * The variance in the x position of emitted particles
     *
     * @property positionVarX
     * @type {number}
     * @default 0
     **/
  p.positionVarX = 0;

  /**
     * The variance in the y position of emitted particles
     *
     * @property positionVarY
     * @type {number}
     * @default 0
     **/
  p.positionVarY = 0;

  /**
     * The radial acceleration of the particle
     *
     * @property radialAcceleration
     * @type {number}
     * @default 0
     **/
  p.radialAcceleration = 0;

  /**
     * The variance of the radial acceleration of the particle
     *
     * @property radialAccelerationVar
     * @type {number}
     * @default 0
     **/
  p.radialAccelerationVar = 0;

  /**
     * The number of pixels per second that the particle will move
     *
     * @property speed
     * @type {number}
     * @default 10
     **/
  p.speed = 10;

  /**
     * The number of pixels per second that the speed can vary by
     *
     * @property speedVar
     * @type {number}
     * @default 0
     **/
  p.speedVar = 0;

  /**
     * The start opacity of each particle, where 1 is opaque and 0 is transparent
     *
     * @property startOpacity
     * @type {number}
     * @default 0
     **/
  p.startOpacity = 1;

  /**
     * The color of each particle [r,g,b] when it is created
     *
     * @property startColor
     * @type {[r,g,b]}
     * @default [255,0,0]
     **/
  p.startColor = [255, 0, 0];

  /**
     * The variance in the start color
     *
     * @property startColorVar
     * @type {[r,g,b]}
     * @default [0,0,0]
     **/
  p.startColorVar = [0, 0, 0];

  /**
     * The start size of each particle, in pixels
     *
     * @property startSize
     * @type {number}
     * @default 20
     **/
  p.startSize = 20;

  /**
     * The variance in start size, in pixels
     *
     * @property startSizeVar
     * @type {number}
     * @default 0
     **/
  p.startSizeVar = 0;

  /**
     * The number of degrees to spin each particle per second when each particle is created
     *
     * @property startSpin
     * @type {number}
     * @default 0
     **/
  p.startSpin = 0;

  /**
     * The variance in start spin
     *
     * @property startSpinVar
     * @type {number}
     * @default 0
     **/
  p.startSpinVar = 0;

  /**
     * The tangental acceleration of the particle
     *
     * @property tangentalAcceleration
     * @type {number}
     * @default 0
     **/
  p.tangentalAcceleration = 0;

  //
  /**
     * The variance in the tangental acceleration of the particle
     *
     * @property tangentalAccelerationVar
     * @type {number}
     * @default 0
     **/
  p.tangentalAccelerationVar = 0;

  // #endregion
  // #region Private Properties

  // The total number of particles emitted by this emitter
  p._totalEmitted = 0;

  // The time the emitter started
  p._timeStarted = 0;

  // The time at which the last particle was emitted
  p._timeLastParticleEmitted = 0;

  // All the particles currently managed by this emitter
  p._particles = [];

  // #endregion

  // #region Public Methods

  p.changeImage = function(image) {
    this.image = image; // image宽度和高度必须与上一个图像的一致
  };

  /**
     * Resets the emitter which removes any active particles before starting all over again.
     *
     * @method reset
     */
  p.reset = function() {
    while (this._particles.length > 0) {
      var particle = this._particles[0];

      if (particle.filters != null) {
        for (var filterIndex in particle.filters) {
          createjs.Tween.removeTweens(particle.filters[filterIndex]);
        }
      }

      particle.uncache();
      createjs.Tween.removeTweens(particle);

      this._particles.splice(0, 1);
      this.parent.removeChild(particle);
    }

    this._timeLastParticleEmitted = 0;
    this.state = createjs.ParticleEmitterState.Created;
  };

  // #endregion
  // #region Private Methods

  p.initialize = function() {
    this.DisplayObject_initialise();
  };

  p.updateContext = function(ctx) {
    this.DisplayObject_updateContext(ctx);

    var currentTimeMilli = createjs.Ticker.getTime();

    if (!TQ.FrameCounter.isPlaying()) {
      currentTimeMilli = this._lastUpdateTimeMs;
    }

    if (ParticleEmitter.stopped) { // 停止了
      currentTimeMilli = this._lastUpdateTimeMs;
    }

    // Update state
    if (this.state === createjs.ParticleEmitterState.Created) {
      this._timeStarted = currentTimeMilli;
      this.state = createjs.ParticleEmitterState.Running;
    } else if (this.duration !== this.INFINITE &&
            currentTimeMilli > (this._timeStarted + this.duration)) {
      this.state = createjs.ParticleEmitterState.Finished;
    }

    // If RUNNING, try to generate a particle
    if (this.state === createjs.ParticleEmitterState.Running) {
      switch (this.emitterType) {
        case createjs.ParticleEmitterType.OneShot:
          this._oneShot(currentTimeMilli);
          break;
        case createjs.ParticleEmitterType.Emit:
        default:
          this._emit(currentTimeMilli);
          break;
      }
    } else if (this.state === createjs.ParticleEmitterState.Finished) {
      // If FINISHED, remove from parent
      if (this.autoRemoveOnFinished) {
        this.parent.removeChild(this);
      }
    }

    // Call updateCache if color tweening is required
    // NB. ColorFilter (or any other type of filter) tweening is computationally very expensive.
    // Therefore if you wish to use color tweening, then we recommend trying to minimize:
    //  a) the emission rate, and
    //  b) the start and end size of the particles
    if (this.endColor !== p.REMAIN_UNCHANGED) {
      for (var i = 0; i < this._particles.length; i++) {
        this._particles[i].updateCache();
      }
    }
  };

  p._emit = function(currentTimeMilli) {
    var millisecondsPerParticle = 1000 / this.emissionRate;
    if (currentTimeMilli > (this._timeLastParticleEmitted + millisecondsPerParticle)) {
      if (this._particles.length < this.maxParticles) {
        this._generateParticle();
        this._timeLastParticleEmitted = currentTimeMilli;
      }
    }
  };

  p._oneShot = function(currentTimeMilli) {
    if (this._particles.length === 0) {
      for (var i = 0; i < this.maxParticles; i++) {
        this._generateParticle();
      }

      this._timeLastParticleEmitted = currentTimeMilli;
    }
  };

  // Generate a new particle
  p._generateParticle = function() {
    var o = this;
    this._debugText("generateParticle");

    // Get properties
    var startOpacity = this.startOpacity;
    var startColor = this._getColor(this.startColor, this.startColorVar);
    var startSize = this._getVariedValue(this.startSize, this.startSizeVar, true);
    var startSpin = this._getVariedValue(this.startSpin, this.startSpinVar, false);
    var endColor = this.endColor === this.REMAIN_UNCHANGED ? this.startColor : this._getColor(this.endColor, this.endColorVar);
    var endSize = this.endSize === this.REMAIN_UNCHANGED ? this.startSize : this._getVariedValue(this.endSize, this.endSizeVar, true);
    var endSpin = this.endSpin === this.REMAIN_UNCHANGED ? this.startSpin : this._getVariedValue(this.endSpin, this.endSpinVar, true);
    var endOpacity = this.endOpacity === this.REMAIN_UNCHANGED ? this.startOpacity : this.endOpacity;
    var scale = endSize / startSize;
    var speed = this._getVariedValue(this.speed, this.speedVar, true);
    var life = this._getVariedValue(this.life, this.lifeVar, true);
    var angle = this._getAngle(this.angle, this.angleVar);
    var distance = speed * life / 1000;
    var startPos = {
      x: this._getVariedValue(this.position.x, this.positionVarX, false),
      y: this._getVariedValue(this.position.y, this.positionVarY, false)
    };
    var endPos = this._getPositionInDirection(this.position, angle, distance);
    var dx = endPos.x - this.position.x;
    var dy = endPos.y - this.position.y;

    // Create shape
    var shape = this._createParticle(startPos, startColor, startOpacity, startSize, startSpin, life, dx, dy);
    this.parent.addChild(shape);

    // Create color filter
    var colorFilter = this._createColorFilter(shape, startColor);

    // Cache shape
    if (this.image == null) {
      shape.cache(0, 0, startSize, startSize);
    } else {
      shape.cache(0, 0, this.image.width, this.image.height, startSize / this.image.width);
    }

    // Animate
    scale = scale * shape.scaleX;
    createjs.Tween.get(shape).to({ scaleX: scale, scaleY: scale, rotation: endSpin, alpha: endOpacity }, life).call(function() {
      o._onParticleFinished(shape);
    });
    createjs.Tween.get(colorFilter).to({ redMultiplier: endColor[0] / 255.0, greenMultiplier: endColor[1] / 255.0, blueMultiplier: endColor[2] / 255.0 }, life);

    // Finalize
    this._particles.push(shape);
    this._totalEmitted++;

    // Write to console
    this._debugText(this._format("Particle [s_x:{0}, s_y:{1}, e_x:{2}, e_y:{3}]", this.position.x, this.position.y, endPos.x, endPos.y));
  };

  p._createColorFilter = function(shape, color) {
    var filter = new createjs.ColorFilter(color[0] / 255.0, color[1] / 255.0, color[2] / 255.0, 1);
    shape.filters = [filter];

    return filter;
  };

  p._createParticle = function(position, color, alpha, size, spin, life, dx, dy) {
    var shape = null;

    if (this.image != null) {
      shape = this._createImageParticle(color, size);
    } else {
      shape = this._createCircleParticle(color, size);
    }

    var originalWidth = this.image != null ? this.image.width : size;
    var originalHeight = this.image != null ? this.image.height : size;

    shape._baseParticle.originX = this.position.x;
    shape._baseParticle.originY = this.position.y;
    shape._baseParticle.linearVelocityX = dx / life * 1000;
    shape._baseParticle.linearVelocityY = dy / life * 1000;
    shape._baseParticle.linearAccelerationX = this.accelerationX;
    shape._baseParticle.linearAccelerationY = this.accelerationY;
    shape._baseParticle.radialAcceleration = this._getVariedValue(this.radialAcceleration, this.radialAccelerationVar, false);
    shape._baseParticle.tangentalAcceleration = this._getVariedValue(this.tangentalAcceleration, this.tangentalAccelerationVar, false);

    shape.alpha = alpha;
    shape.rotation = spin;
    shape.x = position.x;
    shape.y = position.y;
    shape.regX = originalWidth / 2;
    shape.regY = originalHeight / 2;

    shape.initializeProperties(this._totalEmitted);

    return shape;
  };

  p._createImageParticle = function(color, size) {
    var bitmap = new createjs.BitmapParticle(this.image);
    bitmap.scaleX = size / this.image.width;
    bitmap.scaleY = bitmap.scaleX;

    return bitmap;
  };

  p._createCircleParticle = function(color, size) {
    var shape = new createjs.ShapeParticle();
    var colorRgb = createjs.Graphics.getRGB(255, 255, 255);
    shape.graphics.beginFill(colorRgb).drawCircle(size / 2, size / 2, size / 2);
    shape.alpha = 255;

    return shape;
  };

  p._debugText = function(text) {
    if (this.debugMode) {
      TQ.Log.debugInfo(text);
    }
  };

  p._getPositionInDirection = function(startPoint, angle, length) {
    var newX = startPoint.x + (this._cosd(angle) * length);
    var newY = startPoint.y + (this._sind(angle) * length);

    return new createjs.Point(newX, newY);
  };

  p._getVariedValue = function(base, variance, applyLowerLimit) {
    var plusOrMinus = this._intRandom(1) === 1 ? 1 : -1;
    var variedValue = base + (this._intRandom(variance) * plusOrMinus);

    if (applyLowerLimit || false) {
      variedValue = this._lowerLimit(variedValue);
    }

    return variedValue;
  };

  p._getAngle = function(base, variance) {
    var unlimited = this._getVariedValue(base, variance);
    unlimited = unlimited < 0 ? 360 + unlimited : unlimited;
    unlimited = unlimited > 360 ? unlimited - 360 : unlimited;
    return unlimited;
  };

  p._getColor = function(base, variance) {
    var r = variance == null ? base[0] : this._getVariedValue(base[0], variance[0]);
    var g = variance == null ? base[1] : this._getVariedValue(base[1], variance[1]);
    var b = variance == null ? base[2] : this._getVariedValue(base[2], variance[2]);

    r = this._rgbLimit(r);
    g = this._rgbLimit(g);
    b = this._rgbLimit(b);

    var color = [r, g, b];

    return color;
  };

  p._rgbLimit = function(unlimitedVal) {
    var limitedVal = this._lowerLimit(unlimitedVal);
    limitedVal = limitedVal > 255 ? 255 : limitedVal;
    return limitedVal;
  };

  p._lowerLimit = function(unlimitedVal) {
    var limitedVal = unlimitedVal < 0 ? 0 : unlimitedVal;
    return limitedVal;
  };

  /** * Generate a random integer between 0-x (inclusive) */
  p._intRandom = function(upperbound) {
    return Math.floor(Math.random() * (upperbound + 1));
  };

  p._sind = function(degrees) {
    return Math.sin(this._toRadians(degrees));
  };

  p._cosd = function(degrees) {
    return Math.cos(this._toRadians(degrees));
  };

  p._toRadians = function(degrees) {
    return degrees * Math.PI / 180;
  };

  p._format = function() {
    var s = arguments[0];
    for (var i = 0; i < arguments.length - 1; i++) {
      var reg = new RegExp("\\{" + i + "\\}", "gm");
      s = s.replace(reg, arguments[i + 1]);
    }
    return s;
  };

  // #endregion
  // #region Private Event Handlers

  // Called when a particles life is over
  p._onParticleFinished = function(particle) {
    particle.uncache();
    var particleIndex = this._particles.indexOf(particle);
    this._particles.splice(particleIndex, 1);
    this.parent.removeChild(particle);

    if (this._particles.length === 0 && this.state === createjs.ParticleEmitterState.Running && this.emitterType === createjs.ParticleEmitterType.OneShot) {
      this.state = createjs.ParticleEmitterState.Finished;
    }
  };

  // #endregion

  createjs.ParticleEmitter = ParticleEmitter;
}());

var TQ = TQ || {};

(function() {
  "use strict";

  /**
     * A shape particle
     * @constructor
     * @extends createjs.Shape
     */
  var SnowEffect = function() {
  };

  var FeParticle = SnowEffect;
  FeParticle.SNOW = "snow";
  FeParticle.RAIN = "rain";
  FeParticle.MONEY = "money";

  SnowEffect.initialize = initialize;
  SnowEffect.getDefaultOptions = getDefaultOptions;
  SnowEffect.start = start;
  SnowEffect.stop = stop;
  SnowEffect.change = change;
  SnowEffect.set = set;

  var snowOps = { // nXXXX是规范化到[0,10]区间的参数
    nStartSize: 3, // 雪花大小，  默认1,  取值范围1-5.
    nDirection: 0, // 落雪方向： 0：向下， 取值范围： -15度到15度，
    nDensity: 1, // 密度， 默认1（小雨）取值范围：1-10
    dy: 10,
    v0: 200,
    endOpacity: 0.1,
    endSize: -1,
    endSizeVar: 5,
    imageSrc: "http://" + TQ.Config.DOMAIN_NAME + "/mcImages/xuehua1.png"
  };

  var rainOps = {
    nStartSize: 3, // 雨滴大小，  默认1,  取值范围1-5.
    nDirection: 0, // 落雪方向： 0：向下， 取值范围： -15度到15度，
    nDensity: 1, // 密度， 默认1（小雨）取值范围：1-10
    dy: 10,
    v0: 200,
    endOpacity: 0.1,
    endSize: -1,
    endSizeVar: 5,
    imageSrc: "http://" + TQ.Config.DOMAIN_NAME + "/mcImages/yudi3.png"
  };

  var yuanbaoOps = {
    nStartSize: 3,
    nDirection: 0,
    nDensity: 1,
    dy: 10,
    v0: 200,
    endOpacity: 0.1,
    endSize: -1,
    endSizeVar: 5,
    imageSrc: "http://" + TQ.Config.DOMAIN_NAME + "/mcImages/yuanbao1.png"
  };

  var defaultOps = snowOps;
  var para1 = null;
  var emitters = [];
  var created = false;
  var particleImage = null;
  var images = {};

  function initialize() {
    emitters.splice(0);
    created = false;
    particleImage = null;
    images = {};
  }

  function getDefaultOptions(subType) {
    switch (subType) {
      case TQ.FeParticle.MONEY:
        return TQ.Base.Utility.shadowCopy(yuanbaoOps);
      case TQ.FeParticle.RAIN:
        return TQ.Base.Utility.shadowCopy(rainOps);
      case TQ.FeParticle.SNOW:
        return TQ.Base.Utility.shadowCopy(defaultOps);
      default:
        return TQ.Base.Utility.shadowCopy(defaultOps);
    }
  }

  function start(options) {
    change(options);
  }

  function change(options) {
    if (!options) {
      options = defaultOps;
    } else {
      if (options.nStartSize === undefined) {
        options.nStartSize = options.startSize;
      }
      if (options.nDirection === undefined) {
        options.nDirection = options.direction;
      }
      if (options.nDensity === undefined) {
        options.nDensity = options.density;
      }

      if (options.imageSrc === undefined) {
        options.imageSrc = defaultOps.imageSrc;
      }
    }

    set(options);
  }

  function set(option) {
    option.startSize = TQ.MathExt.unifyValue10(parseFloat(option.nStartSize), 10, 20);
    option.direction = TQ.MathExt.unifyValue10(parseFloat(option.nDirection), 90 - 15, 90 + 15);
    option.density = TQ.MathExt.unifyValue10(parseFloat(option.nDensity), 30, 40);
    option.v0 = parseFloat(option.v0);
    para1 = option;
    if (!hasSameAsset()) {
      _loadAsset();
    } else {
      initEmitter(particleImage);
    }
  }

  function resetOne(emitter1, position) {
    emitter1.position = position;
    emitter1.speed = para1.v0; // 粒子的初始速度，
    emitter1.positionVarY = para1.dy;
    emitter1.angle = para1.direction;
    emitter1.endOpacity = para1.endOpacity;
    emitter1.startSize = para1.startSize;
    emitter1.startSizeVar = para1.startSize / 2; // 10;
    emitter1.endSizeVar = para1.endSizeVar;
    emitter1.changeImage(particleImage);
  }

  function _loadAsset() {
    var asset = images[para1.imageSrc];
    if (asset) {
      initEmitter(asset);
    } else {
      asset = new Image();
      asset.onload = function() {
        images[para1.imageSrc] = asset;
        initEmitter(asset);
      };
      asset.src = para1.imageSrc;
    }
  }

  function hasSameAsset() {
    return (particleImage && (particleImage.src === para1.imageSrc));
  }

  // 停止下雨
  function stop() { // 立即停止，消失所有的雨滴
    createjs.ParticleEmitter.stopped = true;
  }

  function initEmitter(asset) {
    particleImage = asset;
    reset(para1);
    created = true;
  }

  function reset(para) {
    var M = para.density; // 雪花的密度，
    var N = 1;
    var k = 0;
    for (var i = 0; i < M; i++) {
      for (var j = 0; j < N; j++) {
        var x = i / M * canvas.width + canvas.width / 10;
        var y = j / N * canvas.height - canvas.height / 10;
        if ((k < emitters.length) && (emitters[k])) {
          resetOne(emitters[k], new createjs.Point(x, y));
        } else {
          para.x = x;
          para.y = y;
          emitters.push(addParticleEmitter(para));
        }
        k++;
      }
    }
    createjs.ParticleEmitter.stopped = false;
  }

  function addParticleEmitter(para) {
    var emitter = new createjs.ParticleEmitter(particleImage);
    emitter.position = new createjs.Point(para.x, para.y);
    emitter.emitterType = createjs.ParticleEmitterType.Emit;
    emitter.emissionRate = 2; // 产生新粒子的速度
    emitter.maxParticles = 2000; // 粒子库的大小
    emitter.life = 9000; // 粒子的寿命长度
    emitter.lifeVar = 500;
    emitter.speed = para.v0; // 粒子的初始速度，
    emitter.speedVar = 20; //
    emitter.positionVarX = 20;
    emitter.positionVarY = para.dy;
    emitter.accelerationX = 0;
    emitter.accelerationY = 0;
    emitter.radialAcceleration = 0;
    emitter.radialAccelerationVar = 0;
    emitter.tangentalAcceleration = 0;
    emitter.tangentalAccelerationVar = 0;
    emitter.angle = para.direction;
    emitter.angleVar = 10;
    emitter.startSpin = 20;
    emitter.startSpinVar = 10;
    emitter.endSpin = null;
    emitter.endSpinVar = null;
    emitter.startColor = [190, 190, 255];
    emitter.startColorVar = [50, 50, 0];
    emitter.startOpacity = 1;
    emitter.endColor = null;
    emitter.endColorVar = null;
    emitter.endOpacity = para.endOpacity;
    emitter.startSize = para.startSize;
    emitter.startSizeVar = para.startSize / 2; // 10;
    emitter.endSize = 0;
    emitter.endSizeVar = para.endSizeVar;
    stageContainer.addChild(emitter);
    return emitter;
  }

  TQ.SnowEffect = SnowEffect;
  TQ.FeParticle = FeParticle;
}());

/**
 * Created by Andrewz on 1/22/2017.
 * 图强动漫引擎,
 * 专利产品 领先技术
 * 粒子系统的增、删、改、查
 *
 * 是singleton
 * ** 全场粒子：同时只有1个实例在active， 但是， 整个作品， 可以有多个粒子实例（先下雨，后下雪）
 * ** 点粒子源：（鞭炮， 礼花），同时可以有多个
 */
TQ = TQ || {};
(function() {
  function ParticleMgr() {
  }

  var items = [];
  var selectedElement = null;
  var counter = 0;
  var fullscreenEffect = TQ.SnowEffect;
  var feRefers = [];
  var children = {};
  var lastOps = null;
  var feReferCount = 0;

  ParticleMgr.change = change;
  ParticleMgr.feStart = feStart;
  ParticleMgr.feStop = feStop;
  ParticleMgr.getOps = getOps;
  ParticleMgr.pause = pause;
  ParticleMgr.removeAll = removeAll;
  ParticleMgr.resume = resume;
  ParticleMgr.initialize = function() {
    fullscreenEffect.initialize(); // 清除emitters;
    counter = 0;
    children = {}; // create a new one, will throw the old into Garbage collection
    feRefers.splice(0);
    feReferCount = 0;
    removeAll();
  };

  function change() {
    var n = feRefers.length;
    if (n > 0) {
      var ele = feRefers[n - 1];
      ele.apply();
    }
  }

  function feStart(ele, paras) {
    feReferCount++;
    var lastFe = feRefers.shift();
    feRefers.push(ele);
    if (feReferCount === 1) {
      fullscreenEffect.start(paras);
    } else {
      if (lastFe) {
        TQ.CommandMgr.directDo(new TQ.HideCommand([lastFe], false)); // 隐藏上一个全屏特效
      }
      setTimeout(function() {
        fullscreenEffect.change(paras);
      });
    }

    selectedElement = ele;
    lastOps = paras;
    TQUtility.triggerEvent(document.body, TQ.EVENT.REFRESH_UI);
    children[ele.jsonObj.subType] = ele;
  }

  function feStop() {
    feReferCount--;
    if (feReferCount < 0) {
      feReferCount = 0;
    }
    if (feReferCount === 0) {
      fullscreenEffect.stop();
      selectedElement = null;
    }
  }

  ParticleMgr.insertMoney = function() {
    var existEle = children[TQ.FeParticle.MONEY];
    if (existEle) {
      existEle.show(true);
      existEle.play();
      selectedElement = existEle;
      return;
    }

    var desc = {
      name: TQ.FeParticle.MONEY + counter,
      src: null,
      type: TQ.ElementType.FULLSCREEN_EFFECT_PARTICLE,
      subType: TQ.FeParticle.MONEY
    };
    TQ.SceneEditor.addItem(desc);
  };

  ParticleMgr.insertRain = function() {
    var existEle = children[TQ.FeParticle.RAIN];
    if (existEle) {
      existEle.show(true);
      existEle.play();
      selectedElement = existEle;
      return;
    }

    var desc = {
      name: TQ.FeParticle.RAIN + counter,
      src: null,
      type: TQ.ElementType.FULLSCREEN_EFFECT_PARTICLE,
      subType: TQ.FeParticle.RAIN
    };

    TQ.SceneEditor.addItem(desc);
  };

  ParticleMgr.insertSnow = function() {
    var existEle = children[TQ.FeParticle.SNOW];
    if (existEle) {
      existEle.show(true);
      existEle.play();
      selectedElement = existEle;
      return;
    }

    // particle 不需要上传本地图片， 所以，不需要通过EditService的addItem,
    // 而是直接调用SceneEditor的
    var desc = {
      name: TQ.FeParticle.SNOW + counter,
      src: null,
      type: TQ.ElementType.FULLSCREEN_EFFECT_PARTICLE,
      subType: TQ.FeParticle.SNOW
    };
    TQ.SceneEditor.addItem(desc);
  };

  ParticleMgr.register = function(ele) {
    if (items.indexOf(ele) >= 0) {
      if (!selectedElement) {
        selectedElement = ele;
      }
      return;
    }
    items.push(ele);
    selectedElement = ele;
  };

  ParticleMgr.unregister = function(ele) {
    var id = items.indexOf(ele);
    if (id >= 0) {
      var temp = items.splice(id, 1);
      if (temp[0] === selectedElement) {
        selectedElement = null;
      }
    }
  };

  ParticleMgr.stop = function(evt) {
    if (evt) {
      evt.preventDefault();
      evt.stopPropagation();
    }
    if (selectedElement) {
      // selectedElement.stop();
      TQ.CommandMgr.directDo(new TQ.HideCommand([selectedElement], false));
      selectedElement = null;
    }
  };

  ParticleMgr.deleteItem = function(evt) {
    if (evt) {
      evt.preventDefault();
      evt.stopPropagation();
    }

    if (selectedElement) {
      var temp = selectedElement;
      selectedElement.stop();
      TQ.CommandMgr.directDo(new TQ.DeleteEleCommand(currScene, temp));
      selectedElement = null;
    }
  };

  function removeAll() {
    selectedElement = null;
    for (var i = items.length - 1; i >= 0; i--) {
      var ele = items[i];
      // if (ele.isCrossLevel) continue;
      ele.stop();
      items.splice(i, 1);
    }
  }

  function pause() {
    createjs.ParticleEmitter.stopped = true;
  }

  function getOps() {
    if (!lastOps) {
      lastOps = TQ.SnowEffect.getDefaultOptions();
    }

    return lastOps;
  }

  function resume() {
    createjs.ParticleEmitter.stopped = false;
  }

  TQ.ParticleMgr = ParticleMgr;
}());

/**
 * Tuqiang Game Engine
 * Copyright Tuqiang Tech
 * Created at : 12-11-13 下午7:16
 */
window.TQ = window.TQ || {};

(function() {
  function DitherRemover() {
  }
  var p = DitherRemover;
  p._LENGTH = 20; // N点加权平均法消除抖动
  p.buffer = [];
  p._on = false;
  p.enabled = false;
  p.start = function(xx, yy) {
    this.buffer.splice(0);
    this.buffer.push({ x: xx, y: yy });
    this._on = true;
    return this.buffer[0];
  };

  p.close = function() {
    this.buffer.splice(0);
    this._on = false;
  };

  // 添加1个新的点, 获取消抖处理后的点
  p.smooth = function(xx, yy) {
    if (this.enabled) {
      if (!this._on) {
        assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
        return this.start(xx, yy);
      }
      if (Window.__user_level === 8) {
        TQ.Log.debugInfo(xx + ", " + yy);
      }
      if (this.buffer.length >= this._LENGTH) {
        this.buffer.shift();
      }
      this.buffer.push({ x: xx, y: yy });
      xx = 0;
      yy = 0;
      var num = this.buffer.length;
      for (var i = 0; i < num; i++) {
        xx += this.buffer[i].x / num;
        yy += this.buffer[i].y / num;
      }
    }
    return { x: xx, y: yy };
  };

  p.isOn = function() { return this._on; };

  TQ.DitherRemover = DitherRemover;
}());

var TQ = TQ || {};
(function() {
  "use strict";
  function TouchManager() {
  }

  var enableTouchScreen = true;
  var initialized = false;
  var started = false;
  var canvas = null;
  var currentOps = null;
  var trsaOps = null;
  var mCopyOps = null;

  function addHandler(gesture, handler) {
    TQ.AssertExt.invalidLogic(!!canvas, "canvas is not initialized!");
    ionic.EventController.onGesture(gesture, handler, canvas);
  }

  function detachHandler(gesture, handler) {
    TQ.AssertExt.invalidLogic(!!canvas, "canvas is not initialized!");
    ionic.EventController.off(gesture, handler, canvas);
  }

  function initialize() {
    trsaOps = [
      ["touch", TQ.Trsa3.onTouchStart],
      ["mousedown", TQ.Trsa3.onMouseDown],

      ["touchend", TQ.Trsa3.onTouchEnd],
      ["mouseup", TQ.Trsa3.onMouseUp],

      ["release", TQ.Trsa3.onRelease],
      ["rotate", TQ.Trsa3.onPinchAndRotate],
      ["pinch", TQ.Trsa3.onPinchAndRotate],
      // 'scale': not work
      //
      // ['pinchin', onPinch],
      // ['pinchout', onPinch],
      ["drag", TQ.Trsa3.onDrag],
      ["touchmove", notHandled]
      // 其余事件： 'swipeup'.
    ];

    mCopyOps = [
      ["touch", TQ.Trsa3.mCopy]
    ];

    canvas = TQ.Graphics.getCanvas();
    if (!enableTouchScreen) {
      return;
    }
    disableBodyScrollInIOS();
    disableBrowserZooming();
    initialized = true;
    start();
  }

  function start() {
    if (started) {
      TQ.AssertExt.invalidLogic(true, "重复启动touchManager！");
      TQ.Trsa3.reset();
      updateOps({ isMCopying: false });
      return;
    }
    started = true;
    if (currentOps) {
      detachOps(currentOps);
    }
    currentOps = trsaOps;
    attachOps(currentOps);
    TQ.Assert.isTrue(!!TQ.SceneEditor.stage, "Stage 没有初始化！");
    TQ.SceneEditor.stage.addEventListener("touch", TQ.Trsa3.onTouchStage);
  }

  function updateOps(state) {
    if (currentOps) {
      detachOps(currentOps);
      currentOps = null;
    }
    if (state.isMCopying) {
      attachOps(mCopyOps);
    } else {
      attachOps(trsaOps);
    }
  }

  function attachOps(ops, newCanvas) {
    if (currentOps) {
      detachOps(currentOps);
      currentOps = null;
    }
    if (newCanvas) {
      canvas = newCanvas;
    }
    if (ops) {
      ops.forEach(function(item) {
        addHandler(item[0], item[1]);
      });
      currentOps = ops;
    }
  }

  function detachOps(ops) {
    if (ops) {
      ops.forEach(function(item) {
        detachHandler(item[0], item[1]);
      });
    }
  }

  var savedState;
  function save() {
    savedState = { ops: currentOps, canvas: canvas };
  }

  function restore() {
    canvas = savedState.canvas;
    if (currentOps) {
      detachOps(currentOps);
    }
    attachOps(savedState.ops);
    savedState = null;
  }

  function stop() {
    if (!started) {
      TQ.AssertExt.invalidLogic(true, "重复关闭touchManager！");
      return;
    }

    started = false;
    if (currentOps) {
      detachOps(currentOps);
    }

    TQ.Assert.isTrue(!!TQ.SceneEditor.stage, "Stage 没有初始化！");
    TQ.SceneEditor.stage.removeEventListener("touch", TQ.Trsa3.onTouchStage);
  }

  function isFirstTouch(e) {
    return (!started); // && !isMultiTouching);
  }

  function disableBrowserZooming() {
    document.addEventListener("mousewheel", function(e) {
      // TQ.Log.debugInfo(e.type, e.deltaX, e.deltaY, e.wheelDeltaX, e.wheelDeltaY);
      e.preventDefault();
    });
  }

  function disableBodyScrollInIOS() {
    // IOS's page body are scrolling when user touch moving
    document.ontouchstart = disableScroll;
    document.ontouchmove = disableScroll;

    document.addEventListener("touchmove", disableScroll, true);
    document.addEventListener("touchstart", disableScroll, true);

    function disableScroll(e) {
      // TQ.Log.debugInfo(e.type, e.target.tagName, e.srcElement.tagName, e.currentTarget ? e.currentTarget.tagName: 'None',
      //     e.target.nodeName, e.srcElement.nodeName, e.currentTarget ? e.currentTarget.nodeName: 'None');
      var whiteList = ["BUTTON", "INPUT", "TEXTAREA"];
      var tag = "";
      if (e.target && e.target.nodeName) {
        tag = e.target.nodeName.toUpperCase();
      }

      if (whiteList.indexOf(tag) < 0) {
        e.preventDefault();
      }
    }
  }

  function notHandled(e) {
    TQ.Log.debugInfo("event not handled: " + e.type + ", " + (e.touches ? e.touches.length : 0));
  }

  function hasStarted() {
    return started;
  }

  function hasInitialized() {
    return initialized;
  }

  TouchManager.save = save;
  TouchManager.restore = restore;
  TouchManager.addHandler = addHandler;
  TouchManager.attachHandler = addHandler;
  TouchManager.detachHandler = detachHandler;
  TouchManager.initialize = initialize;
  TouchManager.hasStarted = hasStarted;
  TouchManager.hasInitialized = hasInitialized;
  TouchManager.start = start;
  TouchManager.stop = stop;
  TouchManager.attachOps = attachOps;
  TouchManager.updateOps = updateOps;
  TQ.TouchManager = TouchManager;
})();

/**
 * 图强动漫引擎, 专利产品, 大众动画
 */

var TQ = TQ || {};
TQ.TimerUI = (function() {
  var MIN_DURATION = 0; // 10 frames, ==> 0.5s
  var isUserControlling = false;
  var isSagPanel = false;
  var initialized = false;
  var previousSync = null;
  var tPool = [];
  var tPoolMaxLength = 5;
  var unitSeries = [0.05, 0.1, 0.5, 1, 2, 5, 10, 20, 50, 100, 500, 1000, 5000]; // * 20 frame per second
  var rangeSlider = {
    minValue: 0,
    maxValue: 0,
    options: {
      floor: 0,
      ceil: 100,
      step: 1,
      showTicks: true,
      ticksArray: [10, 20, 30],
      minRange: MIN_DURATION,
      // maxRange: MIN_DURATION,
      pushRange: true,
      translate: onTranslate,
      onStart: onMouseStart,
      onEnd: onMouseStop,
      onChange: onMouseAction // onChange,
    }
  };

  return {
    getTObject1: getTObject1,
    getTObject2: getTObject2,
    onTrimCompleted: onTrimCompleted,
    rangeSlider: rangeSlider,
    startSagPanel: startSagPanel,
    stopSagPanel: stopSagPanel,
    initialize: initialize,
    setGlobalTime: setGlobalTime
  };

  function initialize() {
    if (initialized) {
      setTimeout(onRangeChanged, 100);
      return;
    }

    for (var i = 0; i < unitSeries.length; i++) {
      unitSeries[i] *= TQ.FrameCounter.defaultFPS;
    }

    initialized = true;
    rangeSlider.minValue = TQ.FrameCounter.t2f(TQ.Scene.localT2Global(TQ.FrameCounter.t()));
    rangeSlider.options.floor = 0;
    rangeSlider.options.ceil = Math.ceil(TQ.FrameCounter.t2f(TQ.Scene.getTMax()));
    updateTicksArray();
    TQ.FrameCounter.addHook(update);
    // 迫使系统render slider
    document.addEventListener(TQ.EVENT.SCENE_TIME_RANGE_CHANGED, onRangeChanged, false);
    onRangeChanged();
  }

  function onMouseStart() {
    isUserControlling = true;
  }

  function onMouseStop(sliderId, modelValue, highValue, pointerType) {
    if (TQ.State.showTrimTimeline) {
      syncToCounter(highValue);
    } else {
      syncToCounter(modelValue);
    }
    isUserControlling = false;
  }

  /** 消除抖动和快速移动中的中间过渡：
     *   200ms, 消除中间位置；
     *   在同一个位置停留1000ms，则sync到此位置
     */
  function syncToCounter(v) {
    var t = TQ.FrameCounter.f2t(v);
    TQBase.LevelState.saveOperation(TQBase.LevelState.OP_TIMER_UI);
    if (previousSync == null) {
      tPool.splice(0);
    } else {
      clearTimeout(previousSync);
      previousSync = null;
    }

    while (tPool.length >= tPoolMaxLength) {
      tPool.shift();
    }

    tPool.push(t);
    var status = calculateStatus();
    t = status.tAverage;

    if (status.hasStayOver1s) {
      tPool.splice(0);
      previousSync = null;
      doSync();
    } else {
      previousSync = setTimeout(doSync, 200);
    }

    function doSync() {
      var tObj = TQ.Scene.globalT2local(t);
      TQ.FrameCounter.cmdGotoFrame(TQ.FrameCounter.t2f(tObj.t));
      TQ.DirtyFlag.requestToUpdateAll();
      previousSync = null;
    }

    function calculateStatus() {
      var sum = 0;
      var diff = 0;
      var maxDiff = 0;
      var base = tPool[tPool.length - 1];
      for (let i = 0; i < tPool.length; i++) {
        sum += tPool[i];
        diff = Math.abs(tPool[i] - base);
        if (diff > maxDiff) {
          maxDiff = diff;
        }
      }
      var totalLength = TQ.Scene.getTMax();
      return {
        tAverage: sum / tPool.length,
        hasStayOver1s: ((tPool.length >= tPoolMaxLength) && (maxDiff < totalLength * 0.05))
      };
    }
  }

  function setGlobalTime(globalT) {
    var globalV = TQ.FrameCounter.t2f(globalT);
    syncToCounter(globalV);
    update(true);
  }

  function onMouseAction(sliderId, modelValue, highValue, pointerType) {
    // TQ.Log.debugInfo("Mouse Action: t10 = " + t10);
    if (TQ.State.showTrimTimeline) {
      syncToCounter(highValue);
    } else {
      syncToCounter(modelValue);
    }
    // ToDo: 移动时间轴的位置, 修改帧频率, 增加刻度的显示, 增加缩放
  }

  function update(forceToUpdate) {
    if (forceToUpdate || !(isUserControlling || isSagPanel)) {
      if (forceToUpdate || TQ.FrameCounter.isNew) {
        rangeSlider.minValue = TQ.FrameCounter.t2f(TQ.Scene.localT2Global(TQ.FrameCounter.t()));
      }
    }
  }

  function startSagPanel() {
    isSagPanel = true;
  }

  function stopSagPanel() {
    isSagPanel = false;
  }

  function onRangeChanged() {
    rangeSlider.minValue = TQ.FrameCounter.t2f(TQ.Scene.localT2Global(TQ.FrameCounter.t()));
    rangeSlider.options.floor = 0;
    rangeSlider.options.ceil = Math.ceil(TQ.FrameCounter.t2f(TQ.Scene.getTMax()));
    updateTicksArray();

    var editorService = angular.element(document.body).injector().get("EditorService");
    if (editorService && editorService.forceToRenderSlider) {
      editorService.forceToRenderSlider();
    }

    update(true);
  }

  function onTrimCompleted() {
    rangeSlider.maxValue = rangeSlider.minValue;
    setGlobalTime(TQ.FrameCounter.f2t(rangeSlider.minValue));
  }

  function getTObject1() {
    return TQ.Scene.globalT2local(TQ.FrameCounter.f2t(rangeSlider.minValue), true);
  }

  function getTObject2() {
    return TQ.Scene.globalT2local(TQ.FrameCounter.f2t(rangeSlider.maxValue), true);
  }

  function onTranslate(value, id, which) {
    // TQ.Log.debugInfo(value + ',' + id + ',' + which);
    var t,
      result;
    t = TQ.FrameCounter.f2t(value);
    if ((which === "model") || (which === "high")) {
      result = t.toFixed(1);
    } else {
      if (which === "floor") {
        result = t.toFixed(0) + "";
      } else if (which === "ceil") {
        result = t.toFixed(0) + "s";
      }
    }
    return result;
  }

  function updateTicksArray() {
    if (rangeSlider.options.ceil <= 1) {
      return;
    }

    var totalLength = rangeSlider.options.ceil;
    var minUnit = totalLength / 20;
    var maxUnit = totalLength / 5;
    var ideaUnit = 1;
    var ticks = [];
    unitSeries.some(function(unit) {
      ideaUnit = unit;
      return ((minUnit <= unit) && (unit <= maxUnit));
    });

    for (var v = ideaUnit; v < totalLength; v += ideaUnit) {
      ticks.push(v);
    }

    if (ticks.length < 1) {
      return;
    }

    var oldTicksArray = rangeSlider.options.ticksArray;
    if ((oldTicksArray.length < 1) ||
            (oldTicksArray.length !== ticks.length) ||
            (oldTicksArray[oldTicksArray.length - 1] !== ticks[ticks.length - 1])) {
      rangeSlider.options.ticksArray = ticks;
    }
  }
}());

/**
 * Created by Andrewz on 1/26/2017.
 */
var TQ = TQ || {};
(function() {
  "use strict";
  function PreviewMenu() {
  }

  PreviewMenu.hide = onPreviewMenuOff;
  PreviewMenu.initialize = initialize;
  PreviewMenu.startWatch = startWatch;
  PreviewMenu.stopWatch = stopWatch;
  PreviewMenu.disableWatch = disableWatch;
  PreviewMenu.enableWatch = enableWatch;
  function enableWatch() {
    allowToWatch = true;
  }

  function disableWatch() {
    allowToWatch = false;
  }

  var selectedEvents = ["touchstart", "click"];
  var state = null;
  var previewMenuOnCallback = null;
  var previewMenuOffCallback = null;
  var hasTouch = false;
  var hasMouse = false;
  var isWatching = false;
  var allowToWatch = true;

  function initialize(globalState, onCallback, offCallback) {
    if (!state) {
      state = TQ.State;
    }
    if (TQ.QueryParams.hideMenu) {
      return;
    }
    previewMenuOnCallback = onCallback;
    previewMenuOffCallback = offCallback;
  }

  function onPreviewMenuOn(e) {
    if (TQ.QueryParams.hideMenu || !isSelectedEvent(e)) {
      return;
    }
    if (!state) {
      state = TQ.State;
    }

    if (state.isPreviewMode && e && (selectedEvents.indexOf(e.type) >= 0)) {
      stopWatch();
      state.isPreviewMenuOn = true;
      if (previewMenuOnCallback) {
        previewMenuOnCallback();
      }
    }
  }

  function onPreviewMenuOff(e) {
    if (e && !isSelectedEvent(e)) {
      return;
    }

    if (!state) {
      state = TQ.State;
    }
    state.isPreviewMenuOn = false;
    if (previewMenuOffCallback) {
      previewMenuOffCallback();
    }
  }

  function startWatch() {
    if (TQ.QueryParams.hideMenu || isWatching || !allowToWatch) {
      return;
    }
    isWatching = true;
    TQ.Log.checkPoint("start watch in preview Menu...");
    setTimeout(function() { // 避免延后一点， 避免被preview按钮的操作触发
      if (isWatching && allowToWatch) { // 防止刚start，就stop， （在App刚刚启动的时候）
        selectedEvents.forEach(function(item) {
          document.addEventListener(item, onPreviewMenuOn);
        });
      }
    }, 100);
  }

  function stopWatch() {
    if (TQ.QueryParams.hideMenu || !isWatching || !allowToWatch) {
      return;
    }
    isWatching = false;
    TQ.Log.debugInfo("stop watch!");
    selectedEvents.forEach(function(item) {
      document.removeEventListener(item, onPreviewMenuOn);
    });
  }

  function isSelectedEvent(e) {
    return (e && (selectedEvents.indexOf(e.type) >= 0));
  }

  TQ.PreviewMenu = PreviewMenu;
})();

/**
 * Created by Andrewz on 5/11/19.
 */
angular.module("starter").factory("StorageManager", StorageManager);
StorageManager.$inject = ["$q", "$timeout", "$http", "NetService"];

function StorageManager($q, $timeout, $http, NetService) {
  var cachedQueue = [];
  var isUploading = false;
  var onReadyForCloseCallback = null;

  function isReadyForClose() {
    return !(isUploading || cachedQueue.length > 0);
  }

  function onReadyForClose(callback) {
    if (isReadyForClose()) {
      callback();
    } else {
      onReadyForCloseCallback = callback;
    }
  }

  function saveAll(opusJson, screenshot, onSuccess) {
    cachedQueue.push({ wcyId: TQ.Scene.getWcyId(),
      localId: TQ.Scene.getLocalId(),
      ssSign: TQ.Scene.getSsSign(),
      opusJson: opusJson,
      screenshot: screenshot,
      onSuccess: onSuccess });

    setTimeout(function() {
      startUpload();
    });
  }

  function saveOpus(opusJson, options, onSuccess, onError) {
    cachedQueue.push({ wcyId: TQ.Scene.getWcyId(),
      localId: TQ.Scene.getLocalId(),
      opusJson: opusJson,
      options: options,
      onSuccess: onSuccess,
      onError: onError });

    setTimeout(function() {
      startUpload();
    });
  }

  function saveScreenshot(screenshot, onSuccess, onError) {
    cachedQueue.push({ wcyId: TQ.Scene.getWcyId(),
      localId: TQ.Scene.getLocalId(),
      ssSign: TQ.Scene.getSsSign(),
      screenshot: screenshot,
      onSuccess: onSuccess,
      onError: onError });

    setTimeout(function() {
      startUpload();
    });
  }

  function startUpload() {
    if (cachedQueue.length <= 0) {
      return;
    }
    var onePackage = cachedQueue.pop();
    if (onePackage) {
      isUploading = true;
      if (!onePackage.opusJson) {
        console.log("screenshot only");
      }
      console.log("upload " + onePackage.wcyId + ", " + onePackage.length);

      /*
      // if no wcyId , apply wcyId, shared = true
      // if screenshot, upload screenshot
      // update currScene： ssPath,
      save record,  shared = true
       */

      if (!onePackage.ssSign) {
        uploadOpus(onePackage.wcyId, onePackage.opusJson, onePackage.options).then(
          function(httpResult) {
            httpResult.localIdCached = onePackage.localId;
            TQ.Scene.parseOpusSaveResult(httpResult.data);
            if (onePackage.onSuccess) {
              onePackage.onSuccess(httpResult);
              if (!onePackage.ssSign) {
                onePackage.ssSign = TQ.Scene.getSsSign();
              }
              if (!TQ.Utility.isValidWcyId(onePackage.wcyId)) {
                onePackage.wcyId = TQ.Scene.getWcyId();
              }

              if (onePackage.screenshot) {
                uploadWithSsign();
              } else {
                onUploadCompleted(httpResult);
              }
            }
          }
        ).then(function(value) {
          console.log("saved successfully!");
        }, _onNetIOError);
      } else {
        uploadWithSsign();
      }

      function uploadWithSsign() {
        if (onePackage.screenshot) {
          uploadScreenshot(onePackage.ssSign, onePackage.screenshot)
            .then(doSaveOpus, _onNetIOError)
            .catch(_onNetIOError);
        } else {
          doSaveOpus();
        }
      }

      function doSaveOpus(value) {
        if (onePackage.opusJson) {
          console.log(value);
          TQ.Scene.updateSSPath(onePackage, currScene.ssPath);
          uploadOpus(onePackage.wcyId, onePackage.opusJson, onePackage.options)
            .then(onUploadCompleted, _onNetIOError);
        } else {
          onUploadCompleted({});
        }
      }

      function onUploadCompleted(httpResult) {
        httpResult.localIdCached = onePackage.localId;
        isUploading = false;
        if (onePackage.onSuccess) {
          onePackage.onSuccess(httpResult);
        }
        if (isReadyForClose() && onReadyForCloseCallback) {
          onReadyForCloseCallback(httpResult);
        }
      }
    }
  }
  function uploadOpus(_wcyId, jsonWcyData, options) {
    if (!TQ.Utility.isValidWcyId(_wcyId)) {
      _wcyId = 0;
    }

    var params = "?wcyId=" + _wcyId;
    var forkIt = (!!options && !!options.forkIt);

    return $http({
      method: "POST",
      url: TQ.Config.OPUS_HOST + "/wcy" + params + (forkIt ? "&fork=true" : ""),
      headers: {
        "Content-Type": "application/json"
      },
      data: jsonWcyData
    });
  }

  function uploadScreenshot(ssSign, screenshot) {
    TQ.AssertExt.invalidLogic(!!ssSign);
    TQ.AssertExt.invalidLogic(!!screenshot);
    if (!ssSign) {
      throw new Error("internal error: no ssSign");
    }

    return NetService.doUploadImage(ssSign, screenshot).then(onUploadSsSuccess);
  }

  function onUploadSsSuccess(res) {
    var data = (!res) ? null : res.data;
    if (data) {
      if (data.url) {
        currScene.setSsPath(data.url);
        // TQ.MessageBox.toast(TQ.Locale.getStr('screenshot uploaded successfully!'));
        // save();
      }

      TQ.Log.debugInfo(data);
    }
  }

  function _onNetIOError(data) {
    TQ.Log.debugInfo(data);
    TQ.MessageBox.confirm(TQ.Locale.getStr("hey, the network connection lost"));
  }

  return {
    HTTP_RES_STATUS_OK: "OK",
    isReadyForClose: isReadyForClose,
    onReadyForClose: onReadyForClose,
    saveAll: saveAll,
    saveOpus: saveOpus,
    saveScreenshot: saveScreenshot
  };
}

/*
区别：
  WCY： 提供作品级别的服务
  EditorService： 综合提供元素级别的服务， 并且调用WCY中的服务

WCY 服务： 提供wcy及其screenshot的创建、保存、编辑、展示等服务；
  * 首次保存的时候， 也保存一份截图（当前画面的）
  * 再次保存的时候， 不再自动保存截图，
  * 可以单独保存截图（更新， 会替换旧的）
  * ToDo：想法删除旧的截图， 节省空间， 确保它没有被分享出去， 在替换的时候， 放到待删除库
  * 保存截图的时候， 必须同时再更新WCY（确保其中的ssPath是最新的）。

   ? 统一管理在下面三个地方的存取：app本地文件， LocalStorage和远程服务器
   提供WCY的自动保存服务
   LocalStorage由于空间有限， 只提供当前文件的自动存储。
   app本地文件， 可以离线存储多个作品
   暂时，只有当在线的情况下， 点击“保存”，才上传到远程服务器。
   (ToDO：会自动找到未上传的WCY， 从app本地文件读取其数据和截屏， 上传到服务器)

   => start
   => createScene
   => edit
   => show
*/
angular.module("starter").factory("WCY", WCY);
WCY.$inject = ["$q", "$timeout", "$http", "FileService", "WxService", "NetService", "StorageManager"];

function WCY($q, $timeout, $http, FileService, WxService, NetService, StorageManager) {
  // 类的私有变量， 全部用_开头， 以区别于函数的局部变量
  var user = TQ.userProfile;
  var _AUTO_SAVE_NAME = "_auto_save_name_";
  var isSaving = false;
  var _FILENAME = "_filename_";
  var _SHARE_CODE_ = "_shareCode";
  var _WCY_ID_ = "_wcy_id";
  var readCache = TQ.Base.Utility.readCache;
  var writeCache = TQ.Base.Utility.writeCache;
  var _wcyId = TQ.Config.INVALID_WCY_ID; // 缺省-1， 表示没有保存的作品。，12345678;
  var _onStarted = null;
  var levelThumbs = [];
  var preloadedWcyData = null;
  var getWcyCalled = false;

  TQ.isPreloadingWcy = false; // 因为要在index.html中使用， 不能归入TQ.State中
  TQ.State.shareCode = null;

  function isSafe() {
    return TQ.StageBuffer.isEmpty();
  }

  function needToStop() {
    return (currScene && !!currScene.levels);
  }

  function create(option) {
    if (TQ.userProfile.loggedIn && needToSave()) {
      return save().then(function() {
        create(option); // 数据已经保存，到内存， 网络上传还需要时间
      }, _onFail);
    }

    if (needToStop()) {
      stop();
    }

    if (!option) {
      option = {};
    }
    setAsNew();
    levelThumbs.splice(0);
    TQ.SceneEditor.createScene(option);
    doStarted();
  }

  function setAsNew() {
    _wcyId = TQ.Config.INVALID_WCY_ID; // 能够从新分配一个作品ID
    TQ.State.shareCode = null;
    writeCache(_SHARE_CODE_, TQ.State.shareCode);
    writeCache(_WCY_ID_, _wcyId);
    if (currScene) {
      currScene.resetMoment();
      currScene.isShared = false;
      currScene.setFilenameById(TQ.Config.UNNAMED_SCENE_ID);
      writeCache(_FILENAME, currScene.filename);
    }
    TQ.State.isPlayOnly = false;
    TQ.State.isTopicIntro = false;
  }

  function stop() {
    TQ.TouchManager.stop(); // 防止之前被打开
    stopAutoSave();
  }

  function saveOpusAndScreenshot(onSuccess) {
    TQ.ScreenShot.getForPostAsync(saveToStorage);

    function saveToStorage(screenshot) {
      if (TQ.ResourceSync.isBusy()) {
        return TQ.ResourceSync.once("complete", function() {
          saveToStorage(screenshot);
        });
      }
      var opusJson = currScene.getData();
      StorageManager.saveAll(opusJson, screenshot, onSuccess);
    }
  }

  function save(forkIt) {
    if (!TQ.userProfile.loggedIn) {
      return TQ.MessageBox.prompt("Login in first!");
    }
    if (TQ.Config.LocalCacheEnabled) {
      saveToCache();
    }

    if (currScene.isIComponent() && !currScene.isValidIComponent()) {
      return TQ.MessageBox.prompt("智能元件需要满足以下条件：一个场景:" + currScene.levelNum() +
        ", 一个根元素: " + currScene.levels[0].elements.length);
    }

    TQ.Assert.isDefined(_wcyId);
    _wcyId = (_wcyId === -1) ? 0 : _wcyId;
    TQ.Assert.isTrue(_wcyId >= 0);

    function saveToStorage() {
      var jsonWcyData = currScene.getData();
      StorageManager.saveOpus(jsonWcyData, { forkIt: forkIt }, onSavedSuccess);
    }

    if (TQ.ResourceSync.isBusy()) {
      TQ.ResourceSync.once("complete", saveToStorage);
    } else {
      saveToStorage();
    }
  }

  function createHtmlPage(screenshotUrl) {
    var shareData = {
      ssPath: screenshotUrl,
      title: currScene.title,
      description: currScene.description
    };

    return $http({
      method: "POST",
      url: TQ.Config.OPUS_HOST + "/wcy/" + TQ.State.shareCode,
      data: shareData
    });
  }

  function saveToCache() {
    TQ.Assert.isObject(currScene);
    var data = currScene.getData();
    data = new Blob([data], { type: "text/plain" });
    var fileName = TQ.Config.WORKS_CORE_PATH + "nn.wcy";
    FileService.saveFile(fileName, data,
      function onSuccess(e) {
        TQ.Log.info(fileName + " saved");
        currScene.isSaved = true;
      },
      function onError(e) {
        TQ.Log.error("出错：无法保存文件: " + fileName + JSON.stringify(e));
      });
  }

  function _getWcy(shareString) {
    if (TQ.userProfile.loggedIn && needToSave()) {
      return save().then(function() {
        _getWcy(shareString);
      });
    }

    if (needToStop()) {
      stop();
    }

    levelThumbs.splice(0);
    // TQ.MessageBox.showWaiting(TQ.Locale.getStr('is loading...'));
    if (!preloadedWcyData && !TQ.isPreloadingWcy) {
      doGetOpusFromServer(shareString).then(_onReceivedWcyData, _onFail);
    } else if (preloadedWcyData) {
      _onReceivedWcyData(preloadedWcyData);
      preloadedWcyData = null;
    } else {
      getWcyCalled = true;
    }
  }

  function preloadWcy() {
    var shareString = TQ.Utility.getShareCodeFromUrl();
    if (!shareString || shareString === "") {
      return;
    }

    TQ.isPreloadingWcy = true;
    doGetOpusFromServer(shareString)
      .then(function(res) {
        TQ.isPreloadingWcy = false;
        if (getWcyCalled) {
          _onReceivedWcyData(res);
        } else {
          preloadedWcyData = res;
        }
      }, _onFail);
  }

  function getWcyById(wcyId) { // 通过作品栏目调入到编辑器中
    return getWcy(TQ.Utility.wcyId2ShareCode(wcyId), false);
  }

  function getWcy(shareString) {
    // /任何修改，必须确保5种打开方式都OK:
    // ** url
    // ** latest opus
    // ** my opus pane
    // ** topic
    // ** new

    if (currScene) {
      currScene.close();
      currScene.reset();
    }

    TQ.State.isTopicIntro = false;
    TQ.State.shareCode = TQ.QueryParams.shareCode = shareString;
    _getWcy(shareString);
  }

  function getTopicIntro(topic) {
    TQ.State.topic = topic;
    TQ.State.isTopicIntro = true;
    TQ.State.isPlayOnly = true;
    return _getWcy(TQ.Utility.wcyId2ShareCode(topic.introId), false);
  }

  function getShareCode() {
    return TQ.State.shareCode;
  }

  function getScreenshotUrl() {
    return (!currScene.ssPath) ? null : TQ.RM.toFullPathFs(currScene.ssPath);
  }

  function hasSsPath() {
    return !!currScene.ssPath;
  }

  function uploadScreenshot(newScreenshot, onSuccess, onFail) {
    if (newScreenshot) {
      StorageManager.saveScreenshot(newScreenshot, onSuccess, onFail);
    } else {
      TQ.ScreenShot.getForPostAsync(uploadScreenshot);
    }
  }

  // ToDo： 在Server端实现, 记录播放的次数，(client端是不可靠的， 可能被黑客的）
  function edit(sceneId) {
    TQ.WCY.isPlayOnly = false;
    return _load(sceneId);
  }

  function forkIt() {
    currScene.isPlayOnly = false;
    TQ.WCY.isPlayOnly = false;
    setAsNew();
    return save(true); // 要求fork 当前作品 //服务器不处理
  }

  function cloneIt() { // clone 是fork自己
    setAsNew();
    save(true); // 要求fork 当前作品 //服务器不处理
  }

  function show(sceneId) {
    TQ.WCY.isPlayOnly = true;
    return _load(sceneId);
  }

  function start() {
    if (TQ.userProfile.loggedIn && needToSave()) {
      return save().then(function() {
        start();
      });
    }

    var previousSaved = TQ.Config.ignoreCachedFile ? null : readCache(_AUTO_SAVE_NAME, null);
    if (previousSaved) {
      TQ.State.shareCode = readCache(_SHARE_CODE_, null);
      _wcyId = readCache(_WCY_ID_, TQ.Config.INVALID_WCY_ID);
      if (TQ.State.shareCode && ((!_wcyId) || (_wcyId < 1))) {
        _wcyId = TQ.Utility.shareCode2Id(TQ.State.shareCode);
      }
      var filename = readCache(_FILENAME, TQ.Config.UNNAMED_SCENE);
      var fileInfo = { name: filename, content: previousSaved };
      _open(fileInfo);
    } else {
      TQ.WCY.isPlayOnly = false; // 新创作的， 当然是可以修改的
      create();
    }
  }

  // private function:
  function _load(sceneId) {
    var filename = "p14959.wdm"; // straw berry
    var content = null;

    if (sceneId) {
      filename = "p" + sceneId + ".wdm";
    }

    var url = TQ.Config.BONE_HOST + "/wcy/wdmOpen?filename=" + filename;
    if (!content) {
      $http.get(url, {})
        .success(function(data, status, headers, config) {
          TQ.Log.debugInfo(data);
          content = JSON.stringify(data);
          _openInJson(data);
        }).error(function(data, status, headers, config) {
          TQ.Log.debugInfo(data);
        });
    } else {
      var fileInfo = { name: filename, content: content };
      _open(fileInfo);
    }
  }

  function _open(fileinfo) {
    // ToDo:@UI  initCreateEnvironment(TQ.WCY.isPlayOnly);
    TQ.SceneEditor.openScene(fileinfo);
    doStarted();
  }

  function doStarted() {
    // initToolbar();
    TQ.FloatToolbar.initialize();
    // TQ.FloatToolbar.isVisible();
    if (_onStarted) {
      _onStarted();
    }
  }

  function _autoSave() {
    if (TQ.State.isInBkg || isSaving || _autoSaveStopped || currScene.hasSavedToCache ||
      !needToSave() || !currScene.ssPath || // 只有生成（提交）过1次之后，才允许自动保存，以避免产生太多的草稿和空白截屏
      !isSafe()) {
    } else {
      TQ.Assert.isObject(currScene);
      var data = currScene.getData();
      writeCache(_AUTO_SAVE_NAME, data);
      writeCache(_FILENAME, currScene.filename);
      currScene.hasSavedToCache = true;
      updateWxShareData();
      if (TQ.userProfile.loggedIn && isNewOpus()) {
        save();
      }
      updateThumbnail(levelThumbs, currScene.currentLevelId);
    }

    return $timeout(_autoSave, 30000); // 30s
  }

  function updateThumbnail(levelThumbs, levelId) {
    if (currScene.hasStaleThumbnail || !levelThumbs[levelId] || !levelThumbs[levelId].src) {
      TQ.ScreenShot.saveThumbnail(levelThumbs, levelId);
      currScene.hasStaleThumbnail = false;
      $timeout(null);
    }
  }

  var _autoSaveInitialized = false;
  var _autoSaveStopped = true;
  var _autoSavingTimeout;

  function startAutoSave() {
    if (_autoSaveInitialized) {
      stopAutoSave();
    }

    if (!TQ.Config.AutoSaveEnabled) {
      return;
    }

    _autoSaveInitialized = true;
    _autoSaveStopped = false;
    _autoSavingTimeout = _autoSave();
  }

  function stopAutoSave() {
    if (_autoSavingTimeout) {
      _autoSaveStopped = true;
      clearTimeout(_autoSavingTimeout);
      _autoSavingTimeout = null;
    }
  }

  function onSavedSuccess(res) {
    var data = (!res) ? null : res.data;
    if (!TQ.Scene.isSameOpus(res.localIdCached)) {
      return;
    }

    currScene.isSaved = true;
    if (data) {
      parseCommonData(data);
      TQUtility.triggerEvent(document, TQ.EVENT.MAT_CHANGED, { matType: TQ.MatType.OPUS });
      TQUtility.triggerEvent(document.body, TQ.Scene.EVENT_SAVED);
      TQ.Log.debugInfo(data);
    }

    if (!res) {
      TQ.Log.error("为什么为null？  在save的时候？");
    }
  }

  function parseCommonData(data) { // the common data in both save and get
    TQ.Scene.parseOpusSaveResult(data);
    if (!!data && !!data.wcyId) {
      _wcyId = parseInt(data.wcyId);
    } else {
      _wcyId = TQ.Config.UNNAMED_SCENE_ID;
    }

    writeCache(_SHARE_CODE_, TQ.State.shareCode);
    writeCache(_WCY_ID_, _wcyId);
  }

  function onUrlChanged() {
    updateWxShareData();
  }

  function updateWxShareData() { // 在页面url更新之后， 才能初始化微信分享
    if (TQ.Config.hasWx && TQ.State.shareCode && (_wcyId > 0)) { //  更新微信的shareCode， 以供用户随时分享。
      WxService.init(composeWxShareData(currScene, TQ.State.shareCode));
    }
  }

  function composeWxShareData(scene, shareCode) {
    var defaultShareForKids = {
      "title": "儿童创造能力提升",
      "description": "儿童创造能力提升--UDOIDO KIDZ"
    };

    TQ.Assert(_wcyId > 0, "必须先保存，才能调用");
    return {
      title: defaultShareForKids.title, // (scene.title) ? scene.title : "UdoIdo",
      ssPath: (scene.ssPath) ? TQ.RM.toFullPathFs(scene.ssPath) : null,
      desc: defaultShareForKids.description, // (scene.description) ? scene.description: null,
      code: (shareCode) || TQ.Utility.wcyId2ShareCode(_wcyId)
    };
  }

  function _onFail(data) {
    TQ.Log.debugInfo(data);
    TQ.MessageBox.prompt(TQ.Locale.getStr("hey, the network connection lost"));
  }

  function doGetOpusFromServer(shareString) {
    if (!shareString) {
      return;
    }

    var url = TQ.Config.OPUS_HOST + "/wcy/" + TQ.Utility.getShareCodeCore(shareString);
    return $http.get(url);
  }

  function getOutro(outroId) {
    return doGetOpusFromServer(TQ.Utility.wcyId2ShareCode(outroId))
      .then(_onReceivedOutroData, _onReceivedOutroData);
  }

  function _onReceivedWcyData(res) {
    TQ.MessageBox.reset(); // end of loading，no resource yet
    var data = res.data;
    parseCommonData(data);
    TQ.State.isPlayOnly = (TQ.State.isTopicIntro ? true : data.isPlayOnly);
    TQ.State.determineWorkingRegion();
    TQ.WCY.authorId = data.authorId;
    if (data.data) {
      _openInJson(TQ.Scene.decompress(data.data));
    }
  }

  function _onReceivedOutroData(res) {
    var outroData = (!res || !res.data || !res.data.data) ? null : res.data.data;
    if (outroData) {
      outroData = TQ.Scene.decompress(outroData);
      // upgrade
      outroData = JSON.parse(outroData);
      currScene.attachOutro(outroData);
    }
  }

  function _openInJson(content) {
    var filename = _findFileName(content);
    var fileInfo = { name: filename, content: content };
    fileInfo.isPlayOnly = TQ.WCY.isPlayOnly;
    _open(fileInfo);
  }

  function _findFileName(data) {
    var content = JSON.parse(data);
    if (content.filename && content.filename !== TQ.Config.UNNAMED_SCENE_ID) {
      return content.filename;
    }
    return TQ.Config.UNNAMED_SCENE_ID;
  }

  function setOnStarted(fn) {
    _onStarted = fn;
  }

  function isNewOpus() {
    return (!TQ.State.shareCode);
  }

  function needToSave() {
    return (currScene && (TQ.State && !TQ.State.isPlayOnly && !TQ.State.isTopicIntro) &&
      !currScene.isCurrentLevelEmpty() &&
      currScene.isAllDataReady() &&
      !currScene.isSaved);
  }

  return {
    levelThumbs: levelThumbs,
    updateThumbnail: updateThumbnail,
    setOnStarted: setOnStarted,
    start: start, // start a new one, or load previous one (edited or played)
    create: create,
    needToSave: needToSave,
    save: save,
    saveOpusAndScreenshot: saveOpusAndScreenshot,
    createHtmlPage: createHtmlPage,
    forkIt: forkIt,
    cloneIt: cloneIt,
    setAsNew: setAsNew,
    startAutoSave: startAutoSave,
    stopAutoSave: stopAutoSave,
    uploadScreenshot: uploadScreenshot,
    edit: edit, // open for edit
    getWcy: getWcy,
    getOutro: getOutro,
    preloadWcy: preloadWcy,
    getWcyById: getWcyById,
    getTopicIntro: getTopicIntro,
    getShareCode: getShareCode,
    getScreenshotUrl: getScreenshotUrl,
    hasSsPath: hasSsPath,
    onUrlChanged: onUrlChanged,
    show: show, // open for show only

    // old api will be depreciated
    test: show,
    createScene: create
  };
}

/**
 * Created by Andrewz on 3/28/2017.
 * SAG: Simple Animation Generator
 */
var TQ = TQ || {};
TQ.AnimationManager = (function() {
  "use strict";
  var UNLIMIT = 99999999;
  var MIN_MOVE_TIME = 0.1;
  var DEFAULT_DELAY = 0;
  var DEFAULT_DURATION = Math.round(TQ.FrameCounter.f2t(16)); // frames

  var SagCategory = {
    IN: 1,
    IDLE: 2,
    OUT: 3
  };

  var SagType = {
    NO: "no animation",

    // translate
    RIGHT_IN: "sag right in",
    LEFT_IN: "sag left in",
    BOTTOM_IN: "sag bottom in",
    TOP_IN: "sag top in",

    RIGHT_OUT: "sag right out",
    LEFT_OUT: "sag left out",
    BOTTOM_OUT: "sag bottom out",
    TOP_OUT: "sag top out",

    SCALE_IN: "sag scale in",
    SCALE_OUT: "sag scale out",

    // idle
    FLOAT_X: "sag float x",
    ROTATE: "sag rotate",
    TWINKLE: "sag twinkle",

    // opacity change
    FADE_IN: "sag fade in",
    FADE_OUT: "sag fade out"
  };
  var sagLatest = null;

  var state = {
    delay: DEFAULT_DELAY,
    duration: DEFAULT_DURATION,
    leftIn: false,
    leftOut: false,
    rightIn: false,
    rightOut: false,
    topIn: false,
    topOut: false,
    bottomIn: false,
    bottomOut: false,
    scaleIn: false,
    scaleOut: false,
    rotate: false,
    fadeIn: false,
    fadeOut: false,
    twinkle: false
  };

  var speeds = {
    leftIn: 2.5, // 1--5,
    leftOut: 2.5,
    rightIn: 2.5,
    rightOut: 2.5,
    floatX: 2.5,
    topIn: 2.5,
    topOut: 2.5,
    bottomIn: 2.5,
    bottomOut: 2.5,
    scaleIn: 2.5,
    scaleOut: 2.5,
    rotate: 2.5,
    fadeIn: 2.5,
    fadeOut: 2.5,
    twinkle: 2.5
  };

  var animationList = [
    "rotate",
    "twinkle",
    "scaleIn",
    "scaleOut",
    "fadeIn",
    "fadeOut",

    "leftIn",
    "rightIn",
    "topIn",
    "bottomIn",

    "leftOut",
    "rightOut",
    "topOut",
    "bottomOut"
  ];

  var instance = {
    categoryId: SagCategory.IN,
    tDelay: DEFAULT_DELAY,
    tDuration: DEFAULT_DURATION, // seconds
    getCurrentTypeSag: getCurrentTypeSag,
    previewAndRemoveLatest: previewAndRemoveLatest,
    state: state,
    speeds: speeds,
    SagCategory: SagCategory,
    SagType: SagType,

    initialize: initialize,
    removeAllSags: removeAllSags,
    clear: clear,
    reset: reset,
    rotate: rotate,
    twinkle: twinkle,
    scaleIn: scaleIn,
    scaleOut: scaleOut,
    fadeIn: fadeIn,
    fadeOut: fadeOut,
    floatX: floatX,

    leftIn: leftIn,
    rightIn: rightIn,
    topIn: topIn,
    bottomIn: bottomIn,

    leftOut: leftOut,
    rightOut: rightOut,
    topOut: topOut,
    bottomOut: bottomOut
  };

  return instance;

  function initialize() {

  }

  function clear() {
    sagLatest = null;
    instance.tDelay = DEFAULT_DELAY;
    instance.tDuration = DEFAULT_DURATION;
  }

  function reset(ele) {
    if (!sagLatest || sagLatest.ele !== ele) {
      sagLatest = null;
    }
    if (!ele) {
      ele = TQ.SelectSet.getLastSolidElement();
      if (!ele) {
        state.hasSag = false;
        return false;
      }
    }

    state.hasSag = !!ele.getSags();
    var existSag = getCurrentTypeSag(ele);
    if (existSag && (instance.categoryId === existSag.categoryId)) {
      instance.tDuration = existSag.duration;
      instance.tDelay = existSag.delay;
    }

    return true;
  }

  function getCurrentTypeSag(ele) {
    var existSags = ele.getSags();
    var sag;
    var result = null;

    if (existSags) {
      existSags.some(function(channelSags) {
        if (channelSags && (sag = channelSags[instance.categoryId])) {
          if ((typeof sag.duration === "undefined") || (typeof sag.delay === "undefined")) {
            TQ.AssertExt.invalidLogic(false, "缺少duration和delay: " + sag.typeId);
            return false;
          }
          instance.tDuration = sag.duration;
          instance.tDelay = sag.delay;
          result = sag;
          return true;
        }
        return false;
      });
    }
    return result;
  }

  function rotate() {
    TQ.Log.debugInfo("rotate");
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }
    var endAngle = ele.getRotation();
    var startAngle = endAngle - 360;
    var sag = composeIdleSag(SagType.ROTATE, startAngle, endAngle);
    return recordSag(sag);
  }

  function twinkle() {
    var delay = TQ.FrameCounter.gridSnap(getTDelay().t);
    var t1 = delay;
    var duration = composeDuration(); // seconds

    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("twinkle");
    var speed = getSpeed(SagType.TWINKLE);
    var showT = 1 / speed.actualSpeed;
    var hideT = showT;
    var sag = {
      // / for editor only begin
      delay: delay,
      duration: duration,
      // / for editor only end
      categoryId: SagCategory.IDLE,
      typeId: SagType.TWINKLE,
      showT: showT,
      hideT: hideT,
      speed: speed.normSpeed, // only for UI // ToDo: 实际的speed
      t1: t1,
      t2: t1 + duration // UNLIMIT // end time
    };

    return recordSag(sag);
  }

  function recordSag(sagOrsags) {
    var ele = TQ.SelectSet.getLastSolidElement();
    var sags = (Array.isArray(sagOrsags) ? sagOrsags : [sagOrsags]);
    var sagId;

    if (ele) {
      sagId = TQ.TrackRecorder.recordSag(ele, sags);
      TQ.DirtyFlag.setElement(ele);
    }

    sagLatest = {
      sag: sags[0],
      ele: ele
    };

    return sagId;
  }

  function previewAndRemoveLatest() {
    setTimeout(function() {
      if (sagLatest && sagLatest.ele && sagLatest.sag) {
        document.addEventListener(TQ.FrameCounter.EVENT_AB_PREVIEW_STOPPED, onABPreviewStopped);
        TQ.Scene.doReplay(composePreviewOptions(sagLatest.sag));
      }
    });
  }

  function onABPreviewStopped() {
    document.removeEventListener(TQ.FrameCounter.EVENT_AB_PREVIEW_STOPPED, onABPreviewStopped);
    removePreviewedSag();
  }

  function composePreviewOptions(sag) {
    var t1; var t2;
    var currentTime = TQ.FrameCounter.t();
    switch (sag.typeId) {
      case SagType.TWINKLE:
        t1 = currentTime;
        t2 = t1 + 3 * (sag.hideT + sag.showT);
        break;
      case SagType.LEFT_IN:
      case SagType.RIGHT_IN:
      case SagType.BOTTOM_IN:
      case SagType.TOP_IN:
      case SagType.FADE_IN:
      case SagType.SCALE_IN:
      case SagType.FLOAT_X:
        t1 = sag.t1;
        t2 = sag.t2;
        break;

      case SagType.LEFT_OUT:
      case SagType.RIGHT_OUT:
      case SagType.BOTTOM_OUT:
      case SagType.TOP_OUT:
      case SagType.FADE_OUT:
      case SagType.SCALE_OUT:
        t1 = sag.t1;
        t2 = sag.t2;
        break;

      default:
        t1 = sag.t1;
        t2 = sag.t2;
        break;
    }

    var EPSILON = 0.1; /* 0.1s, 大约少1~2帧, 以免跨入下一个level */
    if (TQ.FrameCounter.maxTime() < t2) {
      TQ.FrameCounter.setTMax(t2);
    }
    t2 = Math.min(t2, TQ.FrameCounter.maxTime() - EPSILON);
    return { tStart: t1, tEnd: t2, stopAt: currentTime };
  }

  function leftIn() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("left in");
    var posInWorld = ele.getPositionInWorld();
    var startPos = -ele.getBBoxRadiusInWorld();
    var sag = composeFlyInSag(SagType.LEFT_IN, startPos, posInWorld.x);
    return recordSag(sag);
  }

  function rightIn() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("right in");
    var posInWorld = ele.getPositionInWorld();
    var startPos = TQ.Graphics.getCanvasWidth() + ele.getBBoxRadiusInWorld();
    var sag = composeFlyInSag(SagType.RIGHT_IN, startPos, posInWorld.x);
    return recordSag(sag);
  }

  function floatX() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("float x");
    var MARGIN = 10;
    var posInWorld = ele.getPositionInWorld();
    var halfWidth = ele.getBBoxRadiusInWorld() / 2;
    var startPos = posInWorld.x;
    var fakeEndPos = startPos + TQ.Graphics.getCanvasWidth();
    var extraData = {
      xMin: 0 - halfWidth - MARGIN,
      xMax: TQ.Graphics.getCanvasWidth() + halfWidth + MARGIN
    };

    var sag = composeIdleSag(SagType.FLOAT_X, startPos, fakeEndPos, extraData);
    return recordSag(sag);
  }

  function bottomIn() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("bottom in");
    var posInWorld = ele.getPositionInWorld();
    var startPos = -ele.getBBoxRadiusInWorld();
    var sag = composeFlyInSag(SagType.BOTTOM_IN, startPos, posInWorld.y);
    return recordSag(sag);
  }

  function topIn() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("top in");
    var posInWorld = ele.getPositionInWorld();
    var startPos = TQ.Graphics.getCanvasHeight() + ele.getBBoxRadiusInWorld();
    var sag = composeFlyInSag(SagType.TOP_IN, startPos, posInWorld.y);
    return recordSag(sag);
  }

  function leftOut() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("left out");
    var posInWorld = ele.getPositionInWorld();
    var endPos = -ele.getBBoxRadiusInWorld();
    var sag = composeFlyOutSag(SagType.LEFT_OUT, posInWorld.x, endPos);
    return recordSag(sag);
  }

  function rightOut() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("right out");
    var posInWorld = ele.getPositionInWorld();
    var endPos = TQ.Graphics.getCanvasWidth() + ele.getBBoxRadiusInWorld();
    var sag = composeFlyOutSag(SagType.RIGHT_OUT, posInWorld.x, endPos);

    return recordSag(sag);
  }

  function bottomOut() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("bottom out");
    var posInWorld = ele.getPositionInWorld();
    var endPos = -ele.getBBoxRadiusInWorld();
    var sag = composeFlyOutSag(SagType.BOTTOM_OUT, posInWorld.y, endPos);
    return recordSag(sag);
  }

  function topOut() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("top out");
    var posInWorld = ele.getPositionInWorld();
    var endPos = TQ.Graphics.getCanvasHeight() + ele.getBBoxRadiusInWorld();
    var sag = composeFlyOutSag(SagType.TOP_OUT, posInWorld.y, endPos);
    return recordSag(sag);
  }

  function scaleIn() {
    TQ.Log.debugInfo("scale in");
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    var endSx = ele.getScaleInWorld().sx;
    var startSx = 0.01 * endSx;
    var endSy = ele.getScaleInWorld().sy;
    var startSy = 0.01 * endSy;
    var sagX = composeFlyInSag(SagType.SCALE_IN, startSx, endSx);
    var sagY = composeFlyInSag(SagType.SCALE_IN, startSy, endSy);
    return recordSag([sagX, sagY]);
  }

  function scaleOut() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("scale out");
    var startSx = ele.getScaleInWorld().sx;
    var endSx = 0.01 * startSx;
    var startSy = ele.getScaleInWorld().sy;
    var endSy = 0.01 * startSy;
    var sagX = composeFlyOutSag(SagType.SCALE_OUT, startSx, endSx);
    var sagY = composeFlyOutSag(SagType.SCALE_OUT, startSy, endSy);
    return recordSag([sagX, sagY]);
  }

  function fadeIn() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("fade in");
    var endValue = ele.getAlpha();
    var startValue = 0;
    var sag = composeFlyInSag(SagType.FADE_IN, startValue, endValue);
    return recordSag(sag);
  }

  function fadeOut() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    TQ.Log.debugInfo("fade out");
    var endValue = 0;
    var startValue = ele.getAlpha();
    var sag = composeFlyOutSag(SagType.FADE_OUT, startValue, endValue);
    return recordSag(sag);
  }

  function getTDelay() {
    return { t: instance.tDelay };
  }

  function getTDuration() {
    return { t: instance.tDelay + instance.tDuration };
  }

  function composeDuration() {
    return TQ.FrameCounter.gridSnap((getTDuration().t - getTDelay().t));
  }

  // private functions:
  function composeIdleSag(typeId, startPos, destinationPos, extraData) {
    return composeSag(SagCategory.IDLE, typeId, startPos, destinationPos, extraData);
  }

  function composeFlyInSag(typeId, startPos, destinationPos) {
    return composeSag(SagCategory.IN, typeId, startPos, destinationPos);
  }

  function composeSag(categoryId, typeId, startPos, destinationPos, extraData) {
    var speed = getSpeed(typeId);
    var delay = TQ.FrameCounter.gridSnap(getTDelay().t); var // seconds
      duration = composeDuration(); // seconds
    var t1 = delay;
    var dampingDuration = TQ.FrameCounter.gridSnap(TQ.SpringEffect.defaultConfig.dampingDuration); // seconds
    var t2 = t1 + duration;
    var velocity;
    var dt = t2 - t1 - dampingDuration;
    if (dt < MIN_MOVE_TIME) {
      t1 = t2 - dampingDuration - MIN_MOVE_TIME;
      dt = t2 - t1 - dampingDuration;
    }

    velocity = (destinationPos - startPos) / dt;
    return {
      // / for editor only begin
      delay: delay,
      duration: duration,
      extraData: extraData,
      // / for editor only end
      destinationPos: destinationPos, // exactly stop at this point
      categoryId: categoryId,
      typeId: typeId,
      speed: speed.normSpeed, // 1-5 规范化的速度
      actualSpeed: velocity,
      value0: startPos,
      t1: t1, // start time
      t2: t2
    };
  }

  function composeFlyOutSag(typeId, startPos, destinationPos) {
    var speed = getSpeed(typeId);
    var delay = TQ.FrameCounter.gridSnap(getTDelay().t);
    var duration = composeDuration(); // seconds
    var t1 = delay;
    var dampingDuration = TQ.FrameCounter.gridSnap(TQ.SpringEffect.defaultConfig.dampingDuration); // seconds
    var t2 = t1 + duration;
    var velocity;
    var dt = t2 - t1 - dampingDuration;
    if (dt < MIN_MOVE_TIME) {
      t1 = t2 - dampingDuration - MIN_MOVE_TIME;
      dt = t2 - t1 - dampingDuration;
    }

    velocity = (destinationPos - startPos) / dt;
    return {
      // / for editor only begin
      delay: delay,
      duration: duration,
      // / for editor only end
      destinationPos: destinationPos, // exactly stop at this point
      categoryId: SagCategory.OUT,
      typeId: typeId,
      speed: speed.normSpeed,
      actualSpeed: velocity,
      value0: startPos,
      t1: t1, // start time
      t2: t2
    };
  }

  function getSpeed(typeId) {
    var norm;
    var actual;
    var speedFactor = TQ.Config.speedFactor;
    switch (typeId) {
      case SagType.FADE_IN:
        norm = speeds.fadeIn;
        actual = norm * speedFactor.fadeIn;
        break;

      case SagType.FADE_OUT:
        norm = speeds.fadeOut;
        actual = norm * speedFactor.fadeOut;
        break;

      case SagType.SCALE_IN:
        norm = speeds.scaleOut;
        actual = norm * speedFactor.scaleIn;
        break;

      case SagType.SCALE_OUT:
        norm = speeds.scaleIn;
        actual = norm * speedFactor.scaleOut;
        break;

      case SagType.ROTATE:
        norm = speeds.rotate;
        actual = norm * speedFactor.rotate;
        break;

      case SagType.LEFT_IN:
        norm = speeds.leftIn;
        actual = norm * speedFactor.flyIn;
        break;

      case SagType.LEFT_OUT:
        norm = speeds.leftOut;
        actual = norm * speedFactor.flyOut;
        break;

      case SagType.RIGHT_IN:
        norm = speeds.rightIn;
        actual = norm * speedFactor.flyIn;
        break;

      case SagType.RIGHT_OUT:
        norm = speeds.rightOut;
        actual = norm * speedFactor.flyOut;
        break;

      case SagType.TOP_IN:
        norm = speeds.topIn;
        actual = norm * speedFactor.flyIn;
        break;

      case SagType.TOP_OUT:
        norm = speeds.topOut;
        actual = norm * speedFactor.flyOut;
        break;

      case SagType.BOTTOM_IN:
        norm = speeds.bottomIn;
        actual = norm * speedFactor.flyIn;
        break;

      case SagType.BOTTOM_OUT:
        norm = speeds.bottomOut;
        actual = norm * speedFactor.flyOut;
        break;

      case SagType.TWINKLE:
        norm = speeds.twinkle;
        actual = norm * speedFactor.twinkle;
        break;

      case SagType.FLOAT_X:
        norm = speeds.floatX;
        actual = norm * speedFactor.floatX;
        break;

      default:
        TQ.AssertExt.invalidLogic(false, "unknown case");
        break;
    }

    return { normSpeed: norm, actualSpeed: actual };
  }

  function removeAllSags() {
    var ele = TQ.SelectSet.getLastSolidElement();
    if (!ele) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }
    TQ.TrackRecorder.removeAllSags(ele);
    TQ.DirtyFlag.setElement(ele);
  }

  function removePreviewedSag() {
    if (sagLatest && sagLatest.ele && sagLatest.sag) {
      TQ.TrackRecorder.removeSag(sagLatest.ele, sagLatest.sag);
      TQ.DirtyFlag.setElement(sagLatest.ele);
      sagLatest = null;
    }
  }
})();

var TQ = TQ || {};
(function() {
  function CameraService() {
  }
  // take picture/video via camera, and insert it into WCY directly as background
  var _isVideo = false;
  var pcTestImage = "img/camera-emulator.png";

  var takePicture = function(sourceType, onSuccess, onError, imageWidth, imageHeight) {
    if (_isVideo) {
      _takeVideo(sourceType, onSuccess, onError, imageWidth, imageHeight);
    } else {
      _takeStaticImage(sourceType, onSuccess, onError, imageWidth, imageHeight);
    }
  };

  var _takeStaticImage = function(sourceType, onSuccess, onError, imageWidth, imageHeight) {
    if (!TQ.Base.Utility.isCordovaDevice()) {
      TQ.Log.info("isPC!");
    }

    if (!navigator.camera) {
      TQ.Log.info("Camera is not supported, return emulator picture instead");
      onSuccess(pcTestImage);
      return;
    }

    var options = { quality: 50,
      destinationType: Camera.DestinationType.FILE_URI,
      correctOrientation: true,
      // allowEdit : true, // to shrink the image, uncomment these 3 lines
      targetWidth: imageWidth,
      targetHeight: imageHeight,
      saveToPhotoAlbum: false,
      // popoverOptions: CameraPopoverOptions, // ios-only features
      sourceType: sourceType, // 0:Photo Library, 1=Camera, 2=Saved Album
      encodingType: 0 // 0=JPG 1=PNG
    };

    if (enabledBase64()) {
      options.destinationType = Camera.DestinationType.DATA_URL;
    }

    navigator.camera.getPicture(
      function(data) {
        onSuccess(data);
      },
      function(error) {
        // hasImage = false; // probable take more pictures;
        var NORMAL_ACTION = "Camera cancelled";
        if (angular.isString(error) && error.indexOf(NORMAL_ACTION) >= 0) {
          return;
        }

        TQ.Log.eroor("Error in camera call:" + angular.toJson(error));
        if (onError) {
          onError();
        }
      },
      options);

    return false;
  };

  var _takeVideo = function(sourceType, onSuccess, onError) {
    if (!TQ.Base.Utility.isCordovaDevice()) {
      alert("isPC!");
    }

    if (!navigator.camera) {
      alert("Camera is not supported", "Error");
      return;
    }

    // capture callback
    var captureSuccess = function(mediaFiles) {
      var path, len;
      for (let i = 0, len = mediaFiles.length; i < len; i += 1) {
        path = mediaFiles[i].fullPath;
        alert(path);
        // do something interesting with the file
      }

      if (mediaFiles.length > 0) {
        onSuccess(mediaFiles[0].fullPath);
      }
    };

    // capture error callback
    var captureError = function(error) {
      TQ.Log.error("Camera Error: " + error.code);
    };

    // start video capture
    navigator.device.capture.captureVideo(captureSuccess, captureError, { limit: 2 });
  };

  var enabledBase64 = function() {
    return false;
    // return ((!TQ.Base.Utility.isPC()) && (!_isVideo) && TQ.Base.Utility.isFullySupported());
  };

  function insertFromCamera() {
    var sourceType = 1; // 0:Photo Library, 1=Camera, 2=Saved Album
    var imageWidth = 660;
    var imageHeight = 1024;

    function onSuccess(imageUrl) {
      var desc = { src: imageUrl, type: "Bitmap", autoFit: TQ.Element.FitFlag.FULL_SCREEN };
      TQ.SceneEditor.addItem(desc);
    }

    function onError() {

    }
    takePicture(sourceType, onSuccess, onError, imageWidth, imageHeight);
  }

  CameraService.insertFromCamera = insertFromCamera;
  CameraService.takePicture = takePicture;
  CameraService.enabledBase64 = enabledBase64;
  TQ.CameraService = CameraService;
}());

/**
 * Created by Andrewz on 1/17/2016.
 * EditorExt service 是 SceneEditor的扩展，
 * * 可以调用更多的模块（比editor）， 比如图片上传模块
 */

angular.module("starter").factory("EditorService", EditorService);
EditorService.$inject = ["$q", "$rootScope", "$timeout", "NetService", "WxService", "WCY", "AppService", "StatService"];

function EditorService($q, $rootScope, $timeout, NetService, WxService, WCY, AppService, StatService) {
  var CMD_UNKNOWN = "unknown";
  var CMD_MCOPYING_BEGIN = "mcopying begin";
  var CMD_MCOPYING_END = "mcopying end";

  var _initialized = false;
  var _sceneReady = false;
  var _colorPanel = null;
  var _lastSelected = null;
  var fileElement = null;
  var isSharingToFB = false;
  var domEle = null;
  var lastCmd = CMD_UNKNOWN;
  var currCmd = CMD_UNKNOWN;

  var canvas;

  var state = TQ.State;
  var levelThumbs = WCY.levelThumbs;
  var addModeDoneCallback = null;
  var hasTouch = false;
  var hasMouse = false;

  state.isInBkg = false;

  return {
    state: state,
    updateControllers: updateControllers,
    forceToRenderSlider: forceToRenderSlider,

    // 素材管理
    banMat: NetService.banMat,
    shareMat: NetService.shareMat,
    requestToBanMat: NetService.requestToBanMat,
    requestToShareMat: NetService.requestToShareMat,
    addSprite: NetService.addSprite,

    // 作品管理
    requestToBanOpus: NetService.requestToBanOpus,
    banOpus: NetService.banOpus,
    refineOpus: NetService.refineOpus,
    requestToShareOpus: NetService.requestToShareOpus,
    shareOpus: NetService.shareOpus,

    // 主题
    addTopic: NetService.addTopic,
    updateTopic: NetService.updateTopic,
    getTopics: NetService.getTopics,
    attachTopic: NetService.attachTopic,
    detachTopic: NetService.detachTopic,
    banTopic: NetService.banTopic,
    shareTopic: NetService.shareTopic,
    requestToBanTopic: NetService.requestToBanTopic,
    requestToShareTopic: NetService.requestToShareTopic,

    // play & preview
    preview: preview,
    previewCurrentLevel: previewCurrentLevel,
    play: play,
    stop: stop,
    exitPreview: exitPreview,
    pause: pause,
    resume: resume,
    replay: replay,
    startRecord: startRecord,
    stopRecord: stopRecord,
    toggleSpeed: TQ.FrameCounter.toggleSpeed,
    // pause: doPause,

    // opus ==> WCY
    cloneIt: WCY.cloneIt,
    forkIt: forkIt,
    emptyScene: emptyScene,

    // level
    addLevel: addLevel,
    addLevelAt: addLevelAt,
    duplicateCurrentLevel: duplicateCurrentLevel,
    deleteLevel: deleteLevel,
    deleteCurrentLevel: deleteCurrentLevel,
    gotoPreviousLevel: gotoPreviousLevel,
    gotoNextLevel: gotoNextLevel,
    gotoLevel: gotoLevel,

    // level and element
    onDelete: onDelete,
    deleteSound: deleteSound,
    deleteDub: deleteDub,

    // element modification (text, sound, image...)
    changeSkin: changeSkin,
    getFontSize: getFontSize,
    setSize: setSize,
    setFontLevel: setFontLevel,
    setTextProperty: setTextProperty,
    decreaseFontLevel: decreaseFontLevel,
    increaseFontLevel: increaseFontLevel,
    setColor: setColor,
    eraseAnimeTrack: TQ.SelectSet.eraseAnimeTrack,
    turnOnTrim: turnOnTrim,
    turnOffTrim: turnOffTrim,
    trim: trim,
    increaseTimeline: increaseTimeline,
    decreaseTimeline: decreaseTimeline,

    // UI操作部分， 更改了元素的state， 所有，必须 调用 updateMode()，以更新UI
    hideOrShow: hideOrShow,
    pinIt: pinIt,
    attachTextBubble: attachTextBubble,
    detachTextBubble: detachTextBubble,
    moveCtrl: TQ.MoveCtrl,
    // element insert (text, sound, image...)
    mCopyToggle: mCopyToggle,
    insertMat: insertMat,
    loadLocalImage: loadLocalImage,
    loadLocalSound: loadLocalSound,
    insertPeopleImage: insertPeopleImage, // i.e. FromUrl:
    insertIComponent: insertIComponent,
    insertPropImage: insertPropImage,
    insertBkImage: insertBkImage,
    insertImageDesc: insertImageDesc,
    insertText: insertText,
    insertRectangle: insertRectangle,
    insertCircle: insertCircle,
    insertSound: insertSound,
    insertSnow: TQ.ParticleMgr.insertSnow,
    insertRain: TQ.ParticleMgr.insertRain,
    insertMoney: TQ.ParticleMgr.insertMoney,
    uploadIComponentThumbnail: uploadIComponentThumbnail,

    // select set
    emptySelectSet: emptySelectSet,

    // editor
    initialize: initialize,
    forceToRefreshUI: forceToRefreshUI,
    setAddMode: setAddMode,
    toAddMode: toAddMode,
    onAddModeDone: onAddModeDone,
    setModifyMode: setModifyMode,
    getTextCursor: getTextCursor,
    setColorPanel: setColorPanel,
    reset: reset,
    setWorkingRegion: setWorkingRegion,
    setBackgroundColor: setBackgroundColor,
    onEventByToolbar: onEventByToolbar,

    // particle Effect
    ParticleMgr: TQ.ParticleMgr, // start, stop, change(option)

    // share
    shareFbWeb: shareFbWeb
  };

  function addItem(desc, matType) {
    if (isProxyMat(desc.src)) {
      NetService.uploadOne(desc.src, matType).then(function(res) {
        TQ.Log.alertInfo("uploaded " + desc.src + " to " + res.url);
        desc.src = res.url;
        TQ.SceneEditor.addItem(desc);
      }, function(err) {
        TQ.Log.error(err);
      })
        .finally(TQ.MessageBox.reset);
    } else {
      return TQ.SceneEditor.addItem(desc);
    }
    return null;
  }

  function reset() {
    // editor 的各种当前值， 用户选择的
    // element's state
    state.x = 0.1; // in NDC space
    state.y = 0.9;
    state.fontLevel = TQ.Utility.fontSize2Level(TQ.Config.fontSize);
    state.color = TQ.Config.color;
    state.isVisible = true;
    state.isLocked = false;
    state.isFont = false;
    state.showTimer = TQ.Config.hasTimeline;
    state.showTrimTimeline = false; // 不论是否显示timeline，trim都不显示（默认）

    // editor's mode
    if (currScene && !TQ.State.isPlayOnly) {
      setAddMode();
    } else {
      setPreviewMode();
    }
    state.isRecording = false; // must be in AddMode
    state.isPreviewMenuOn = false;
    state.isPlayMode = null;
    TQ.State.isPlaying = false;
    state.isMCopying = false;
    TQ.FrameCounter.toggleSpeed(TQ.Const.TOGGLE_RESET, state);
    if (!state.isPlayOnly) {
      TQ.SelectSet.clear();
      TQ.AnimationManager.clear();
      TQ.SoundMgr.reset();
    }
  }

  function initialize() {
    TQ.TextElementWxAdapter.detectFontSizeFactor();
    reset();
    $rootScope.$on(TQ.Scene.EVENT_READY, onSceneReady);
    $rootScope.$on(TQ.EVENT.REFRESH_UI, forceToRefreshUI);
    TQDebugger.Panel.init();
  }

  function forceToRenderSlider() {
    $timeout(function() { // 初始化slider模块
      $rootScope.$broadcast("rzSliderForceRender");
    });
  }

  function onSelectSetChange() {
    updateMode();
  }

  function onSceneReady() {
    var outroId;
    reset();
    TQ.PreviewMenu.initialize(state, onPreviewMenuOn, onPreviewMenuOff);
    onResize();
    if (!currScene.outroInitialized && (outroId = currScene.getOutroId()) != null) {
      WCY.getOutro(outroId);
    }

    if (!_sceneReady) { // 新建WCY， 不属于此
      TQ.AssertExt.invalidLogic(!_sceneReady, "不能反复调用");
      _sceneReady = true;
      window.addEventListener("resize", onResize);
      window.addEventListener("orientationchange", function() {
        $timeout(onResize); // ！！ 必须用timeout 之后， 否则ipad上不起作用。
      });
      window.addEventListener("blur", onGotoBkg);
      window.addEventListener("focus", onGotoForegroud);
      var pausedByBkur = false;

      function onGotoBkg() {
        state.isInBkg = true;
        console.log("state on go to bkg!");
        if (isEditMode() || isPlayMode()) {
          if (!TQ.FrameCounter.isPaused()) {
            pausedByBkur = true;
            stop();
          }
        } else {
          TQ.SoundMgr.stopAll();
          TQ.VideoMgr.stopAll();
        }
      }

      function onGotoForegroud() {
        state.isInBkg = false;
        if (screenfull && !screenfull.enabled) {
          screenfull.setupAutoEnable();
        }
        console.log("state on go to foreground!");
        if (pausedByBkur) {
          pausedByBkur = false;
          if (isPlayMode()) {
            play();
          }
        }
      }

      function isEditMode() {
        return (state.editorMode === TQ.SceneEditor.MODE.EDIT);
      }

      function isPlayMode() {
        return (state.editorMode === TQ.SceneEditor.MODE.PREVIEW);
      }

      document.addEventListener(TQ.SelectSet.SELECTION_NEW_EVENT, onSelectSetChange);
      document.addEventListener(TQ.SelectSet.SELECTION_EMPTY_EVENT, onSelectSetChange);
      document.addEventListener(TQ.Element.EVENT_NEW_ELEMENT_ADDED, onNewElementAdded);
      updateMode();
      updateColorPanel();
      if (TQ.Config.statServiceEnabled) {
        // 此服务无法lazyLoading，因为是ng模块， 暂时停止使用
        StatService.startToShow();
      }

      if (TQ.Config.hasFacebook) {
        TQ.LazyLoading.loadOne("/wcy3Social/fb.js");
      }

      // TQ.TouchManager.addHandler('swipeleft', gotoPreviousLevel);
      // TQ.TouchManager.addHandler('swiperight', gotoNextLevel);
    }

    if (TQ.State.isPlayOnly) {
      updateControllers();
      preview();
    }
  }

  function onNewElementAdded(evt) {
    // 用事件， 在条件满足之后，再触发event，比延时更好，确保资源和M矩阵都ready。
    var ele = (evt && evt.data && evt.data.element) ? evt.data.element : null;
    if (ele && ele.level && ele.level.isActive()) {
      if (ele.isSound()) {
        ele.play(true);
      } else if (ele.isVideo()) {
        TQ.VideoMgr.play(ele.jsonObj.src);
      } else {
        if (!ele.isSound() && ele.isSelectable()) { // particle不能够纳入普通的选择集
          TQ.SelectSet.add(ele);
        }
      }
    }
  }

  function updateControllers() { // 在login和fork之后， 都需要使用
    if (!TQ.TouchManager.hasInitialized() && !TQ.State.isPlayOnly) {
      TQ.TouchManager.initialize();
    }

    if (!TQ.TouchManager.hasStarted() && !TQ.State.isPlayOnly) {
      TQ.TouchManager.start();
    }

    if (TQ.TouchManager.hasStarted() && TQ.State.isPlayOnly) {
      TQ.TouchManager.stop();
    }
  }

  function onResize() {
    if (!TQ.State.textEditor || !TQ.State.textEditor.isOpening) {
      AppService.configCanvas();
      forceToRedraw(); // 迫使IOS系统重新绘制canvas上的图像
    }
  }

  function isSelectedEvent(e) {
    if (hasTouch) {
      if (e.type === "click") {
        return false;
      }
    }

    if (hasMouse) {
      if (e.type === "touchstart") {
        return false;
      }
    }

    if (e.type === "touchstart") {
      hasTouch = true;
    } else if (e.type === "click") {
      hasMouse = false;
    } else {
      console.error("wrong events: " + e.type);
    }

    return true;
  }

  function onPreviewMenuOn() {
    $timeout(function() {
      TQ.IdleCounter.remove(TQ.PreviewMenu.hide);
      $timeout(forceToRenderSlider, 200);
    });
  }

  function onPreviewMenuOff() {
    $timeout(function() {
      state.isPreviewMenuOn = false;
    });
  }

  function loadLocalSound(matType, useDevice, files, callback) {
    if (WxService.isReady()) {
      // alert("请在浏览器中打开，以便于使用所有功能");
      // return doInsertMatFromLocalWx(matType);
    }

    var dstLevel = currScene.currentLevel;
    if (matType === TQ.MatType.SOUND) {
      if (useDevice) {
        if (TQ.AudioRecorder.isRecording) {
          return TQ.AudioRecorder.stop();
        } else {
          return TQ.AudioRecorder.start(function(data) {
            TQ.SceneEditor.addItemByFile(dstLevel, data, matType, callback);
          }, forceToRefreshUI);
        }
      } else {
        var soundFile = files[files.length - 1];
        if (soundFile.size > TQ.Config.MAX_SOUND_FILE_SIZE) {
          return TQ.MessageBox.confirm("文件太大，影响打开速度，请限制声音文件大小 < " + Math.round(TQ.Config.MAX_SOUND_FILE_SIZE / 1000) + "K");
        }
        TQ.SceneEditor.addItemByFile(dstLevel, soundFile, matType, callback);
      }
    }
  }

  function loadLocalImage(matType, useDevice, filesOrImage64, callback, kouTuMain) {
    var dstLevel = currScene.currentLevel;
    var files = (filesOrImage64 instanceof FileList) ? filesOrImage64 : [filesOrImage64];
    var n = files.length;
    var mat;

    function processOneFile(i) {
      if (i >= n) {
        return;
      }
      mat = files[i];
      if (TQ.Utility.isImageFile(mat) || TQ.Utility.isImage64(mat) || TQUtility.isVideoFile(mat)) {
        TQ.SceneEditor.preprocessLocalImage(dstLevel, mat, matType, onPreprocessCompleted, kouTuMain);
      }

      function onPreprocessCompleted(desc, fileOrBlob, matType) {
        callback(desc, fileOrBlob, matType);
        if ((i + 1) < n) {
          $timeout(function() {
            processOneFile(i + 1);
          });
        }
      }
    }

    processOneFile(0);
  }

  function processOneMat(data) {
    var aFile = data.aFile;
    var matType = data.matType;

    var wxAbility = {
      FileAPI: !!window.FileAPI,
      FileReader: !!window.FileReader,
      URL: !!window.URL,
      XMLHttpRequest: !!window.XMLHttpRequest,
      Blob: !!window.Blob,
      ArrayBuffer: !!window.ArrayBuffer,
      webkitURL: !!window.webkitURL,
      atob: !!window.atob
    };

    TQ.MessageBox.showWaiting(TQ.Locale.getStr("processing..."));
    TQ.Log.alertInfo("before uploadOne:" + JSON.stringify(wxAbility));

    var q = $q.defer();

    // ToDo: 检查合法的文件类别
    switch (matType) {
      case TQ.MatType.BKG:
        var options = { crossOrigin: "Anonymous" }; // "Use-Credentials";
        TQ.ImageProcess.start(aFile, options,
          function(buffer) {
            data.fileOrBuffer = buffer;
            q.resolve(data);
          });
        break;
      default:
        if (matType === TQ.MatType.SOUND) {
          if (!TQUtility.isSoundFile(aFile)) {
            var str = TQ.Locale.getStr("found audio format unsupported, please use wav or map3") + ": " + aFile.type;
            TQ.MessageBox.show(str);
            q.reject({ error: 1, msg: str });
            break;
          }
        }
        data.fileOrBuffer = aFile;
        q.resolve(data);
    }

    return q.promise;
  }

  function uploadMat(data, option) {
    var fileOrBuffer = data.fileOrBuffer;
    var matType = data.matType;
    var q = $q.defer();

    NetService.uploadOne(fileOrBuffer, matType, option).then(function(res) {
      data.url = res.url;
      q.resolve(data);
    });

    return q.promise;
  }

  function uploadIComponentThumbnail() {
    var option = {
      iComponentId: TQ.Scene.getWcyId(),
      // ToDo: 素材库已有的图片，直接利用，避免再次上传，只是新素材id而已
      src: TQ.ScreenShot.getDataWithBkgColor()
    };
    var data = {
      matType: currScene.iComponentInfo.type,
      fileOrBuffer: option.src
    };

    return uploadMat(data, option);
  }

  function addItemByData(data) {
    TQ.Log.debugInfo("mat url: " + data.url);
    addItemByUrl(data.url, data.matType, data.option);
  }

  function mCopyToggle() {
    if (TQ.SelectSet.isEmpty() && !state.isMCopying) {
      return TQ.MessageBox.prompt(TQ.Locale.getStr("please select an object first!"));
    }

    state.isMCopying = !state.isMCopying;
    currCmd = (state.isMCopying) ? CMD_MCOPYING_BEGIN : CMD_MCOPYING_END;
    if (state.isMCopying) {
      TQ.SelectSet.btnEffect.mCopy = "effect-working";
    } else {
      TQ.SelectSet.btnEffect.mCopy = null;
    }
    TQ.TouchManager.updateOps(state);
  }

  function insertMat(data) {
    return uploadMat(data).then(addItemByData, function(err) {
      TQ.Log.error(err);
    })
      .finally(TQ.MessageBox.reset);
  }

  // private functions:
  function doInsertMatFromLocalWx(matType) {
    WxService.chooseImage().then(function(filePath) {
      var aFile = {
        path: filePath,
        type: matType,
        isWx: true
      };

      TQ.Log.alertInfo("微信InsertLocal：" + JSON.stringify(aFile));
      processOneMat(aFile, matType);
    }, function(err) {
      TQ.Log.error(err);
    });
  }

  function isProxyMat(url) {
    var mainDomain = TQUtility.urlParser(url).origin;
    return (url && (TQ.Config.whiteListMatHosts.indexOf(mainDomain) < 0));
  }

  function insertImage(filename, x, y, matType, fitFlag) {
    if (!fitFlag) {
      fitFlag = TQ.Element.FitFlag.WITHIN_FRAME;
    }
    if (!matType) {
      matType = TQ.MatType.PROP;
    }
    var descType = (matType === TQ.ElementType.GROUP_FILE) ? TQ.ElementType.GROUP_FILE : "Bitmap";
    var desc = {
      src: filename, type: descType, eType: TQ.MatType.toEType(matType),
      autoFit: fitFlag, x: x, y: y
    };
    addItem(desc, matType);
  }

  function insertImageDesc(desc) {
    if (desc.eType === TQ.Element.ETYPE_BACKGROUND) {
      desc.autoFit = TQ.Element.FitFlag.FULL_SCREEN;
      desc.zIndex = 0;
    }

    TQ.SceneEditor.addItem(desc);
  }

  function insertPeopleImage(filename, x, y, fitFlag) {
    insertImage(filename, x, y, TQ.MatType.PEOPLE, fitFlag);
  }

  function insertIComponent(filename, x, y, fitFlag) {
    insertImage(filename, x, y, TQ.ElementType.GROUP_FILE, fitFlag);
  }

  function insertPropImage(filename, x, y, fitFlag) {
    insertImage(filename, x, y, TQ.MatType.PROP, fitFlag);
  }

  function insertBkImage(filename, x, y) {
    var desc = {
      src: filename, type: "Bitmap", eType: TQ.Element.ETYPE_BACKGROUND,
      autoFit: TQ.Element.FitFlag.FULL_SCREEN, x: x, y: y,
      zIndex: 0
    };
    addItem(desc, TQ.MatType.BKG);
  }

  function insertText(message, x, y, options) {
    if (!message) {
      return TQ.Log.info("空字符串， 不必添加到画布");
    }
    if (!state.fontFace) {
      state.fontFace = TQ.Config.fontFace;
    }

    if (options) {
      if (options.fontSize) {
        state.fontLevel = TQ.Utility.fontSize2Level(options.fontSize);
      }
      if (options.color) {
        state.color = options.color;
      }
    }

    var desc = {
      src: null,
      text: message,
      type: "Text",
      eType: TQ.Element.ETYPE_TEXT,
      autoFit: TQ.Element.FitFlag.KEEP_SIZE,
      x: x,
      y: y,
      fontSize: getFontSize(), // 必须是像素坐标，在designated坐标系
      fontFace: state.fontFace,
      color: state.color
    };

    TQ.SceneEditor.addItem(desc);
    // TQ.TextEditor.initialize();
    // TQ.TextEditor.addText(TQ.Dictionary.defaultText);
  }

  function insertCircle(x, y, r) {
    var desc = {
      src: null,
      type: TQ.ElementType.CIRCLE,
      eType: TQ.Element.ETYPE_CIRCLE,
      autoFit: TQ.Element.FitFlag.NO,
      x: x,
      y: y,
      width: r,
      height: r,
      radius: r,
      color: "#FF0000"
    };

    TQ.SceneEditor.addItem(desc);
  }

  function insertRectangle(x, y, w, h) {
    var desc = {
      src: null,
      type: TQ.ElementType.RECTANGLE,
      eType: TQ.Element.ETYPE_RECTANGLE,
      autoFit: TQ.Element.FitFlag.NO,
      x: x,
      y: y,
      width: w,
      height: h,
      fontSize: getFontSize(), // 必须是像素坐标，在designated坐标系
      color: state.color
    };

    TQ.SceneEditor.addItem(desc);
  }

  function insertSound(urlOrConfig, resourceName, isCrossLevel) {
    var desc = {
      resName: resourceName,
      type: "SOUND",
      eType: TQ.Element.ETYPE_AUDIO,
      isCrossLevel: isCrossLevel
    };

    if (angular.isObject(urlOrConfig)) {
      desc = TQUtility.extend(desc, urlOrConfig);
    } else {
      desc.src = urlOrConfig;
    }

    if (desc.sprite && !desc.sprite["__default"]) {
      desc.sprite["__default"] = desc.sprite[desc.spriteMap[0]];
    }

    return addItem(desc, TQ.MatType.SOUND);
  }

  function addItemByUrl(url, matType, option) {
    var eleType = (matType === TQ.MatType.SOUND) ? TQ.ElementType.SOUND : TQ.ElementType.BITMAP;
    var autoFitRule = (matType === TQ.MatType.BKG)
      ? TQ.Element.FitFlag.FULL_SCREEN : TQ.Element.FitFlag.WITHIN_FRAME;
    var desc = option || {};
    desc.src = url;
    desc.type = eleType;
    if (!Object.prototype.hasOwnProperty.call(desc, "autoFit")) {
      desc.autoFit = autoFitRule;
    }
    TQ.SceneEditor.addItem(desc);
  }

  function getFontSize() {
    return parseFloat(state.fontLevel) * TQ.Config.FONT_LEVEL_UNIT;
  }

  /*
	 直接跳转到第id个场景 (id >=0)
	 */
  function gotoLevel(id) {
    if (state.isAddMode || state.isModifyMode) {
      var level = currScene.currentLevel;
      if (level && !level.isOverlay()) {
        var levelId = currScene.currentLevelId;
        WCY.updateThumbnail(levelThumbs, levelId);
      }
    }
    TQ.Log.debugInfo("gotoLevel " + id);
    if (typeof id === "string") {
      id = Number(id);
    }
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;
    TQ.CommandMgr.reset();
    currScene.gotoLevel(id);
  }

  function gotoPreviousLevel() {
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;

    if (currScene && currScene.currentLevelId > 0) {
      gotoLevel(currScene.currentLevelId - 1);
    }
  }

  function gotoNextLevel() {
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;

    if (currScene && (currScene.currentLevelId !== undefined) && (currScene.currentLevelId < (currScene.levelNum() - 1))) {
      gotoLevel(currScene.currentLevelId + 1);
    }
  }

  /*
	 插入第id(id >=0）个场景， 如果该位置已经有场景， 把原来的场景向后顺延。
	 如果id < 0, 则令id =0;.
	 如果id 超出上边界， 则自动在末尾添加一个场景）
	 */
  function addLevelAt(id) {
    id = Number(id);
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return -1;

    currScene.addLevel(id);
    levelThumbs.splice(currScene.currentLevelId + 1, 0, { src: null, timestamp: Date.now() });
    gotoLevel(id);
    return id;
  }

  /*
	 紧跟当前场景的后面，插入1个新场景。
	 */
  function addLevel() {
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;
    return addLevelAt(currScene.currentLevelId + 1);
  }

  function duplicateCurrentLevel() {
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;
    var nextLevel = currScene.currentLevelId + 1;
    var thumbnail = levelThumbs[currScene.currentLevelId].src;
    currScene.duplicateCurrentLevel();
    levelThumbs.splice(currScene.currentLevelId, 0, { src: thumbnail, timestamp: Date.now() });
    $timeout(function() {
      gotoLevel(nextLevel);
    });
  }

  /*
	 删除第id(id >=0）个场景， 并且把此后的场景前移。
	 如果id超出边界（id < 0)，则忽略
	 */
  function deleteLevel(id) {
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    assertNotNull(id, currScene); // 必须在微创意显示之后使用
    id = Number(id);
    if (!currScene) return;

    if (id === currScene.currentLevelId) {
      deleteCurrentLevel();
    } else {
      doDeleteLevelAndThumbs(id);
    }
  }

  function doDeleteLevelAndThumbs(id) {
    currScene.deleteLevel(id);
    levelThumbs.splice(id, 1);
  }

  function deleteCurrentLevel() {
    if (currScene.levelNum() === 1) {
      // addLevel();
      // $timeout(function() {
      //     deleteLevel(0);
      // });
      return TQ.MessageBox.prompt(TQ.Locale.getStr("at least 1 scene!"));
    }

    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene || (currScene.currentLevelId === undefined)) return;

    var id = currScene.currentLevelId;
    var nextLevel = id + 1;
    if (nextLevel >= currScene.levelNum()) {
      nextLevel = id - 1;
    }
    if (nextLevel < 0) {
      currScene.currentLevel.empty();
      levelThumbs[0] = null;
    } else {
      currScene.gotoLevel(nextLevel);
      $timeout(function() {
        deleteLevel(id);
      });
    }
  }

  /*
	 移动序号为srcId的场景，并插入到序号dstId的场景之前，
	 注意：srcId和dstId都是在执行此函数之前， 按照场景的顺序来编号的。
	 用户不需要关心
	 */
  function moveTo(srcId, dstId) {
    srcId = Number(srcId);
    dstId = Number(dstId);
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;

    currScene.moveTo(srcId, dstId);
  }

  /*
	 复制序号为srcId的场景的内容，并插入到序号dstId的场景之前，
	 */
  function copyTo(srcId, dstId) {
    srcId = Number(srcId);
    dstId = Number(dstId);
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return;

    currScene.copyTo(srcId, dstId);
  }

  /*
	 获取当前微创意的场景（Level）数量
	 */
  function getLevelNum() {
    assertNotNull(TQ.Dictionary.FoundNull, currScene); // 必须在微创意显示之后使用
    if (!currScene) return 0;
    return currScene.levelNum();
  }

  function exitPreview() {
    stop();
    TQ.PreviewMenu.stopWatch();
  }

  function stop() {
    // 新建立的账号，没有currScene，但是调用Stop()？
    // assertTrue(TQ.Dictionary.INVALID_LOGIC, currScene != null);
    if (currScene != null) {
      currScene.stop();
      updateMode();
    }
    TQ.State.isPlaying = false;
    $timeout(function() { // 用timeout迫使angularjs 刷新UI,
      // 只是stop，不涉及修改canvas
    });
  }

  function preview(options) {
    if (TQ.Config.AutoPlay && currScene && !TQ.State.isAddMode) {
      if (!TQ.Scene.ensureFirstClick(function() {
        if (TQUtility.isIOS()) {
          TQ.SoundMgr.iosForceToResumeAll();
          TQ.VideoMgr.iosForceToResumeAll();
        }
        preview(options);
      })) {
        return;
      }
    }

    currScene.updateReadyFlag();
    if (!currScene.isAllDataReady()) {
      document.addEventListener(TQ.Scene.EVENT_ALL_DATA_READY, onAllDataReady);
      TQ.OverlayMask.turnOn(null, "请稍候，正在准备数据...");
      function onAllDataReady() {
        document.removeEventListener(TQ.Scene.EVENT_ALL_DATA_READY, onAllDataReady);
        TQ.OverlayMask.turnOff();
      }
    }

    TQ.MessageBox.reset();
    WCY.stopAutoSave();
    TQ.SoundMgr.reset();
    TQ.VideoMgr.reset();
    TQ.SelectSet.empty(); // 清楚选中的元素， 和highlight
    setPreviewMode();
    state.requestToRecordAudio = false; // 在preview的时候，清除
    replay(options);
  }

  function previewCurrentLevel() {
    preview({ thisLevelOnly: true });
  }

  function play() {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, currScene != null);
    if (currScene != null) {
      currScene.play();
    }
    _onPlay();
  }

  function pause() {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, currScene != null);
    if (currScene != null) {
      TQ.FrameCounter.pause();
    }
  }

  function resume() {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, currScene != null);
    if (currScene != null) {
      TQ.FrameCounter.resume();
    }
  }

  function _onPlay() {
    updateMode();
    forceToRefreshUI();
    if (TQ.TouchManager && TQ.TouchManager.hasStarted()) {
      TQ.TouchManager.stop();
    }
    TQ.State.isPlaying = true;
    $timeout(function() { // 用timeout跳过本次touch的end或mouse的up引起的事件
      AppService.configCanvas();
    }, 100);
    TQ.IdleCounter.start(TQ.PreviewMenu.hide);
    TQ.PreviewMenu.startWatch();
  }

  function replay(option) {
    TQ.SoundMgr.reset();
    TQ.VideoMgr.reset();
    TQ.Scene.doReplay(option);
    _onPlay();
  }

  function startRecord() {
    TQ.FrameCounter.startRecord();
    TQ.SceneEditor.setPlayMode();
  }

  function stopRecord() {
    TQ.FrameCounter.stopRecord();
    TQ.SceneEditor.setEditMode();
  }

  function emptyScene() {
    TQ.SelectSet.empty();
    if (currScene) {
      TQ.SceneEditor.emptyScene();
      currScene.selectLevel(0);
      currScene.showLevel();
      currScene.start();
      $timeout(syncLevelThumbs);
    }
  }

  function doPlayStop() {
    if (TQ.FrameCounter.isPlaying()) {
      stop();
    } else {
      play();
    }
  }

  // 进入/退出 全屏模式
  function fullscreenPlay(width, height) { // 屏幕分辨率的大小
    canvas = TQ.Graphics.getCanvas();
    canvas.width = Math.round(width);
    canvas.height = Math.round(height);

    TQ.Config.zoomX = width / TQ.Config.workingRegionWidth;
    TQ.Config.zoomY = height / TQ.Config.workingRegionHeight;
    TQ.Config.workingRegionWidth = width;
    TQ.Config.workingRegionHeight = height;
    play();
  }

  function eixtFullscreen() {
    TQ.Graphics.setCanvas();
    TQ.Config.zoomX = TQ.Config.zoomY = 1;
  }

  function setWorkingRegion(w, h, asDefault) {
    if (currScene) {
      currScene.setDesignatedSize({ w: w, h: h });
    }

    if (asDefault) {
      state.designatedWidth = w;
      state.designatedHeight = h;
    }

    $timeout(onResize);
  }

  function setBackgroundColor(bkgColor, asDefault) {
    if (currScene) {
      currScene.backgroundColor = bkgColor;
    }

    if (asDefault) {
      state.backgroundColor = bkgColor;
    }

    $timeout(onResize);
  }

  // ------------- 以下的函数用于配置系统参数 -------------------------
  // 设置零件标志的大小， 默认是10：
  function setMarkerSize(radius) {
    TQ.Marker.RADIUS = radius;
  }

  function setFontLevel(level) {
    var selectedElement = TQ.SelectSet.peek();
    if (selectedElement && selectedElement.isText()) {
      state.fontLevel = level;
      TQ.CommandMgr.directDo(new TQ.SetSizeCommand(selectedElement, getFontSize()));
    }
  }

  function setTextProperty(ele, option) {
    TQ.CommandMgr.directDo(TQ.CommandMgr.setTextProperty(ele, option));
  }

  function increaseFontLevel() {
    var selectedElement = TQ.SelectSet.peek();
    if (selectedElement && selectedElement.isText()) {
      state.fontLevel = TQ.Utility.fontSize2Level(selectedElement.getFontSize());
      state.fontLevel++;
      setFontLevel(state.fontLevel);
    }
  }

  function decreaseFontLevel() {
    var selectedElement = TQ.SelectSet.peek();
    if (selectedElement && selectedElement.isText()) {
      state.fontLevel = TQ.Utility.fontSize2Level(selectedElement.getFontSize());
      if (state.fontLevel >= 1) {
        state.fontLevel--;
        setFontLevel(state.fontLevel);
      }
    }
  }

  function turnOnTrim() {
    state.showTrimTimeline = true;
    TQ.TimerUI.rangeSlider.maxValue = TQ.TimerUI.rangeSlider.minValue;
    forceToRenderSlider();
    $timeout(forceToRenderSlider, 100);
  }

  function trim() {
    if (!TQ.Utility.preventDither()) {
      return;
    }
    console.warn("TRIM command: ...", tObj1, tObj2);
    var selectedElement = TQ.SelectSet.peek();
    var tObj1 = TQ.TimerUI.getTObject1();
    var tObj2 = TQ.TimerUI.getTObject2();
    var tTemp;

    if ((tObj1.levelId > tObj2.levelId) ||
      ((tObj1.levelId === tObj2.levelId) && (tObj1.t > tObj2.t))) {
      tTemp = tObj1;
      tObj1 = tObj2;
      tObj2 = tTemp;
    }

    TQ.MessageBox.prompt("This operation is not revertable, Are you sure? <br/>Apply to all objects", function() {
      $timeout(onOK);
    }, turnOffTrim);

    function onOK() {
      console.warn("TRIM: onOK...", tObj1, tObj2);
      // if (selectedElement && (tObj1.levelId === tObj2.levelId)) {
      //    selectedElement.trim(tObj1.t, tObj2.t);
      // } else

      if (currScene && currScene.currentLevel) {
        doTrim(tObj1, tObj2);
      }
      turnOffTrim();
    }
  }

  function turnOffTrim() {
    state.showTrimTimeline = false;
    TQ.TimerUI.rangeSlider.maxValue = TQ.TimerUI.rangeSlider.minValue;
    forceToRenderSlider();
    $timeout(forceToRenderSlider, 100);
  }

  function doTrim(tObj1, tObj2) {
    console.warn("TRIM: ...", tObj1, tObj2);
    var MAX_LENGTH = 99999.0;
    var leftLevel, rightLevel;
    if (tObj1.levelId === tObj2.levelId) {
      leftLevel = currScene.getLevel(tObj1.levelId);
      leftLevel.trim(tObj1.t, tObj2.t);
    } else {
      rightLevel = currScene.getLevel(tObj2.levelId);
      rightLevel.trim(0, tObj2.t);
      TQ.DirtyFlag.setLevel(rightLevel);
      rightLevel.calculateLastFrame();
      rightLevel.calculateRealLastFrame();
      var levelId = tObj2.levelId - 1;
      while (levelId > tObj1.levelId) {
        doDeleteLevelAndThumbs(levelId);
        levelId--;
      }
      leftLevel = currScene.getLevel(levelId);
      leftLevel.trim(tObj1.t, MAX_LENGTH);
    }

    TQ.TimerUI.onTrimCompleted();
    TQ.FrameCounter.trim(tObj1, tObj2);
    TQ.DirtyFlag.setLevel(leftLevel);
    leftLevel.calculateLastFrame();
    leftLevel.calculateRealLastFrame();
    if (rightLevel) {
      TQ.DirtyFlag.setLevel(rightLevel);
      rightLevel.calculateLastFrame();
      rightLevel.calculateRealLastFrame();
    }
    currScene.currentLevel.setTime(TQ.FrameCounter.maxTime());
  }

  function increaseTimeline() {
    var level = currScene.currentLevel;
    level.increaseTime();
    level.calculateLastFrame();
    level.calculateRealLastFrame();
    $timeout(forceToRenderSlider, 100);
  }

  function decreaseTimeline() {
    var level = currScene.currentLevel;
    level.decreaseTime();
    level.calculateLastFrame();
    level.calculateRealLastFrame();
    $timeout(forceToRenderSlider, 100);
  }

  function setSize() {
    var selectedElement = TQ.SelectSet.peek();
    if (selectedElement && selectedElement.isText()) {
      TQ.CommandMgr.directDo(new TQ.SetSizeCommand(selectedElement, getFontSize()));
    }
  }

  function updateColorPanel() {
    if (_colorPanel) {
      _colorPanel.style.color = state.color;
    }
  }

  function setColor(colorPicker) {
    if ((typeof colorPicker === "string") && colorPicker[0] === "#") {
      state.color = colorPicker;
    } else {
      state.color = "#" + colorPicker.toString();
    }
    updateColorPanel();
    var selectedElement = TQ.SelectSet.peek();
    if (selectedElement && selectedElement.isText()) {
      TQ.CommandMgr.directDo(new TQ.SetColorCommand(selectedElement, state.color));
    }
  }

  function pinIt() {
    TQ.SelectSet.pinIt();
    updateMode();
  }

  function attachTextBubble() {
    TQ.TextBubble.attachTo();
    updateMode();
  }

  function detachTextBubble() {
    TQ.TextBubble.detachFrom();
    updateMode();
  }

  function hideOrShow() {
    TQ.SelectSet.show(false);
    updateMode();
  }

  // for bottom bar;
  function emptySelectSet() {
    TQ.SelectSet.empty();
    TQ.DirtyFlag.setScene();
    updateMode();
  }

  // private
  function initialized() {
    return (currScene && currScene.currentLevel !== undefined);
  }

  function isEditMode() {
    return (initialized() && TQ.SceneEditor.isEditMode());
  }

  function onAddModeDone(callback) {
    addModeDoneCallback = callback;
  }

  function toAddMode(options) {
    if (TQ.FrameCounter.isPlaying() && currScene) {
      currScene.stop();
    }

    $timeout(function() {
      // 在Preview stop之后，一些event尚未处理完成，所以，通过timeout，resetState
      TQ.Scene.restoreState(options);
      TQ.SceneEditor.setMode(TQBase.LevelState.EDITING);
      TQ.SelectSet.empty();
      if (state.isPreviewMode) {
        state.isPreviewMode = false;
        TQ.IdleCounter.remove(onPreviewMenuOff);
        onPreviewMenuOff();
        TQ.PreviewMenu.stopWatch();
      }
      updateMode(true);
      TQ.State.isPlaying = false;
      AppService.configCanvas();
      forceToRefreshUI();
      $timeout(function() { // 在UI（top bar等）更新之后，必须重新计算canvas大小，
        AppService.configCanvas();
        forceToRefreshUI();
        if (!currScene.isEmpty() && currScene.levelNum() > levelThumbs.length) {
          $timeout(syncLevelThumbs);
        } else {
          toAddModeDone(options);
        }
      });
    }, 100);
  }

  function syncLevelThumbs() {
    // quick fill, to void undefined element in ng repeat;
    var nowTimestamp = Date.now();
    for (var i = 0; i < currScene.levelNum(); i++) {
      if (!levelThumbs[i]) {
        levelThumbs[i] = { src: null, timestamp: i + nowTimestamp };
      }
    }
    TQ.OverlayMask.turnOn(null, "请稍候,正在生成缩略图...");
    doSyncLevelThumbs();
  }

  function doSyncLevelThumbs() {
    if (!currScene.isAllResourceReady()) {
      return $timeout(doSyncLevelThumbs, 200);
    }
    TQ.AssertExt.invalidLogic(currScene.isAllResourceReady(), "有level没有完全加载，不能调用");
    TQ.State.allowPageTransition = false;

    makeOneThumb(currScene.levelNum() - 1);

    function makeOneThumb(levelId) {
      for (; levelId >= 0; levelId--) {
        if (!levelThumbs[levelId] || !levelThumbs[levelId].src) {
          var level = currScene.getLevel(levelId);
          if (level.isActive() && level.isShowing()) {
            WCY.updateThumbnail(levelThumbs, levelId);
          } else {
            document.addEventListener(TQ.Level.EVENT_START_SHOWING, handleNextLevel);
            gotoLevel(levelId);
            break;
          }
        }
      }

      if (levelId < 0) {
        TQ.OverlayMask.turnOff();
        toAddModeDone();
        return;
      }

      function handleNextLevel(evt) {
        if (evt.data.levelId === "Overlay") {
          return;
        }
        var idShowing = parseInt(evt.data.levelId);
        document.removeEventListener(TQ.Level.EVENT_START_SHOWING, handleNextLevel);
        if (TQ.PageTransitionEffect.isBusy()) { // 防止再次进入
          document.addEventListener(TQ.PageTransitionEffect.EVENT_COMPLETED, onPageTransitionCompleted);
          function onPageTransitionCompleted() {
            document.removeEventListener(TQ.PageTransitionEffect.EVENT_COMPLETED, onPageTransitionCompleted);
            makeOneThumb(idShowing - 1);
          }
        } else {
          makeOneThumb(idShowing - 1);
        }
      }
    }
  }
  function toAddModeDone(options) {
    var levelId = (options && options.levelId) ? options.levelId : 0;
    $timeout(function() {
      gotoLevel(levelId);
      $timeout(function() {
        gotoLevel(levelId);
        WCY.startAutoSave();
        TQ.State.allowPageTransition = true;
        TQ.State.isPlayOnly = false;
        updateControllers();
        AppService.configCanvas(); // 以防随动按钮出界，此时工具条都显示了，再更新一次工作区size
        if (addModeDoneCallback) {
          addModeDoneCallback();
        }
        // TQ.VideoMgr.resize();
      }, 500);
    }, 500);
  }

  function setPreviewMode() {
    state.isPreviewMode = true;
    state.isAddMode = false;
    state.isModifyMode = false;
  }

  function forkIt() {
    WCY.forkIt();
    toAddMode();
  }

  function setColorPanel(domPanel) {
    if (!domPanel) {
      _colorPanel = domPanel;
    }
  }

  function setAddMode() {
    state.isModifyMode = false;
    state.isAddMode = true;
    state.isPreviewMode = false;
    forceToRefreshUI();
  }

  function setModifyMode() {
    state.isModifyMode = true;
    state.isAddMode = false;
    state.isPreviewMode = false;
    forceToRefreshUI();
  }

  function updateMode(hasChanged) {
    var value = null;

    if (state.isRecording) {
      return;
    }

    if (!state.isPreviewMode) {
      if (state.isAddMode !== (value = (isEditMode() && TQ.SelectSet.isEmpty()))) {
        state.isAddMode = value;
        hasChanged = true;
      }

      if (state.isModifyMode !== (value = (isEditMode() && !TQ.SelectSet.isEmpty()))) {
        state.isModifyMode = value;
        hasChanged = true;
      }

      if (state.isPlayMode !== (value = (initialized() && TQ.SceneEditor.isPlayMode()))) {
        state.isPlayMode = value;
        hasChanged = true;
        updatePlayingState();
      }
    } else {
      setPreviewMode();
      state.isPlayMode = false;
      updatePlayingState();
      hasChanged = true;
    }

    // 对sceneReady 事件， SelectSet是空
    if (!TQ.SelectSet.isEmpty()) {
      hasChanged = updateElementState() || hasChanged;
    }

    //  force angular to update UI
    if (hasChanged) {
      forceToRefreshUI();
    }
  }

  function updatePlayingState() {
    // 不能用$timeout, 因为DOM的SCENE_READY调用时候， $timeout可能为undefined
    if (!$timeout) {
      setTimeout(doUpdate, 300);
    } else {
      $timeout(doUpdate, 300);
    }

    function doUpdate() {
      if (TQ.State.isPlaying !== TQ.FrameCounter.isPlaying()) {
        TQ.State.isPlaying = TQ.FrameCounter.isPlaying();
        AppService.configCanvas();
      }
    }
  }

  function updatePosition(ele) {
    if ((ele !== _lastSelected) || (_lastSelected == null)) {
      if (_lastSelected && !!_lastSelected.hookInMove) {
        _lastSelected.hookInMove = null;
      }
      _lastSelected = ele;
      if (_lastSelected) {
        _lastSelected.hookInMove = updatePosition;
      }
    }

    if (ele) {
      var pos = ele.getPositionInWorld();
      state.x = pos.x;
      state.y = pos.y;
    }
  }

  function getTextCursor() {
    var x = TQ.MathExt.range(state.x, 0, 0.9);
    var y = state.y;
    var fontHeight = getFontSize() / TQ.Config.workingRegionHeight;

    if (_lastSelected && _lastSelected.isText()) {
      y -= fontHeight;
    }

    if (y < (2 * fontHeight)) {
      y = 1; // go to top again;
    }

    return { x: x, y: y };
  }

  function updateElementState() {
    var hasChanged = false;
    var ele = TQ.SelectSet.peek();
    TQ.AssertExt.isNotNull(ele);
    updatePosition(ele);
    if (ele && state.isModifyMode) {
      if (state.isLocked !== ele.isPinned()) {
        state.isLocked = ele.isPinned();
        hasChanged = true;
      }

      if (state.isVisible !== ele.isVisible()) {
        state.isVisible = ele.isVisible();
        hasChanged = true;
      }

      if (state.color !== ele.getColor()) {
        state.color = ele.getColor();
        updateColorPanel(state.color);
        hasChanged = true;
      }

      if (ele.getType() === TQ.ElementType.TEXT) {
        var level = TQ.Utility.fontSize2Level(ele.getFontSize());
        if (!TQ.Utility.equalWithin2(state.fontLevel, level)) {
          state.fontLevel = level;
          hasChanged = true;
        }

        if (!state.isFont) {
          state.isFont = true;
          hasChanged = true;
        }
        if (state.isFont) {
          if (state.hasBubble !== ele.hasBubble()) {
            state.hasBubble = ele.hasBubble();
            hasChanged = true;
          }
        }
      } else {
        if (state.isFont) {
          state.isFont = false;
          hasChanged = true;
        }
      }
    }

    return hasChanged;
  }

  function forceToRefreshUI() {
    if (!$timeout) {
      setTimeout(null);
    } else {
      $timeout(null);
    }
  }

  function forceToRedraw() {
    if (currScene) {
      currScene.isDirty = true; // 迫使IPad系统重新绘制canvas上的图像， 否则，屏幕上是空白
    }
    forceToRefreshUI();
  }

  function onDelete(evt) {
    if (TQ.SelectSet.isEmpty()) {
      // TQ.MessageBox.show(TQ.Locale.getStr('are you sure to delete it?'), deleteCurrentLevel);
      deleteCurrentLevel();
    } else {
      // 删除当前选中的元素
      evt.stopPropagation();
      evt.preventDefault();
      TQBase.LevelState.saveOperation(TQBase.LevelState.OP_FLOATTOOLBAR);
      TQ.SelectSet.delete();
    }
  }

  function deleteSound(ele) {
    TQ.AssertExt.isNotNull(ele);
    if (ele) {
      ele.stop();
      TQ.CommandMgr.directDo(new TQ.DeleteEleCommand(currScene, ele));
    }
  }

  function deleteDub() {
    var dubs;
    if (currScene && currScene.currentLevel) {
      dubs = currScene.currentLevel.findAllDub();
    }
    if (dubs) {
      dubs.forEach(deleteSound);
    }
  }

  function changeSkin(newSkinUrl, onChanged) {
    if (TQ.SelectSet.isEmpty()) {
      TQ.MessageBox.show(TQ.Locale.getStr("select the element to be changed!"));
      return null;
    }

    var ele = TQ.SelectSet.peekLatestEditableEle();
    if (ele.isPinned()) {
      TQ.MessageBox.prompt(TQ.Locale.getStr("the object is locked, continue?"), function() {
        TQ.CommandMgr.pinIt(ele);
        changeSkin(newSkinUrl, onChanged);
      });
      return ele;
    }

    if (ele.isBitmap()) {
      ele.changeSkin(newSkinUrl, onChanged);
    }

    return ele;
  }

  function shareFbWeb() {
    if (isSharingToFB) {
      console.error("系统正在忙。。。。");
      return;
    }

    if (!WCY.getShareCode()) {
      isSharingToFB = true;
      if (WCY.hasSsPath()) {
        return WCY.save().then(doIt);
      }
      return WCY.uploadScreenshot().then(doItAndSave);
    }

    function doItAndSave() {
      WCY.save();
      doIt();
    }

    function doIt() {
      isSharingToFB = false;
      shareFbWeb();
    }

    var spaUrl = TQUtility.urlConcat(TQ.Config.OPUS_HOST_FB, "?opus=" + WCY.getShareCode());
    var staticUrl = TQUtility.urlConcat(TQ.Config.OPUS_HOST_FB_STATIC, "/opus/" + WCY.getShareCode() + ".html");
    var screenshotUrl = WCY.getScreenshotUrl();
    var redirectUrlParams = "";
    var linkParams = ""; // '?play=true'

    // ToDo: （需要去掉page中的tag吗？）
    // "share" 需要page中的tag支持，
    // "feed", 不需要
    WCY.createHtmlPage(screenshotUrl).then(doFbShare);

    function doFbShare() {
      FB.ui(
        {
          app_id: "273410813018932",
          method: "feed",
          name: "A Picture is Worth a Thousand Words -- idiom",
          redirect_uri: staticUrl + redirectUrlParams,
          link: staticUrl + linkParams,
          message: "" // not supported by FB?
          // picture, description, captions 等废弃了，--- Jul 17, 2017
        });
    }
  }

  function onEventByToolbar(evt) {
    if (evt) {
      evt.preventDefault();
      evt.stopPropagation();
    }

    // 结束批命令:
    if (state.isMCopying) {
      if ((lastCmd === CMD_MCOPYING_BEGIN) && (currCmd !== CMD_MCOPYING_END)) {
        mCopyToggle();
      }
    }

    lastCmd = currCmd;
    currCmd = CMD_UNKNOWN;

    // ToDo: Joint, group
  }
}

/**
 * Created by Andrewz on 6/25/2016.
 */

function DataObject(list) {
  var IMAGE_PAGE_SIZE = 6;
  var SOUND_PAGE_SIZE = 4;
  var LARGE_PAGE_SIZE = 20000;
  var vm = this;
  var bakCurrentPageId = 0;
  var currentPageId = 0;
  var pages = [];

  // interface
  vm.getPage = getPage;
  vm.setList = setList;

  // init
  if (list) {
    // setList(list);
  }

  reset();

  function reset() {
    var page = null;

    if (pages.length >= 1) {
      pages.splice(1, pages.length - 1);
      page = pages[0];
    } else {
      page = createPage();
    }

    if (page.length >= 1) {
      page.splice(0);
    }

    currentPageId = 0;
  }

  function createPage() {
    var page = [];
    page.parent = vm;
    page.previousPage = getPreviousPage;
    page.nextPage = getNextPage;
    pages.push(page);
    return page;
  }

  // implementations (按照字母顺序排列，升序)
  function fixup(items, matType) {
    for (let i = 0; i < items.length; i++) {
      if (items[i].extra) {
        items[i].extra = JSON.parse(items[i].extra);
      }
      if (!items[i].isProxy) {
        var oldPath = (matType === TQ.MatType.TOPIC) ? items[i].posterPicturePath
          : items[i].path;
        if (oldPath === "/undefined") {
          oldPath = null;
        }
        if (!oldPath) {
          items[i].thumbPath = null;
          items[i].path = null;
        } else {
          if (TQ.Utility.isSoundResource(oldPath)) { // force to convert to mp3
            oldPath = TQ.Utility.forceExt(oldPath, ".mp3");
          } else if (!TQ.Utility.isImage(oldPath) && !TQ.Utility.isVideo(oldPath)) {
            TQ.Log.error("Found unknown format:" + oldPath);
          }
          if (matType === TQ.MatType.OPUS) {
            if (items[i].thumbPath === undefined) {
              items[i].thumbPath = TQ.RM.toOpusThumbNailFullPath(oldPath);
            }
          } else {
            items[i].thumbPath = TQ.RM.toMatThumbNailFullPath(oldPath);
          }

          items[i].path = TQ.RM.toFullPathFs(oldPath);
        }
      }
    }
  }

  function getPage(step) {
    updatePageId(step);
    if (pages.length < 1) {
      TQ.AssertExt.invalidLogic(false, "应该有初始值！");
      return null;
    }
    bakCurrentPageId = currentPageId;
    return pages[currentPageId];
  }

  function getPreviousPage() {
    return getPage(-1);
  }

  function getNextPage() {
    return getPage(1);
  }

  function prepareColumn(props_local, pageSize) {
    var page = pages[pages.length - 1];

    for (let i = 0; i < props_local.length; i++) {
      if (page.length >= pageSize) {
        page = createPage();
      }

      if (page.indexOf(props_local[i]) < 0) {
        page.push(props_local[i]);
      }
    }
  }

  function updatePageId(step) {
    if (!step) {
      step = 0;
    }

    switch (step) {
      case -2:
        currentPageId = 0;
        break;
      case 2:
        currentPageId = pages.length;
        break;
      case -1:
      case 1:
        currentPageId += step;
        break;
      case 0:
      default :
        break;
    }

    currentPageId = TQ.MathExt.clamp(currentPageId, 0, pages.length - 1);
  }

  function setList(list, matType) {
    reset();
    if (TQ.Config.LocalCacheEnabled) {
      TQ.DownloadManager.downloadBulk(list);
    } else {
      fixup(list, matType);
    }
    prepareColumn(list, (matType === TQ.MatType.SOUND ? SOUND_PAGE_SIZE : (matType === TQ.MatType.OPUS ? LARGE_PAGE_SIZE : IMAGE_PAGE_SIZE)));

    currentPageId = bakCurrentPageId;
    updatePageId();
  }
}

DataObject.IMAGE_PAGE_SIZE = 9;
TQ.DataObject = DataObject;

/**
 * Created by Andrewz on 7/10/2016.
 */

angular.module("starter").factory("MatLibService", MatLibService);
MatLibService.$inject = ["$http"];

function MatLibService($http) {
  var buffer = [];

  return {
    getProps: getProps
  };

  function getProps(keyword) {
    if (!buffer[keyword]) {
      buffer[keyword] = new TQ.DataObject();
      search(keyword);
    }
    var pageStep = 0;
    return buffer[keyword].getPage(pageStep);
  }

  function search(keyword) {
    $http({
      method: "GET",
      url: "https://openclipart.org//search/json/?query=" + keyword + "&amount=20&page=0&sort=downloads"
    }).then(onReceived);

    function onReceived(pkg) {
      var list = [];

      if ((pkg.status === 200) &&
                (pkg.data.msg === "success") &&
                (pkg.data.info.results > 0) &&
                (pkg.data.payload)) {
        pkg.data.payload.forEach(convert);
        buffer[keyword].setList(list);
      }

      function convert(item) {
        list.push({
          isProxy: true,
          tags: item.tags,
          thumbPath: item.svg.png_thumb,
          path: item.svg.png_full_lossy
        });
      }
    }
  }
}

/**
 * Created by admin on 10/3/2015.
 * Data Service： 从 network获取素材，提供给系统使用。避免重复network传输
 * 共用于 播放和创作
 */

(function() {
  angular.module("starter").factory("DataService", DataService);
  DataService.$inject = ["$rootScope", "$http"];
  function DataService($rootScope, $http) {
    var readCacheWithParse = TQ.Base.Utility.readCacheWithParse;
    var writeCache = TQ.Base.Utility.writeCache;
    var initialized = false;
    var MY_WORKS = "_myWorks_";
    var EVENT_TOPIC_READY = "topic ready";
    var EVENT_DATA_READY = "data ready";
    var READY_BKG_IMAGE = 0x01;
    var READY_PROP_IMAGE = 0x02;
    var READY_PEOPLE_IMAGE = 0x04;
    var READY_SOUND = 0x08;
    var READY_OPUS = 0x10;
    var READY_PUBLISHED_OPUS = 0x20;
    var READY_FINE_OPUS = 0x40;
    var READY_ALL = READY_BKG_IMAGE | READY_PROP_IMAGE | READY_PEOPLE_IMAGE | READY_SOUND |
                READY_OPUS | READY_PUBLISHED_OPUS | READY_FINE_OPUS;
    var state = 0;
    var options = {
      requestAll: false
    };
    var workCounter = 0;

    // 在手机上，图片必须使用相对路径， 不能使用绝对路径！！！
    var propsLocal = new TQ.DataObject();

    var propsAlbum = new TQ.DataObject();

    var propsCamera = new TQ.DataObject();

    var propsPeople = new TQ.DataObject();

    var propsBackground = new TQ.DataObject();

    var sounds = new TQ.DataObject();
    var topics = new TQ.DataObject();

    var myOpus = new TQ.DataObject(); // only my opus
    var latestOpus = new TQ.DataObject(); // latest published
    var fineOpus = new TQ.DataObject(); // latest fine opus

    function cloneWork(work) {

    }

    function generateUUID() {
      var id = workCounter;
      workCounter++;
      writeCache("workCounter", workCounter);
      return id;
    }

    function toWcyName(uuid) {
      return TQ.Config.WORKS_CORE_PATH + uuid + ".wcy";
    }

    function toScreenshotName(uuid) {
      return TQ.Config.SCREENSHOT_CORE_PATH + uuid + ".png";
    }

    function getProps(type, pageStep) {
      switch (type) {
        case TQ.MatType.SOUND:
          return sounds.getPage(pageStep);
        case TQ.MatType.PROP:
          return propsLocal.getPage(pageStep);
        case TQ.MatType.ALBUM:
          TQ.AssertExt.depreciated("ALBUM");
          return propsAlbum.getPage(pageStep);
        case TQ.MatType.CAMERA:
          TQ.AssertExt.depreciated("CAMERA");
          return propsCamera.getPage(pageStep);
        case TQ.MatType.PEOPLE:
          return propsPeople.getPage(pageStep);
        case TQ.MatType.BKG:
          return propsBackground.getPage(pageStep);
        case TQ.MatType.OPUS:
          return myOpus.getPage(pageStep);
        case TQ.MatType.PUBLISHED_OPUS:
          return latestOpus.getPage(pageStep);
        case TQ.MatType.FINE_OPUS:
          return fineOpus.getPage(pageStep);
        case TQ.MatType.TOPIC:
          return topics.getPage(pageStep);
        default :
          console.error("资源类别参数错误");
          return propsLocal.getPage(pageStep);
      }
    }

    function getSounds(pageStep) {
      return sounds.getPage(pageStep);
    }

    function getTopics(pageStep) {
      return topics.getPage(pageStep);
    }

    function loadTopics() {
      var url = TQ.Config.OPUS_HOST + "/topic/list";
      $http.get(url).then(function(response) {
        console.log(response);
        var data = (response.status === 200) ? response.data : [];
        if ((typeof data === "string") && (data.startsWith("db error"))) {
          TQ.MessageBox.confirm("(code=8003): " + TQ.Locale.getStr(
            "network connection failed, please check network availability"));
          data = [];
        }

        if (!Array.isArray(data)) {
          data = [];
        }

        topics.setList(data, TQ.MatType.TOPIC);
        $rootScope.$broadcast(EVENT_TOPIC_READY);
      },
      function(reason) {
        console.log(reason);
      });
    }

    function initialize() {
      if (initialized) {
        return;
      }
      initialized = true;
      document.addEventListener(TQ.EVENT.MAT_CHANGED, onMatChanged, false);
      onMatChanged();
    }

    function onMatChanged(event) {
      var matType = null;
      if (!!event && event.data && event.data.matType) {
        matType = event.data.matType;
      }

      if (!TQ.userProfile.loggedIn) {
        reloadSharedData(matType);
      } else {
        reload(matType);
      }
    }

    function reload(matType, ignorePlayFlag) { // 用于 登录之后的刷新
      if (!ignorePlayFlag && TQ.State.isPlayOnly) {
        return onDataReady();
      }

      if (TQ.userProfile.loggedIn) {
        if (!matType || (matType === TQ.MatType.BKG)) {
          state &= (~READY_BKG_IMAGE);
          getMatList(propsBackground, TQ.MatType.BKG, READY_BKG_IMAGE);
        }

        if (!matType || (matType === TQ.MatType.PROP)) {
          state &= (~READY_PROP_IMAGE);
          getMatList(propsLocal, TQ.MatType.PROP, READY_PROP_IMAGE);
        }

        if (!matType || (matType === TQ.MatType.PEOPLE)) {
          state &= (~READY_PEOPLE_IMAGE);
          getMatList(propsPeople, TQ.MatType.PEOPLE, READY_PEOPLE_IMAGE);
        }
        if (!matType || (matType === TQ.MatType.SOUND)) {
          state &= (~READY_SOUND);
          getMatList(sounds, TQ.MatType.SOUND, READY_SOUND);
        }
        if (!matType || (matType === TQ.MatType.OPUS)) {
          state &= (~READY_OPUS);
          getOpusList(myOpus, TQ.MatType.OPUS, READY_OPUS);
        }
      }
      reloadSharedData(matType, ignorePlayFlag);
    }

    function reloadSharedData(matType, ignorePlayFlag) {
      if (!ignorePlayFlag && TQ.State.isPlayOnly) {
        return onDataReady();
      }

      if (!matType || (matType === TQ.MatType.PUBLISHED_OPUS)) {
        state &= (~READY_PUBLISHED_OPUS);
        getOpusList(latestOpus, TQ.MatType.PUBLISHED_OPUS, READY_PUBLISHED_OPUS);
      }
      if (!matType || (matType === TQ.MatType.FINE_OPUS)) {
        state &= (~READY_FINE_OPUS);
        getOpusList(fineOpus, TQ.MatType.FINE_OPUS, READY_FINE_OPUS);
      }

      if (!matType || (matType === TQ.MatType.TOPIC)) {
        loadTopics();
      }
    }

    function getMatList(mats, matType, stateType) {
      var topicId = TQ.Utility.getTopicId();
      var requestAll = (!topicId) || (topicId <= 0) || options.requestAll;
      $http({
        method: "GET",
        url: TQ.Config.MAN_HOST + "/material/list/" + matType + "/topic/" + topicId + "/option/" + requestAll
      }).then(onSuccess);

      function onSuccess(response) {
        var data = (response.status === 200) ? response.data : [];
        if (!Array.isArray(data)) {
          data = [];
        }
        mats.setList(data, matType);
        state |= stateType;
        if (state === READY_ALL) {
          onDataReady();
        }
      }
    }

    function getOpusList(mats, matType, stateType) {
      var opusDetail = "";
      switch (matType) {
        case TQ.MatType.PUBLISHED_OPUS: // 已经发表的作品，所有人的， 只有admin可以view。
          opusDetail = "latest";
          break;
        case TQ.MatType.FINE_OPUS: // 已经推荐的优秀作品，所有人都可见。
          opusDetail = "fine";
          break;
        default:
          opusDetail = ""; // “我的”作品：除了ban的都返回
          // 对管理员： 所有人的
          // 对普通用户： 只是自己的，不包括他人的
          break;
      }

      var selected = [];

      function getPageList(pageId) {
        $http({
          method: "GET",
          url: TQ.Config.OPUS_HOST + "/wcyList/page/" + pageId
        }).then((response) => {
          var listLength = onSuccess(response);
          if (listLength >= 10) {
            pageId++;
            getPageList(pageId);
          }
        })
          .catch(response => {
            onFail(response);
          });
      }

      if (opusDetail === "") {
        var pageId = 1;
        getPageList(pageId);
      } else {
        $http({
          method: "GET",
          url: TQ.Config.OPUS_HOST + "/wcyList/" + opusDetail
        }).then(onSuccess, onFail);
      }

      function onSuccess(response) {
        var data = (response.status === 200) ? response.data : [];

        if ((typeof data === "string") && (data.startsWith("db error"))) {
          TQ.MessageBox.confirm("(code=8003): " + TQ.Locale.getStr(
            "network connection failed, please check network availability"));
          data = [];
        }

        if (!Array.isArray(data)) {
          data = [];
        }

        data.forEach(function(item) {
          var itemCopy = TQUtility.shadowCopy(item);
          itemCopy.wcyId = item._id;
          itemCopy.path = item.ssPath;
          itemCopy.title = item.title || "我有一个梦"; // ToDo: 允许用户录入主题， 或系统设置竞赛的主题
          itemCopy.score = (!item.score ? 1000 : item.score); // 起点，（只有创作了作品，系统给你1000点， 然后实时统计
          itemCopy.userAge = (!itemCopy.userAge) ? 8 : itemCopy.userAge;
          itemCopy.city = TQ.userProfile.city;
          selected.push(itemCopy);
        });
        var items = [...selected];
        mats.setList(items, matType);
        state |= stateType;
        if (state === READY_ALL) {
          onDataReady();
        }

        return data.length;
      }

      function onFail(response) {
        var data = (response.status === 200) ? response.data : [];

        mats.setList(selected, matType);
        state |= stateType;
        if (state === READY_ALL) {
          onDataReady();
        }
        if (!TQ.MessageBox.hasCriticalError()) {
          TQ.MessageBox.confirm("(code=8002): " +
            TQ.Locale.getStr("network connection failed, please check network availability"));
        }
      }
    }

    function onDataReady() {
      workCounter = readCacheWithParse("workCounter", 0);
      TQ.Log.checkPoint("DataService.EVENT_DATA_READY");
      $rootScope.$broadcast(EVENT_DATA_READY);
    }

    function setup(newOptions) {
      TQUtility.extendWithoutObject(options, newOptions);
    }

    return {
      EVENT_TOPIC_READY: EVENT_TOPIC_READY,
      EVENT_DATA_READY: EVENT_DATA_READY,
      initialize: initialize,
      setup: setup,
      getProps: getProps,
      getSounds: getSounds,
      getTopics: getTopics,
      cloneWork: cloneWork,
      generateUUID: generateUUID,
      loadTopics: loadTopics,
      reload: reload,
      toScreenshotName: toScreenshotName,
      toWcyName: toWcyName
    };
  }
})();

/**
 * Created by Andrewz on 4/19/2017.
 */

angular.module("starter").factory("UserService", UserService);
UserService.$inject = ["$http", "$auth"];
function UserService($http, $auth) {
  var user = TQ.userProfile;
  var userList = [];

  function canAutoLogin() {
    return $auth.isAuthenticated();
  }

  function tryAutoLogin() {
    TQ.AssertExt.invalidLogic(canAutoLogin(), "must call canAutoLogin to determine");
    return getProfile();
  }

  function tryAutoSignUp() {
    var name = "guest" + (new Date()).getTime();
    return signUp(name, name, name);
  }

  function login(name, psw, from, nickName) {
    if (!from) { // 对于WX MiniP 平台, wxCode, 保持原来的大小写
      name = name.toLowerCase();
    }
    return $auth.login({ email: name, password: psw, from: from, nickName: nickName })
      .then(getProfile)
      .catch(onGetProfileFailed);
  }

  function loginFromWx(wxBoneToken, displayName) {
    // return login('wxNewYearCard', 'TqTest123');
    var authorizer = "wx"; // AUTH.WX 见服务器的const.js
    return login(wxBoneToken, "wxGranted", authorizer, displayName);
  }

  function authenticate(authName) {
    return $auth.authenticate(authName)
      .then(getProfile)
      .catch(onGetProfileFailed);
  }

  function logout(name) {
    return $auth.logout()
      .then(onLogoutDone);
  }

  function sendCode(name, callback) {
    console.log("sendCode");
    var data = { "name": name };
    $http.post(TQ.Config.AUTH_HOST + "/auth/sendcode", angular.toJson(data))
      .then(function(result) {
        console.log("result : ", result);
        callback(result);
      },
      function(reason) {
        console.log("reason : ", reason);
        callback(reason);
      });
  }

  function confirmCode(name, code, callback) {
    console.log("confirmCode");
    var data = { "name": name, "code": code };
    $http.post(TQ.Config.AUTH_HOST + "/auth/confirmcode", angular.toJson(data))
      .then(function(result) {
        callback(result);
      },
      function(reason) {
        callback(reason);
      });
  }

  function updatePassword(name, code, psw, callback) {
    console.log("updatePassword");
    var data = { "name": name, "code": code, "psw": psw };
    $http.post(TQ.Config.AUTH_HOST + "/auth/updatepassword", angular.toJson(data))
      .then(function(result) {
        callback(result);
      },
      function(reason) {
        callback(reason);
      });
  }

  function signUp(user) {
    return $auth.signup(user).then(onSignUp).catch(onGetProfileFailed);
  }

  function onSignUp(netPkg) {
    var data = netPkg.data;
    if (data && data.errorId) {
      return onGetProfileFailed(netPkg);
    }
    return getProfile();
  }

  function checkName(name) {
    var url = TQ.Config.AUTH_HOST + "/user/checkname/" + name;
    $http.get(url)
      .then(onCheckNameDone)
      .catch(onGetProfileFailed);
  }

  function setAdmin(userId) {
    const privilege = 0x1ff;
    setPrivilege(userId, privilege);
  }
  function setPrivilege(userId, privilege) {
    if (user.canAdmin) {
      return $http.get(TQ.Config.AUTH_HOST + "/user/privilege/" + userId + "/" + privilege);
    }
  }

  function getUserList() {
    if (user.canAdmin) {
      return $http.get(TQ.Config.AUTH_HOST + "/user/list")
        .then(function(netPkg) {
          userList = netPkg.data;
        });
    }
  }

  function onCheckNameDone(netPkg) {
    var data = netPkg.data;
    user.isValidName = (data.result === TQ.Const.SUCCESS);
  }

  function getProfile() {
    return $http.get(TQ.Config.AUTH_HOST + "/auth/api/me")
      .then(onGetProfileSuccess)
      .catch(onGetProfileFailed);
  }

  function onGetProfileSuccess(netPkg) {
    var data = netPkg.data;
    if (netPkg.status === TQ.Const.STATUS200) {
      var age = (!data.age ? user.age : data.age);
      var city = (!data.city ? user.city : data.city);

      TQUtility.extendWithoutObject(user, data);
      user.loggedIn = true;
      user.hasSignedUp = true;
      user.needManualLogin = false;
      user.age = age;
      user.city = city;
      user.isValidName = true;
      user.saveToCache();
      // 有特别能力解决问题的人 superman
      var superman = ["人人动画_Andrew郅刚", "toronto1111"];
      superman.some(function(displayName) {
        if (user.name === displayName || user.displayName === displayName) {
          user.canSolve = true;
          return true;
        }
      });

      TQ.Log.checkPoint("login successfully!  welcome " + user.displayName + ", " + user.name);
    } else {
      onGetProfileFailed(netPkg);
    }
  }

  function onGetProfileFailed(netPkg) {
    var data = netPkg.data;
    if (data && data.errorId) {
      user.nameError = (TQ.Protocol.ERROR.NAME_IS_INVALID === data.errorId) ||
                (TQ.Protocol.ERROR.NAME_IS_TAKEN === data.errorId) ||
                (TQ.Protocol.ERROR.NAME_IS_INVALID_OR_TAKEN === data.errorId);
      user.passwordError = (TQ.Protocol.ERROR.PASSWORD_IS_INVALID === data.errorId) ||
                (TQ.Protocol.ERROR.PASSWORD_IS_INVALID_OR_INCORRECT === data.errorId);
      if (user.nameError) {
        user.passwordError = true;
      }
    } else {
      if (!TQ.MessageBox.hasCriticalError()) {
        TQ.MessageBox.promptWithNoCancel("(code=9901): " +
          TQ.Locale.getStr("network connection failed, please check network availability"));
      }
    }
    user.loggedIn = false;
    $auth.logout(); // 本地也远程server切换时候遗留的token
    TQ.Log.debugInfo("login failed!");
  }

  function onLogoutDone(netPkg) {
    user.loggedIn = false;
    user.needManualLogin = true;
    user.isValidName = true;
    user.saveToCache();
  }

  return {
    authenticate: authenticate,
    canAutoLogin: canAutoLogin,
    tryAutoLogin: tryAutoLogin,
    tryAutoSignUp: tryAutoSignUp,
    checkName: checkName,
    getProfile: getProfile,
    getUserList: getUserList,
    setAdmin: setAdmin,
    setPrivilege: setPrivilege,
    login: login,
    loginFromWx: loginFromWx,
    logout: logout,
    signUp: signUp,
    sendCode: sendCode,
    confirmCode: confirmCode,
    updatePassword: updatePassword
  };
}

/**
 * Created by Andrewz on 5/8/2016.
 */
angular.module("starter").factory("AppService", AppService);

AppService.$inject = ["$stateParams", "$timeout", "WCY", "NetService", "DeviceService",
  "Setup", "UserService"];

function AppService($stateParams, $timeout, WCY, NetService, DeviceService,
  Setup, UserService) {
  var STATE_LOADED = 1;
  var STATE_STARTING = 2;
  var STATE_STARTED = 3;
  var _state = STATE_LOADED;
  var _initialized = false;
  var _onAppStarting = null;
  var _onAppStarted = null; // onAppStartDefault;

  function configCanvas() {
    TQ.State.updateDeviceInfo();
    TQ.State.determineWorkingRegion();
    if (currScene) {
      TQ.State.canvasStyle = TQ.Graphics.setCanvas();
      TQ.DirtyFlag.setScene();
    }

    TQ.Log.debugInfo("scren is: (" + TQ.Config.workingRegionWidth + ", " + TQ.Config.workingRegionHeight + ")" +
            "orientation = " + TQ.Config.orientation);
  }

  function _init() {
    if (UserService.canAutoLogin()) {
      UserService.tryAutoLogin().then(doInit);
    } else {
      doInit();
    }
  }

  function doInit() {
    // remove_debugger_begin
    // TQ.Log.setLevel(TQ.Log.INFO_LEVEL);
    // remove_debugger_end

    // Chrome规定：必须用户操作之后，才能播放Audio和Video，
    // 如果是从shared link直接打开播放， 则必须要提示用户操作一下，否则video的不触发canplay事件
    // iOS也一样
    TQ.State.needUserClickToPlayAV = (!!TQ.QueryParams.shareCode &&
            (parseInt(TQ.Utility.shareCode2Id(TQ.QueryParams.shareCode)) > 0));

    if (_initialized) {
      TQ.Log.error("Duplicated call in _init");
      return;
    }
    if (!TQ.Utility.isSupportedEnvironment()) {
      var msg = TQ.Locale.getStr("please use android mobile");
      // +' <a href="https://www.google.ca/chrome/browser/features.html" style="font-weight: bold; text-decoration: underline">' +
      // TQ.Locale.getStr('chrome') + '</a>！';
      TQ.MessageBox.prompt(msg, function() {
        msg = TQ.Locale.getStr("please copy this page to technical support") + ": support@udoido.com. \n\n\n\r\n\r";
        $timeout(TQ.MessageBox.prompt(msg + navigator.userAgent + " \n\r" + navigator.vendor));
      });
      return;
    }
    _initialized = true;
    TQ.Log.debugInfo("_init");
    document.addEventListener(TQ.EVENT.SYSTEM_ERROR, onSystemError, false);
    configCanvas();
    if (TQ.Config.LocalCacheEnabled) {
      document.addEventListener(TQ.EVENT.FILE_SYSTEM_READY, onFileSystemReady, false);
      DeviceService.initialize();
    } else {
      onFileSystemReady();
    }
    TQ.Log.checkPoint("file system ready");
    if ((!TQ.Env || !TQ.Env.lang) && !TQ.QueryParams.noLocale) {
      TQ.Log.error("must setup default language!");
    }
    angular.element(document).ready(function() {
      if (!(TQ.QueryParams && TQ.QueryParams.noLocale)) {
        TQ.Locale.initialize(TQ.Env.lang);
      }
    });

    if (_state < STATE_STARTING) { // 由于autoLogin的影响， 可能此段函数被滞后了。
      _state = STATE_STARTING;
    }

    if (_onAppStarting) {
      _onAppStarting();
    }
  }

  // 三个阶段： DeveiceReady, DOM ready, ImageCacheReady, DirReady
  function onFileSystemReady() {
    if (TQ.Config.LocalCacheEnabled) {
      document.addEventListener(TQ.EVENT.DIR_READY, onDirReady, false);
      document.removeEventListener(TQ.EVENT.FILE_SYSTEM_READY, onFileSystemReady);
      Setup.initialize();
      NetService.initialize();
    } else {
      NetService.initialize();
      onDirReady();
    }
  }

  function onDirReady() {
    if (TQ.Config.LocalCacheEnabled) {
      document.removeEventListener(TQ.EVENT.DIR_READY, onDirReady);
      assertTrue("device要先ready", DeviceService.isReady());
    }
    if (_onAppStarted) {
      $timeout(function() {
        _onAppStarted();
      });
    }
    _state = STATE_STARTED;
  }

  function onAppStartDefault() {
    // $scope.testDownload();

    var opus = TQ.Utility.getUrlParam("opus");
    if (!opus && $stateParams.shareCode) {
      opus = $stateParams.shareCode;
    }
    // opus = "100_12345678_123_1234567890";
    // opus = "100_00000016_123_1234567890";
    // opus = "100_00000025_123_1234567890";
    if (opus) {
      WCY.getWcy(opus);
    } else {
      WCY.start();
    }
    // WxService.init();
    // $cordovaProgress.hide();
  }

  function setOnAppStarted(fn) {
    _onAppStarted = fn;
    if (_state === STATE_STARTED) {
      _onAppStarted();
    }
  }

  function setOnAppStarting(fn) {
    _onAppStarting = fn;
    if (_state >= STATE_STARTING) {
      _onAppStarting();
    }
  }

  function onSystemError(evt) {
    if (evt) {
      TQ.Log.error(evt.type);
      TQ.Log.error(evt.data);
      TQ.Log.error(TQUtility.stringifyIgnoreCycle(evt));
    }
    TQ.MessageBox.confirm(TQ.Locale.getStr("Error: Can't load system file"));
  }

  return {
    init: _init,
    configCanvas: configCanvas,
    onAppStarting: setOnAppStarting,
    onAppStarted: setOnAppStarted
  };
}

/*!
* screenfull
* v4.2.0 - 2019-04-01
* (c) Sindre Sorhus; MIT License
*/
(function () {
	'use strict';

	var document = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};
	var isCommonjs = typeof module !== 'undefined' && module.exports;
	var keyboardAllowed = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element;

	var fn = (function () {
		var val;

		var fnMap = [
			[
				'requestFullscreen',
				'exitFullscreen',
				'fullscreenElement',
				'fullscreenEnabled',
				'fullscreenchange',
				'fullscreenerror'
			],
			// New WebKit
			[
				'webkitRequestFullscreen',
				'webkitExitFullscreen',
				'webkitFullscreenElement',
				'webkitFullscreenEnabled',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			// Old WebKit (Safari 5.1)
			[
				'webkitRequestFullScreen',
				'webkitCancelFullScreen',
				'webkitCurrentFullScreenElement',
				'webkitCancelFullScreen',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			[
				'mozRequestFullScreen',
				'mozCancelFullScreen',
				'mozFullScreenElement',
				'mozFullScreenEnabled',
				'mozfullscreenchange',
				'mozfullscreenerror'
			],
			[
				'msRequestFullscreen',
				'msExitFullscreen',
				'msFullscreenElement',
				'msFullscreenEnabled',
				'MSFullscreenChange',
				'MSFullscreenError'
			]
		];

		var i = 0;
		var l = fnMap.length;
		var ret = {};

		for (; i < l; i++) {
			val = fnMap[i];
			if (val && val[1] in document) {
				for (i = 0; i < val.length; i++) {
					ret[fnMap[0][i]] = val[i];
				}
				return ret;
			}
		}

		return false;
	})();

	var eventNameMap = {
		change: fn.fullscreenchange,
		error: fn.fullscreenerror
	};

	var screenfull = {
		enabled: undefined,
		request: function (elem) {
			return new Promise(function (resolve) {
				var request = fn.requestFullscreen;

				var onFullScreenEntered = function () {
					this.off('change', onFullScreenEntered);
					resolve();
				}.bind(this);

				elem = elem || document.documentElement;

				// Work around Safari 5.1 bug: reports support for
				// keyboard in fullscreen even though it doesn't.
				// Browser sniffing, since the alternative with
				// setTimeout is even worse.
        try {
          if (/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent)) {
            elem[request]();
          } else {
            elem[request](keyboardAllowed ? Element.ALLOW_KEYBOARD_INPUT : {});
          }
        } catch (err) {
          console.log("fullscreen error: " + JSON.stringify(err));
        }

				this.on('change', onFullScreenEntered);
			}.bind(this));
		},
		exit: function () {
			return new Promise(function (resolve) {
				if (!this.isFullscreen) {
					resolve();
					return;
				}

				var onFullScreenExit = function () {
					this.off('change', onFullScreenExit);
					resolve();
				}.bind(this);

				document[fn.exitFullscreen]();

				this.on('change', onFullScreenExit);
			}.bind(this));
		},
		toggle: function (elem) {
			return this.isFullscreen ? this.exit() : this.request(elem);
		},
		onchange: function (callback) {
			this.on('change', callback);
		},
		onerror: function (callback) {
			this.on('error', callback);
		},
		on: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.addEventListener(eventName, callback, false);
			}
		},
		off: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.removeEventListener(eventName, callback, false);
			}
		},
    update: function () {
      //
      // 判断是否在全屏状态（假设browser的zoom值是100%， 否则不对）
      // outerHeight单位是 screen pixels，但是在zoom非100%时，竟然小于inner，故不用, 
      // innerWidth 单位 css pixels.
      // 二者都受browser zoom值的影响。
      //  在zoom== 100%时，window.outerHeight == screen.height;
      //                  window.outerHeight > window.innerHeight
      // 而zoom < 100% （字体小了，window.innerHeight大了），会颠覆这个常识
      if (TQ.State.innerHeight == screen.height) {
        screenfull.enabled = true;
      } else {
        screenfull.enabled = false;
        setupAutoEnable();
      }
    },
		raw: fn
	};

	if (!fn) {
		if (isCommonjs) {
			module.exports = false;
		} else {
			window.screenfull = false;
		}

		return;
	}

	Object.defineProperties(screenfull, {
		isFullscreen: {
			get: function () {
				return Boolean(document[fn.fullscreenElement]);
			}
		},
		element: {
			enumerable: true,
			get: function () {
				return document[fn.fullscreenElement];
			}
		}
		// enabled: {
		// 	enumerable: true,
		// 	get: function () {
		// 		// Coerce to boolean in case of old WebKit
		// 		return Boolean(document[fn.fullscreenEnabled]);
		// 	}
		// }
	});

  screenfull.setupAutoEnable = setupAutoEnable;
	if (isCommonjs) {
		module.exports = screenfull;
		// TODO: remove this in the next major version
		module.exports.default = screenfull;
	} else {
		window.screenfull = screenfull;
	}

  function autoEnableFullscreen() {
    if (!screenfull.enabled) {
      if (screenfull.enabled == undefined) {
        screenfull.update();
      }
      if (!screenfull.enabled) {
        screenfull.request();
      }
    }
    document.removeEventListener('touch', autoEnableFullscreen);
    document.removeEventListener('click', autoEnableFullscreen);
  }

  function setupAutoEnable() {
    if (!screenfull.enabled) {
      document.addEventListener('touch', autoEnableFullscreen);
      document.addEventListener('click', autoEnableFullscreen);
    }
  }

  setupAutoEnable();
})();

/*
   浮动工具条
   */
window.TQ = window.TQ || {};

(function() {
  // / 以下是接口部分
  function FloatToolbar() {}
  FloatToolbar.selectedElement = null;
  FloatToolbar.onScaleBig = depreciated;
  FloatToolbar.onScaleSmall = depreciated;
  FloatToolbar.onRotateLeft = depreciated;
  FloatToolbar.onRotateRight = depreciated;
  FloatToolbar.onMoveUpLayer = depreciated;
  FloatToolbar.onMoveDownLayer = depreciated;
  FloatToolbar.onMoveToTop = depreciated;
  FloatToolbar.onMoveToBottom = depreciated;
  FloatToolbar.onDelete = depreciated;
  FloatToolbar.onMirrorX = depreciated;
  FloatToolbar.onMirrorY = depreciated;

  //
  FloatToolbar.initialize = depreciated;
  FloatToolbar.close = depreciated;
  FloatToolbar.show = depreciated;
  FloatToolbar.setPosition = depreciated;
  FloatToolbar.close = depreciated;

  function depreciated() {
    TQ.Log.depreciated();
  }

  TQ.FloatToolbar = FloatToolbar;
}());

/**
 * 图强动漫引擎,
 * 专利产品 领先技术
 */
window.TQ = window.TQ || {};

// 存放全局的API， 需要在所有模块都调入之后， 才能够执行， 否则没有函数。
(function() {
  function WCY() {

  }
  WCY.isPlayOnly = true;
  WCY.currentScene = null;
  WCY.getCurrentScene = function() {
    return WCY.currentScene;
  };

  WCY.getCurrentElement = function() {
    return TQ.SelectSet.peek();
  };

  /*
    直接跳转到第id个场景 (id >=0)
     */
  WCY.gotoLevel = function(id) {
    id = Number(id);
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return;
    WCY.currentScene.gotoLevel(id);
  };

  /*
     插入第id(id >=0）个场景， 如果该位置已经有场景， 把原来的场景向后顺延。
     如果id < 0, 则令id =0;.
     如果id 超出上边界， 则自动在末尾添加一个场景）
     */
  WCY.addLevelAt = function(id) {
    id = Number(id);
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return;

    WCY.currentScene.addLevel(id);
  };

  /*
     紧跟当前场景的后面，插入1个新场景。
     */
  WCY.addLevel = function() {
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return;
    WCY.currentScene.addLevel(WCY.currentScene.currentLevelId + 1);
  };

  /*
     删除第id(id >=0）个场景， 并且把此后的场景前移。
     如果id超出边界（id < 0)，则忽略
     */
  WCY.deleteLevel = function(id) {
    id = Number(id);
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return;

    WCY.currentScene.deleteLevel(id);
  };

  /*
     移动序号为srcId的场景，并插入到序号dstId的场景之前，
     注意：srcId和dstId都是在执行此函数之前， 按照场景的顺序来编号的。
     用户不需要关心
     */
  WCY.moveTo = function(srcId, dstId) {
    srcId = Number(srcId);
    dstId = Number(dstId);
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return;

    WCY.currentScene.moveTo(srcId, dstId);
  };

  /*
     复制序号为srcId的场景的内容，并插入到序号dstId的场景之前，
     */
  WCY.copyTo = function(srcId, dstId) {
    srcId = Number(srcId);
    dstId = Number(dstId);
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return;

    WCY.currentScene.copyTo(srcId, dstId);
  };

  /*
    获取当前微创意的场景（Level）数量
    */
  WCY.getLevelNum = function() {
    assertNotNull(TQ.Dictionary.FoundNull, WCY.currentScene); // 必须在微创意显示之后使用
    if (!WCY.currentScene) return 0;
    return WCY.currentScene.levelNum();
  };

  WCY.doStop = function() {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, WCY.currentScene != null);
    if (WCY.currentScene != null) {
      WCY.currentScene.stop();
    }
  };
  WCY.doPlay = function() {
    assertTrue(TQ.Dictionary.INVALID_LOGIC, WCY.currentScene != null);
    if (WCY.currentScene != null) {
      WCY.currentScene.play();
    }
  };
  WCY.emptyScene = function() { TQ.SceneEditor.emptyScene(); };

  WCY.doPlayStop = function() {
    if (TQ.FrameCounter.isPlaying()) {
      WCY.doStop();
    } else {
      WCY.doPlay();
    }
  };

  var canvas;
  // 进入/退出 全屏模式
  WCY.fullscreenPlay = function(width, height) { // 屏幕分辨率的大小
    canvas = TQ.Graphics.getCanvas();
    canvas.width = Math.round(width);
    canvas.height = Math.round(height);

    TQ.Config.zoomX = width / TQ.Config.workingRegionWidth;
    TQ.Config.zoomY = height / TQ.Config.workingRegionHeight;
    TQ.Config.workingRegionWidth = width;
    TQ.Config.workingRegionHeight = height;
    WCY.doPlay();
  };

  WCY.eixtFullscreen = function() {
    TQ.Graphics.setCanvas();
    TQ.Config.zoomX = TQ.Config.zoomY = 1;
  };

  WCY.deleteElement = function(ele) {
    WCY.currentScene.deleteElement(ele);
  };

  WCY.getCurrentLevelId = function() {
    return WCY.currentScene.currentLevelId;
  };

  WCY.getCurrentTime = function() {
    return TQ.FrameCounter.t();
  };

  // size: 雪花大小，  默认1,  取值范围1-5.
  // direction:  落雪方向： 0：向下， 取值范围： -15度到15度，
  // density: 密度， 默认1（小雨）取值范围：1-10
  WCY.snow = function(size, direction, density, res, snowFlowerImage) {

  };

  WCY.snowChange = function(size, direction, density) {

  };

  WCY.snowStop = function() {
    TQ.SnowEffect.stop();
  };

  // size: 雨滴大小，  默认1,  取值范围1-5.
  // direction: 落雨方向： 0：向下， 取值范围： -15度到15度，
  // density: 密度， 默认1（小雨），取值范围：1-10
  WCY.rain = function(size, direction, density, res, dropImage) {
    TQ.RainEffect.set(size, direction, density, res, dropImage);
  };

  WCY.rainChange = function(size, direction, density) {
    TQ.RainEffect.set(size, direction, density);
  };

  WCY.rainStop = function() {
    TQ.RainEffect.stop();
  };

  // type: 烟火的种类，默认1,      系统保留扩展其它取值）
  WCY.firework = function(type) {
    TQ.Log.debugInfo(type);
  };

  // ------------- 以下的函数用于配置系统参数 -------------------------
  // 设置零件标志的大小， 默认是10：
  WCY.setMarkerSize = function(radius) {
    TQ.Marker.RADIUS = radius;
  };

  TQ.WCY = WCY;
}());

window.TQ = window.TQ || {};
var canvas;
var stage = null;
var stageContainer = null;
var currScene = null;

(function() {
  // 场景编辑器,
  function SceneEditor() {
  }

  SceneEditor.MODE = {
    NOT_INITIALIZED: 0,
    LOADING: 100, // 加载页
    WELCOME: 110,
    LOGIN: 115, // 首页 （没有canvas，1--1999）
    FIRST: 120, // 首页 （没有canvas，1--1999）

    // 以下是登录之后的
    MY_WORK: 210, // 个人作品也，

    // 以下>2000, 都属于EDIT和Play，都需要canvas
    EDIT_OR_PLAY: 2000, // 编辑,分享等 （有canvas，>=2000）
    EDIT: 2100, // 编辑
    // EDIT_IMAGE: 2200, // 尚未以他们代替 flag变量
    RECORD_AUDIO: 2300,
    PREVIEW: 2400, // Play, Preview
    SHARE_PANE: 2410, // 属于PREVIEW上的页面
    CONVERT_TO_TOPIC: 2420,

    // 互动模式
    INTERACT: 3000
  };

  TQ.State.editorMode = SceneEditor.NOT_INITIALIZED;
  var editorOn = false;
  var _auxContainer;

  Object.defineProperty(SceneEditor, "auxContainer", {
    get: function() {
      return _auxContainer;
    }
  });

  SceneEditor._mode = TQBase.LevelState.EDITING; // 创作界面的缺省模式是编辑.

  // 接口
  SceneEditor.turnOnEditor = turnOnEditor;
  SceneEditor.preprocessLocalImage = preprocessLocalImage;
  SceneEditor.lastSoundElement = null;

  SceneEditor.openScene = function(fileInfo) {
    if (fileInfo.isPlayOnly === undefined) {
      fileInfo.isPlayOnly = false;
    }
    init(fileInfo);
  };

  SceneEditor.createScene = function(option) {
    TQ.Assert.isNotNull(option);
    var fileInfo = {
      filename: option.filename || TQ.Config.UNNAMED_SCENE_ID,
      screenshotName: option.screenshotName,
      content: TQ.Scene.getEmptySceneJSON()
    };
    TQ.State.isPlayOnly = false;
    SceneEditor.openScene(fileInfo);
  };

  function createStage() {
    canvas = TQ.Graphics.getCanvas();
    // ToDo:AZ
    // addHammer(canvas);
    // create a new stage and point it at our canvas:
    stage = new createjs.Stage(canvas);
    SceneEditor.stageContainer = stageContainer = new createjs.Container();
    _auxContainer = new createjs.Container();
    stage.addChild(stageContainer);
    stage.addChild(_auxContainer); // aux层，总是在上，存放BBox， marker等
    SceneEditor.stage = stage;
  }

  SceneEditor.cleanStage = function() {
    if (stageContainer) {
      stageContainer.children.splice(0);
    }

    if (_auxContainer) {
      _auxContainer.children.splice(0);
    }
  };

  SceneEditor.addItemByFile = function(dstLevel, data, matType, callback) {
    var aFile = data.aFile || data;

    if ((aFile instanceof File) && aFile.size > TQ.Config.MAT_MAX_FILE_SIZE) {
      return TQ.MessageBox.show("Resource file size should less than " + TQ.Config.MAT_MAX_FILE_SIZE_IN_M + "M");
    }

    if (matType === TQ.MatType.SOUND) {
      if (!TQUtility.isSoundFile(aFile) && !TQUtility.isSoundBlob(aFile)) {
        var str = TQ.Locale.getStr("found audio format unsupported, please use wav or map3") + ": " + aFile.type;
        TQ.MessageBox.show(str);
      } else {
        if (aFile.size > TQ.Config.MAT_MAX_FILE_SIZE) {
          return TQ.MessageBox.show("Resource file size should less than " + TQ.Config.MAT_MAX_FILE_SIZE_IN_M + "M");
        }
        addItemBySoundFile(dstLevel, aFile, matType, callback);
      }
    }
  };

  function preprocessLocalImage(dstLevel, data, matType, callback, kouTuMain) { // reduce size,
    var aFile = data.aFile || data;
    var options = { crossOrigin: "Anonymous" }; // "Use-Credentials";

    if ((aFile instanceof File) && aFile.size > TQ.Config.MAT_MAX_FILE_SIZE) {
      return TQ.MessageBox.show("Resource file size should less than " + TQ.Config.MAT_MAX_FILE_SIZE_IN_M + "M");
    }

    if (TQUtility.isVideoFile(aFile)) {
      addVideoItem(dstLevel, aFile, matType, callback);
    } else if (TQ.ImageCliper && TQ.Config.hasClip) {
      TQ.ImageCliper.clipImage(aFile, function(imageData) {
        if (!imageData) {
          // 操作被Cancelled，
          return;
        }
        tryKouTu({ data: imageData, errorCode: 0 });
      });
    } else {
      TQ.ImageProcess.start(aFile, options, tryKouTu);
    }

    var stopReminder = true;
    function tryKouTu(buffer) {
      if (buffer.data) {
        if (buffer.data instanceof File) {
          var imageFile = buffer.data;
          if (imageFile.size > TQ.Config.MAX_FILE_SIZE) {
            return TQ.MessageBox.confirm("文件太大，影响打开速度，请限制文件大小 < " + Math.round(TQ.Config.MAX_FILE_SIZE / 1000) + "K");
          }
        }
      }

      if (!stopReminder && !!buffer.errorCode && buffer.errorCode !== 0) {
        TQ.MessageBox.prompt("For this design, the image file's width and height should be <= " +
          TQ.Config.designatedWidth + " by " + TQ.Config.designatedHeight + ", do you want to resize automatically?",
        nextProcess,
        function() {
        });
      } else {
        nextProcess();
      }

      function nextProcess() {
        if (typeof kouTuMain === "function") {
          koutuMain(buffer.data, matType, function(image64) {
            addItemByImageData(dstLevel, image64, matType, callback);
          });
        } else {
          addItemByImageData(dstLevel, buffer.data, matType, callback);
        }
      }
    }
  }

  function addItemByImageData(dstLevel, image64Data, matType, callback) {
    var img = new Image();
    img.onload = doAdd;
    if (TQUtility.isLocalFile(image64Data)) {
      img.src = TQUtility.fileToUrl(image64Data, {});
    } else { // base64
      img.src = image64Data;
    }

    function doAdd() {
      var desc = {
        data: img,
        src: null, type: "Bitmap", autoFit: determineAutoFit(matType),
        dstLevel: dstLevel,
        eType: TQ.MatType.toEType(matType)
      };

      callback(desc, image64Data, matType);
    }
  }

  function addVideoItem(dstLevel, aFile, matType, callback) {
    if (TQUtility.isLocalFile(aFile)) {
      TQ.VideoMgr.play(TQUtility.fileToUrl(aFile, {}), doAdd); //
    } else {
      TQ.AssertExt.invalidLogic(false, "video 应该是本地视频文件");
    }

    function doAdd(inst) {
      if (inst) {
        console.log(inst);
      }
      var desc = TQ.VideoElement.createDescFromResource(inst.domEle);
      TQUtility.extendWithoutObject(desc, {
        data: !inst ? aFile : inst.domEle,
        src: !inst ? aFile : inst.src,
        autoFit: TQ.Element.FitFlag.NO,
        dstLevel: dstLevel,
        eType: TQ.MatType.toEType(matType)
      });
      callback(desc, aFile, matType);
    }
  }

  function addItemBySoundFile(dstLevel, fileOrBlob, matType, callback) {
    TQ.RM.loadSoundFromFile(fileOrBlob, function(result) {
      var desc = {
        data: TQ.RM.getResource(result.item.id).res,
        src: result.item.id, type: TQ.ElementType.SOUND,
        dstLevel: dstLevel,
        eType: TQ.MatType.toEType(matType)
      };

      callback(desc, fileOrBlob, matType);
    });
  }

  SceneEditor.addItem = function(desc) {
    desc.version = TQ.Element.VER3; // 新增加的元素都是2.0
    if (!desc.eType) {
      TQ.Log.error("未定义的eType");
    }

    if (!desc.dstLevel) {
      desc.dstLevel = currScene.currentLevel;
    }
    // "Groupfile" 暂时还没有纳入RM的管理范畴
    if (((desc.type === TQ.ElementType.SOUND) ||
        (desc.type === TQ.ElementType.BITMAP) ||
        (desc.type === TQ.ElementType.VIDEO) ||
        (desc.type === TQ.ElementType.BUTTON)) && !desc.data &&
      (!TQ.RM.hasElementDesc(desc))) {
      TQ.RM.addElementDesc(desc, doAdd);
      return null; // 无法立即添加并返回ele，因为资源不ready
    } else {
      return doAdd();
    }

    function doAdd() {
      var ele = currScene.addItem(desc);
      TQ.Assert.isTrue(!!desc.eType);
      if (ele.level && ele.level.isActive()) {
        ele.isNewlyAdded = true;
      }
      return ele;
    }
  };
  SceneEditor.getElements = function() {
    return currScene.getElements();
  };
  SceneEditor.emptyScene = function() { // empty the current scene
    TQ.AssertExt.isNotNull(currScene);
    if (!currScene) {
      return false;
    }

    currScene.empty();
  };

  SceneEditor.getMode = function() {
    if (TQ.State.isPlayOnly) {
      return TQBase.LevelState.RUNNING;
    }
    return SceneEditor._mode;
  };

  SceneEditor.setEditMode = function() {
    if (!currScene) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return false;
    }
    TQ.FrameCounter.stop();
    SceneEditor.setMode(TQBase.LevelState.EDITING);
  };

  SceneEditor.setPlayMode = function() {
    if (!currScene) {
      assertTrue(TQ.Dictionary.INVALID_LOGIC, false);
      return false;
    }
    TQ.FrameCounter.play();
    SceneEditor.setMode(TQBase.LevelState.RUNNING);
  };

  SceneEditor.updateMode = function() {
    if (SceneEditor._requestMode == null) return;
    SceneEditor._mode = SceneEditor._requestMode;
    SceneEditor._requestMode = null;
  };

  SceneEditor.setMode = function(mode) {
    SceneEditor._requestMode = mode;
  };
  SceneEditor.isEditMode = function() {
    SceneEditor.updateMode();
    return (SceneEditor.getMode() === TQBase.LevelState.EDITING);
  };
  SceneEditor.isPlayMode = function() {
    SceneEditor.updateMode();
    return (SceneEditor.getMode() === TQBase.LevelState.RUNNING);
  };

  SceneEditor.stageContainer = stageContainer;
  TQ.SceneEditor = SceneEditor;

  function init(fileInfo) {
    if ((typeof fileInfo) === "string") {
      fileInfo = { name: fileInfo, content: null };
    }
    if (!TQ.SceneEditor.stage) {
      createStage();
    }
    // stage.enableMouseOver();
    TQBase.LevelState.reset();
    if (!currScene) {
      initializeCoreModules();
    }
    loadScene(fileInfo);
    initializeControllers();
  }

  function initializeCoreModules() {
    // core module是在loadScene中需要用到的module， 必须在loadScene之前初始化
    TQ.SoundMgr.initialize();
    TQ.VideoMgr.initialize();
    TQ.ParticleMgr.initialize();
    TQ.RM.initialize();
  }

  function initializeControllers() {
    TQ.InputMap.initialize(TQ.State.isPlayOnly);
    TQ.TaskMgr.initialize();
    TQ.GarbageCollector.initialize();
    if (!TQ.State.isPlayOnly) {
      turnOnEditor();
    }
  }

  function turnOnEditor() {
    if (editorOn) {
      return;
    }

    editorOn = true;
    if (!TQ.SceneEditor.stage) {
      createStage();
    }
    TQ.CommandMgr.initialize();
    TQ.InputCtrl.initialize(stageContainer);
    TQ.MoveCtrl.initialize(stageContainer);
    TQ.SkinningCtrl.initialize(stageContainer, currScene);
    TQ.IKCtrl.initialize(stageContainer, currScene);
    TQ.TrackRecorder.initialize();
    TQ.ActionRecorder.initialize();
    TQ.SelectSet.initialize();
    TQ.AnimationManager.initialize();
  }

  function loadScene(fileInfo) {
    if ((typeof fileInfo) === "string") {
      fileInfo = { name: fileInfo, content: null };
    }

    TQ.MessageBox.reset();
    if (!currScene) {
      currScene = new TQ.Scene();
      TQ.WCY.currentScene = currScene;
    }
    TQ.GarbageCollector.reset();
    currScene.open(fileInfo);
    localStorage.setItem("sceneName", fileInfo.name);
    TQ.FrameCounter.reset();
    TQ.CommandMgr.reset();
    TQ.AnimationManager.reset();
    TQ.SkinningCtrl.end();
    TQ.FloatToolbar.close();
    TQ.WCY.currentScene = currScene;
    return currScene;
  }

  function getDefaultTitle(givenName) {
    var defaultTitle = ((!currScene) || (!currScene.title))
      ? givenName : currScene.title;
    if (!defaultTitle) {
      defaultTitle = TQ.Config.UNNAMED_SCENE;
    }

    var id = defaultTitle.lastIndexOf("\\");
    if (id <= 0) {
      id = defaultTitle.lastIndexOf("/");
    }

    var shortTitle = (id > 0) ? defaultTitle.substr(id + 1) : defaultTitle;
    return TQ.Utility.forceExt(shortTitle);
  }

  function deleteScene() {
    var title = currScene.title;
    if ((title.lastIndexOf(TQ.Config.DEMO_SCENE_NAME) < 0) && // 不能覆盖系统的演示文件
      (title !== TQ.Config.UNNAMED_SCENE)) { // 不能每名称
      var filename = currScene.filename;
      TQ.TaskMgr.addTask(function() {
        netDelete(filename);
      },
      null);
    } else {
      displayInfo2("<" + title + ">:" + TQ.Dictionary.CanntDelete);
    }
  }

  function _doSave(filename, keywords) {
    TQ.TaskMgr.addTask(function() {
      currScene.save(filename, keywords);
    },

    null);
    TQ.InputMap.turnOn();
    localStorage.setItem("sceneName", filename);
  }

  function addImage(desc) {
    TQ.Log.depreciated("replaced by: SceneEditor.addItem");
  }

  function addAnimationTest() {
    currScene.addItem({ src: TQ.Config.SCENES_CORE_PATH + "AnimationDesc.adm", type: "BitmapAnimation" });
  }

  function makeAnimationTest() {
    currScene.shooting();
  }

  function uploadImageWindow() {
    // 从JS调用PHP, 则PHP的URL 是相对于当前HTML或PHP文件的目录, 而不是JS文件的目录,
    createWindow("Weidongman/src/upload_image.php", 500, 400);
  }

  function createWindow(url, width, height) {
    // Add some pixels to the width and height:
    var borderWidth = 10;
    width = width + borderWidth;
    height = height + borderWidth;

    // If the window is already open,
    // resize it to the new dimensions:
    if (window.popup && !window.popup.closed) {
      window.popup.resizeTo(width, height);
    }

    // Set the window properties:
    var specs = "location=no, scrollbars=no, menubars=no, toolbars=no, resizable=yes, left=0, top=0, width=" + width + ", height=" + height;

    // Create the pop-up window:
    var popup = window.open(url, "ImageWindow", specs);
    popup.focus();
  } // End of function.

  function create3DElement() {
    if (TQ.SelectSet.groupIt()) { // 返回false肯定不成功, 不要做后续的
      var ele = currScene.currentLevel.latestElement;
      if (ele != null) {
        if (ele.viewCtrl == null) {
          var ctrl = new TQ.MultiView();
          TQ.CommandMgr.addCommand(new TQ.GenCommand(TQ.GenCommand.SET_3D_OBJ, ctrl, ele, ele));
        }
      }
    }
    TQ.InputCtrl.clearSubjectModeAndMultiSelect();
  }

  function editActions() {
    var ele = TQ.SelectSet.peek();

    if (ele != null) {
      TQ.Animation.unitTest(ele);
    }
  }

  function isBkg(matType) {
    return (matType === TQ.MatType.BKG);
  }

  SceneEditor.revokeLastSound = function() {
    if (SceneEditor.lastSoundElement) {
      SceneEditor.lastSoundElement.stop();
      currScene.deleteElement(SceneEditor.lastSoundElement);
      SceneEditor.lastSoundElement = null;
    }
  };

  function determineAutoFit(matType) {
    return isBkg(matType) ? TQ.Element.FitFlag.FULL_SCREEN : TQ.Element.FitFlag.WITHIN_FRAME;
  }
}());

/**
 *  ScreenShot: 复制单个屏幕(Canvas部分), 上传到服务器,
 *  , 或连续复制屏幕, 制作GIF图像,上传到服务器/显示到页面上
 *  可以指定 透明色, 背景色, 复制的范围(默认是整个canvas),
 *  静态函数, 不需要初始化
 **/
window.TQ = window.TQ || {};

(function() {
  var ScreenShot = {};

  function takeImage(bkgColor) {
    var imageData;
    if (!bkgColor) {
      imageData = stage.toDataURL("image/png"); // 默认生成透明图, 带alpha信息, PNG格式的
    } else {
      imageData = stage.toDataURL(bkgColor, "image/png"); // 带背景色， 不再是透明的
    }

    return imageData;
  }

  ScreenShot.getData = function() {
    return takeImage();
  };

  ScreenShot.saveThumbnail = function(album, id) {
    var img = new Image();
    img.onload = function() {
      album[id] = {
        src: imageResize(img, 100, 100),
        timestamp: Date.now()
      };
    };
    img.src = takeImage(TQ.Graphics.getCanvasBkgColor());
  };

  ScreenShot.getDataWithBkgColor = function() {
    return takeImage(TQ.Graphics.getCanvasBkgColor());
  };

  /*
    专门针对社交app帖子插图的优化：要求：不失真，宽度最大化，容许高度溢出或不足
    归一化到Iphone 6宽度尺寸，而且，高度改为4:3 ==》375*500 （全高度667）
    也可用于和最新作品栏目
  */
  ScreenShot.getForPostAsync = function(onImageReady) {
    var WIDTH_IPHONE_6 = 375;
    var HEIGHT_IPHONE_6 = 667;
    var fullScreenShot = new Image();
    fullScreenShot.onload = function() {
      var resultImage = imageResize(fullScreenShot, WIDTH_IPHONE_6, HEIGHT_IPHONE_6);
      if (onImageReady) {
        onImageReady(resultImage);
      }
    };

    fullScreenShot.src = takeImage(TQ.Graphics.getCanvasBkgColor());
  };

  function determineScale(img, maxWidth, maxHeight) { // 只缩小， 不放大
    var scale = 1;

    if (img.height > maxHeight) {
      scale = Math.min(1, maxHeight / img.height);
    }

    if (img.width > maxWidth) {
      scale = Math.min(scale, maxWidth / img.width);
    }
    return scale;
  }

  function imageResize(img, maxWidth, maxHeight) {
    var scale = determineScale(img, maxWidth, maxHeight);
    var ctx;
    var neededHeight = Math.round(img.height * scale / 8) * 8;
    var neededWidth = Math.round(img.width * scale / 8) * 8;
    var canvasTemp;

    if (!canvasTemp) {
      canvasTemp = document.createElement("canvas");
    }
    canvasTemp.width = neededWidth;
    canvasTemp.height = neededHeight;

    ctx = canvasTemp.getContext("2d");
    var xc = 0; var yc = 0;
    ctx.drawImage(img, xc, yc, neededWidth, neededHeight);
    return canvasTemp.toDataURL("image/png");
  }

  // ToDo: 支持GIF,
  /*

    var jsf  = ["/Demos/b64.js", "LZWEncoder.js", "NeuQuant.js", "GIFEncoder.js"];
    var head = document.getElementsByTagName("head")[0];

    for (var i=0;i<jsf.length;i++) {
        var newJS = document.createElement('script');
        newJS.type = 'text/javascript';
        newJS.src = 'http://github.com/antimatter15/jsgif/raw/master/' + jsf[i];
        head.appendChild(newJS);
    }

// This post was very helpful!
// http://antimatter15.com/wp/2010/07/javascript-to-animated-gif/

    var w = setTimeout(function() { // give external JS 1 second of time to load

        TQ.Log.debugInfo('Starting');

        var canvas = document.getElementById("mycanvas");
        var context = canvas.getContext('2d');
        var shots  = [];
        var grabLimit = 10;  // Number of screenshots to take
        var grabRate  = 100; // Miliseconds. 500 = half a second
        var count     = 0;

        function showResults() {
            TQ.Log.debugInfo('Finishing');
            encoder.finish();
            var binary_gif = encoder.stream().getData();
            var data_url = 'data:image/gif;base64,'+encode64(binary_gif);
            document.write('<img src="' +data_url + '"/>\n');
        }

        var encoder = new GIFEncoder();
        encoder.setRepeat(0);  //0  -> loop forever, 1+ -> loop n times then stop
        encoder.setDelay(500); //go to next frame every n milliseconds
        encoder.start();

        var grabber = setInterval(function(){
            TQ.Log.debugInfo('Grabbing '+count);
            count++;

            if (count>grabLimit) {
                clearInterval(grabber);
                showResults();
            }

            var imdata = context.getImageData(0,0,canvas.width,canvas.height);
            encoder.addFrame(context);

        }, grabRate);

    }, 1000);

*/

  TQ.ScreenShot = ScreenShot;
}());

/**
 * Created by Andrewz on 4/13/2017.
 * 这些API是PHP时代提供的，尚未完全清除的
 */

TQ.FileDialog = { visible: false };
TQ.TextEditor = { visible: false };

/**
 * Created by Andrewz on 4/19/19.
 */
var TQ = TQ || {};
TQ.Interact = (function() {
  var interactOps = [
    ["touch", onClick]
  ];
  var startEle = null;

  return {
    start: start,
    close: close
  };

  function start() {
    // 在playOnly和微信的未授权的时候，
    if (!TQ.TouchManager.hasInitialized()) {
      TQ.TouchManager.initialize();
    }

    if (!TQ.TouchManager.hasStarted()) {
      TQ.TouchManager.start();
    }

    TQ.State.editorMode = TQ.SceneEditor.MODE.INTERACT;
    if (!TQUtility.isMobile()) { // mobile不需要mousedown
      interactOps["mousedown"] = onClick;
    }
    TQ.TouchManager.save();
    TQ.TouchManager.attachOps(interactOps);
  }

  function close() {
    TQ.State.editorMode = TQ.SceneEditor.MODE.PREVIEW;
    TQ.TouchManager.restore();
  }

  function onClick(e) { // ==mouse的onPressed，
    TQ.Log.debugInfo("touch start or mousedown" + TQ.Utility.getTouchNumbers(e));
    updateStartElement(e);
    e.stopPropagation();
    e.preventDefault();
    if (startEle) {
      startEle.playNextSound();
    }
  }

  function updateStartElement(e) {
    TQ.AssertExt.invalidLogic(!!e);
    if (!e) {
      return null;
    }

    TQ.SelectSet.updateByGesture(e);
    startEle = TQ.SelectSet.peekLatestEditableEle();
    if (!startEle) {
      startEle = null;
      TQ.SelectSet.empty();
      TQ.FloatToolbar.close();
      return null;
    }

    return startEle;
  }
}());

/**
 * Created by Andrewz on 4/19/19.
 */
window.TQ = window.TQ || {};

(function() {
  TQ.Element.prototype.playNextSound = function() {
    var spriteMap = this.jsonObj.spriteMap;
    if (spriteMap && spriteMap.length > 0) {
      if (this.spriteID === undefined) {
        this.spriteID = 0;
      } else {
        this.spriteID++;
      }
      if (this.spriteID >= spriteMap.length) {
        this.spriteID = 0;
      }
      this.play(true, spriteMap[this.spriteID]);
    } else {
      this.play(true);
    }
    this.forEachChildren("playNextSound");
    console.log("play next sound");
  };
}());

/**
 * Created by Andrewz on 1/1/18.
 * Cmd 系列的文件， 只是用于编辑， 不能用于播放器， 所以要分离
 */

TQ.CommandMgr.setTextProperty = function(ele, option) {
  if (ele && ele.isText()) {
    var oldOption = {};
    var newOption = option;

    var keys = Object.keys(option);
    var jsonObj = ele.jsonObj;
    keys.forEach(function(prop) {
      oldOption[prop] = jsonObj[prop];
    });

    if (option.toggleBold) {
      oldOption.toggleBold = option.toggleBold;
    }

    if (option.toggleItalic) {
      oldOption.toggleItalic = option.toggleItalic;
    }

    return new TQ.GenCommand(["setProperty", "setProperty"], ele, newOption, oldOption);
  }

  return null;
};

// 实用函数库
var __enable_debug_trsa = false;

function throb(element) {
  $(element).animate({ opacity: 1.0 }, 250, function() { $(this).animate({ opacity: 0.5 }, 2000); });
}

function restoreTestSubjects() {
  $(".testSubject,.testSubject *").removeAttr("style");
}

// 总是当做字符串来输出， 即使是HTML，XML， JSON， 也不做任何解析，只是当做普通子串显示出来
function displayInfo2(msg) {
  $("#testLabelInfo").text(msg);
}

// 总是当做字符串来输出， 即使是HTML，XML， JSON， 也不做任何解析，只是当做普通子串显示出来
function displayInfo3(msg) {
  TQ.MessageBubble.counter++;
  TQ.MessageBubble.addMessage(msg);
  if (TQ.MessageBubble.counter >= 2) { //  在保存文件的时候， 总共显示两次返回的信息，完成之后才能关闭
    TQ.MessageBubble.close();
  }
}

function displayJSON(data) {
  var jsonResultFromJQueryAjax = data;
  var msg = JSON.stringify(jsonResultFromJQueryAjax);
  displayInfo2(msg);
}

function isObject(obj) {
  if (obj == null) { return false; }
  return (typeof (obj) === "object") && (obj.constructor === Object);
}

function isFunction(obj) {
  if (obj == null) { return false; }
  return (typeof (obj) === "function") && (obj.constructor === Function);
}

function dumpObject(obj) {
  // variable to save the html content
  var html = "<table border=\"1px\"><tr><th>name</th><th>type</th><th>value</th><th>dump</th></tr>";

  // list all sub objects
  for (var e in obj) {
    var value = obj[e];
    if (isFunction(value)) continue;
    if (isObject(value)) {
      dumpObject(value);
      continue;
    }

    html += "<tr>";

    // get name
    html += "<td>" + e + "</td>";
    // get type
    html += "<td>" + (typeof (value)) + "</td>";
    // get value
    // html+="<td>"+(isFunction(value)||isObject(value)?'':value)+"</td>";
    html += "<td>" + (isFunction(value) || isObject(value) ? "Error" : value) + "</td>";

    // dump the sub object
    html += "<td>" + (isObject(value) ? dumpObject(value) : "") + "</td>";

    html += "</tr>";
  }

  html += "</table>";
  $("#infoRegion").html(html);
  // return html;
}

/**
 * Created by Andrewz on 9/17/2016.
 * convert custom event to angularjs event
 * 因为custome evet是发给document.body, 它只冒泡给上级， 不会给下级，
 * 所以，子元素收不到， 需要在 body上加1个中转器
 */

angular.module("starter").directive("eventconverter", EventConverter);
EventConverter.$inject = ["$rootScope"];
function EventConverter($rootScope) {
  return {
    restrict: "A",
    link: function(scope, element, attrs) {
      var events = [TQ.Scene.EVENT_READY,
        TQ.Scene.EVENT_SAVED,
        TQ.Scene.EVENT_END_OF_PLAY,
        TQ.EVENT.REFRESH_UI];
      events.forEach(function(evt) {
        element.bind(evt, function() {
          $rootScope.$broadcast(evt);
        });
      });
    }
  };
}

/**
 * Created by Andrewz on 1/1/2017.
 */
var TQ = TQ || {};
TQ.Tool = TQ.Tool || {};
(function() {
  var timestamp = new Date().getTime();
  var TEMP_IMG_NODE_ID = "_tq_temp_img" + timestamp;
  var TEMP_LINK_NODE_ID = "_tq_temp_link" + timestamp;

  TQ.Tool.saveImage = saveImage;
  TQ.Tool.resetDom = resetDom;

  function resetDom() {
    var ele;
    ele = document.getElementById(TEMP_IMG_NODE_ID);
    if (ele) {
      ele.remove();
    }

    ele = document.getElementById(TEMP_LINK_NODE_ID);
    if (ele) {
      ele.remove();
    }
  }

  function saveImage(filename) {
    var image = TQ.ScreenShot.getDataWithBkgColor();
    _saveAs(image, filename);
    // _saveWithLocation(image);
  }

  function _saveAs(image64png, filename) {
    // create a new image and add to the document
    var imgNode = document.getElementById(TEMP_IMG_NODE_ID);
    if (imgNode) { // 防止未清除的
      resetDom();
    }

    imgNode = document.createElement("img");
    imgNode.src = image64png;
    imgNode.id = TEMP_IMG_NODE_ID;
    document.body.appendChild(imgNode);

    var link = document.getElementById(TEMP_LINK_NODE_ID);
    if (!link) {
      link = document.createElement("a");
    }

    link.download = filename;
    link.href = image64png;
    link.click();
    setTimeout(resetDom, 1000);
  }
}());
